/**
 * Copyright (c) 2014-2016 by the respective copyright holders.
 *
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Eclipse Public License v1.0
 * which accompanies this distribution, and is available at
 * http://www.eclipse.org/legal/epl-v10.html
 */
package com.zsmartsystems.zwave.commandclass.impl;

import java.io.ByteArrayOutputStream;
import java.io.IOException;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

/**
 * Class to implement the Z-Wave command class <b>COMMAND_CLASS_IRRIGATION</b> version <b>1</b>.<br>
 *
 * Command Class Irrigation<br>
 *
 * This class provides static methods for processing received messages (message handler) and
 * methods to get a message to send on the Z-Wave network.<br>
 *
 * Note that this code is autogenerated. Manual changes may be overwritten.
 *
 * @author Chris Jackson - Initial contribution of Java code generator
 */
public class CommandClassIrrigationV1 {
    private static final Logger logger = LoggerFactory.getLogger(CommandClassIrrigationV1.class);

    /**
     * Integer command class key for COMMAND_CLASS_IRRIGATION
     */
    public final static int COMMAND_CLASS_KEY = 0x6B;

    /**
     * Irrigation System Info Get Command Constant
     */
    public final static int IRRIGATION_SYSTEM_INFO_GET = 0x01;
    /**
     * Irrigation System Info Report Command Constant
     */
    public final static int IRRIGATION_SYSTEM_INFO_REPORT = 0x02;
    /**
     * Irrigation System Status Get Command Constant
     */
    public final static int IRRIGATION_SYSTEM_STATUS_GET = 0x03;
    /**
     * Irrigation System Status Report Command Constant
     */
    public final static int IRRIGATION_SYSTEM_STATUS_REPORT = 0x04;
    /**
     * Irrigation System Config Set Command Constant
     */
    public final static int IRRIGATION_SYSTEM_CONFIG_SET = 0x05;
    /**
     * Irrigation System Config Get Command Constant
     */
    public final static int IRRIGATION_SYSTEM_CONFIG_GET = 0x06;
    /**
     * Irrigation System Config Report Command Constant
     */
    public final static int IRRIGATION_SYSTEM_CONFIG_REPORT = 0x07;
    /**
     * Irrigation Valve Info Get Command Constant
     */
    public final static int IRRIGATION_VALVE_INFO_GET = 0x08;
    /**
     * Irrigation Valve Info Report Command Constant
     */
    public final static int IRRIGATION_VALVE_INFO_REPORT = 0x09;
    /**
     * Irrigation Valve Config Set Command Constant
     */
    public final static int IRRIGATION_VALVE_CONFIG_SET = 0x0A;
    /**
     * Irrigation Valve Config Get Command Constant
     */
    public final static int IRRIGATION_VALVE_CONFIG_GET = 0x0B;
    /**
     * Irrigation Valve Config Report Command Constant
     */
    public final static int IRRIGATION_VALVE_CONFIG_REPORT = 0x0C;
    /**
     * Irrigation Valve Run Command Constant
     */
    public final static int IRRIGATION_VALVE_RUN = 0x0D;
    /**
     * Irrigation Valve Table Set Command Constant
     */
    public final static int IRRIGATION_VALVE_TABLE_SET = 0x0E;
    /**
     * Irrigation Valve Table Get Command Constant
     */
    public final static int IRRIGATION_VALVE_TABLE_GET = 0x0F;
    /**
     * Irrigation Valve Table Report Command Constant
     */
    public final static int IRRIGATION_VALVE_TABLE_REPORT = 0x10;
    /**
     * Irrigation Valve Table Run Command Constant
     */
    public final static int IRRIGATION_VALVE_TABLE_RUN = 0x11;
    /**
     * Irrigation System Shutoff Command Constant
     */
    public final static int IRRIGATION_SYSTEM_SHUTOFF = 0x12;

    /**
     * Creates a new message with the IRRIGATION_SYSTEM_INFO_GET command.<br>
     *
     * Irrigation System Info Get<br>
     *
     *
     * @return the {@link byte[]} array with the command to send
     */
    static public byte[] getIrrigationSystemInfoGet() {
        logger.debug("Creating command message IRRIGATION_SYSTEM_INFO_GET version 1");

        ByteArrayOutputStream outputData = new ByteArrayOutputStream();
        outputData.write(COMMAND_CLASS_KEY);
        outputData.write(IRRIGATION_SYSTEM_INFO_GET);

        return outputData.toByteArray();
    }

    /**
     * Processes a received frame with the IRRIGATION_SYSTEM_INFO_GET command<br>
     *
     * Irrigation System Info Get<br>
     *
     *
     * @param payload the {@link byte[]} payload data to process
     * @return a {@link Map} of processed response data
     */
    public static Map<String, Object> handleIrrigationSystemInfoGet(byte[] payload) {
        // Create our response map
        Map<String, Object> response = new HashMap<String, Object>();

        // Return the map of processed response data;
        return response;
    }

    /**
     * Creates a new message with the IRRIGATION_SYSTEM_INFO_REPORT command.<br>
     *
     * Irrigation System Info Report<br>
     *
     *
     * @param masterValve {@link Boolean}
     * @param totalNumberOfValves {@link Integer}
     * @param totalNumberOfValveTables {@link Integer}
     * @param valveTableMaxSize {@link Integer}
     * @return the {@link byte[]} array with the command to send
     */
    static public byte[] getIrrigationSystemInfoReport(Boolean masterValve, Integer totalNumberOfValves,
            Integer totalNumberOfValveTables, Integer valveTableMaxSize) {
        logger.debug("Creating command message IRRIGATION_SYSTEM_INFO_REPORT version 1");

        ByteArrayOutputStream outputData = new ByteArrayOutputStream();
        outputData.write(COMMAND_CLASS_KEY);
        outputData.write(IRRIGATION_SYSTEM_INFO_REPORT);

        // Process 'Properties1'
        outputData.write(masterValve ? 0x01 : 0);

        // Process 'Total Number of Valves'
        outputData.write(totalNumberOfValves);

        // Process 'Total Number of Valve Tables'
        outputData.write(totalNumberOfValveTables);

        // Process 'Properties2'
        outputData.write(valveTableMaxSize & 0x0F);

        return outputData.toByteArray();
    }

    /**
     * Processes a received frame with the IRRIGATION_SYSTEM_INFO_REPORT command<br>
     *
     * Irrigation System Info Report<br>
     *
     *
     * The output data {@link Map} has the following properties<br>
     *
     * <ul>
     * <li>MASTER_VALVE {@link Boolean}
     * <li>TOTAL_NUMBER_OF_VALVES {@link Integer}
     * <li>TOTAL_NUMBER_OF_VALVE_TABLES {@link Integer}
     * <li>VALVE_TABLE_MAX_SIZE {@link Integer}
     * </ul>
     *
     * @param payload the {@link byte[]} payload data to process
     * @return a {@link Map} of processed response data
     */
    public static Map<String, Object> handleIrrigationSystemInfoReport(byte[] payload) {
        // Create our response map
        Map<String, Object> response = new HashMap<String, Object>();

        // Process 'Properties1'
        response.put("MASTER_VALVE", Boolean.valueOf((payload[2] & 0x01) != 0));

        // Process 'Total Number of Valves'
        response.put("TOTAL_NUMBER_OF_VALVES", Integer.valueOf(payload[3]));

        // Process 'Total Number of Valve Tables'
        response.put("TOTAL_NUMBER_OF_VALVE_TABLES", Integer.valueOf(payload[4]));

        // Process 'Properties2'
        response.put("VALVE_TABLE_MAX_SIZE", Integer.valueOf(payload[5] & 0x0F));

        // Return the map of processed response data;
        return response;
    }

    /**
     * Creates a new message with the IRRIGATION_SYSTEM_STATUS_GET command.<br>
     *
     * Irrigation System Status Get<br>
     *
     *
     * @return the {@link byte[]} array with the command to send
     */
    static public byte[] getIrrigationSystemStatusGet() {
        logger.debug("Creating command message IRRIGATION_SYSTEM_STATUS_GET version 1");

        ByteArrayOutputStream outputData = new ByteArrayOutputStream();
        outputData.write(COMMAND_CLASS_KEY);
        outputData.write(IRRIGATION_SYSTEM_STATUS_GET);

        return outputData.toByteArray();
    }

    /**
     * Processes a received frame with the IRRIGATION_SYSTEM_STATUS_GET command<br>
     *
     * Irrigation System Status Get<br>
     *
     *
     * @param payload the {@link byte[]} payload data to process
     * @return a {@link Map} of processed response data
     */
    public static Map<String, Object> handleIrrigationSystemStatusGet(byte[] payload) {
        // Create our response map
        Map<String, Object> response = new HashMap<String, Object>();

        // Return the map of processed response data;
        return response;
    }

    /**
     * Creates a new message with the IRRIGATION_SYSTEM_STATUS_REPORT command.<br>
     *
     * Irrigation System Status Report<br>
     *
     *
     * @param systemVoltage {@link Integer}
     * @param sensorStatus {@link String}
     * @param flowValue {@link byte[]}
     * @param pressureValue {@link byte[]}
     * @param shutoffDuration {@link Integer}
     * @param systemErrorStatus {@link List<String>}
     * @param masterValve {@link Boolean}
     * @param valveId {@link Integer}
     * @return the {@link byte[]} array with the command to send
     */
    static public byte[] getIrrigationSystemStatusReport(Integer systemVoltage, String sensorStatus, byte[] flowValue,
            byte[] pressureValue, Integer shutoffDuration, List<String> systemErrorStatus, Boolean masterValve,
            Integer valveId) {
        logger.debug("Creating command message IRRIGATION_SYSTEM_STATUS_REPORT version 1");

        ByteArrayOutputStream outputData = new ByteArrayOutputStream();
        outputData.write(COMMAND_CLASS_KEY);
        outputData.write(IRRIGATION_SYSTEM_STATUS_REPORT);

        // Process 'System Voltage'
        outputData.write(systemVoltage);

        // Process 'Sensor Status'
        switch (sensorStatus) {
            case "FLOW_SENSOR_DETECTED":
                outputData.write(0x00);
                break;
            case "PRESSURE_SENSOR_DETECTED":
                outputData.write(0x01);
                break;
            case "RAIN_SENSOR_DETECTED":
                outputData.write(0x02);
                break;
            case "MOISTURE_SENSOR_DETECTED":
                outputData.write(0x03);
                break;
            default:
                throw new IllegalArgumentException("Unknown constant value for sensorStatus: " + sensorStatus);
        }

        // Process 'Properties1'
        int valProperties1 = 0;
        valProperties1 |= 0;
        valProperties1 |= ((1 << 3) & 0x18);
        valProperties1 |= ((1 << 5) & 0xE0);
        outputData.write(valProperties1);

        // Process 'Flow Value'
        try {
            outputData.write(flowValue);
        } catch (IOException e) {
        }

        // Process 'Properties2'
        int valProperties2 = 0;
        valProperties2 |= 0;
        valProperties2 |= ((1 << 3) & 0x18);
        valProperties2 |= ((1 << 5) & 0xE0);
        outputData.write(valProperties2);

        // Process 'Pressure Value'
        try {
            outputData.write(pressureValue);
        } catch (IOException e) {
        }

        // Process 'Shutoff Duration'
        outputData.write(shutoffDuration);

        // Process 'System Error Status'
        int valSystemErrorStatus = 0;
        valSystemErrorStatus |= (systemErrorStatus.contains("NOT_PROGRAMMED") ? 0x01 : 0);
        valSystemErrorStatus |= (systemErrorStatus.contains("EMERGENCY_SHUTDOWN") ? 0x02 : 0);
        valSystemErrorStatus |= (systemErrorStatus.contains("HIGH_THRESHOLD_TRIGGERED") ? 0x04 : 0);
        valSystemErrorStatus |= (systemErrorStatus.contains("LOW_THRESHOLD_TRIGGERED") ? 0x08 : 0);
        valSystemErrorStatus |= (systemErrorStatus.contains("VALVE_ERRORS") ? 0x10 : 0);
        outputData.write(valSystemErrorStatus);

        // Process 'Properties3'
        outputData.write(masterValve ? 0x01 : 0);

        // Process 'Valve ID'
        outputData.write(valveId);

        return outputData.toByteArray();
    }

    /**
     * Processes a received frame with the IRRIGATION_SYSTEM_STATUS_REPORT command<br>
     *
     * Irrigation System Status Report<br>
     *
     *
     * The output data {@link Map} has the following properties<br>
     *
     * <ul>
     * <li>SYSTEM_VOLTAGE {@link Integer}
     * <li>SENSOR_STATUS {@link String}
     * <li>FLOW_VALUE {@link byte[]}
     * <li>PRESSURE_VALUE {@link byte[]}
     * <li>SHUTOFF_DURATION {@link Integer}
     * <li>SYSTEM_ERROR_STATUS {@link List}<{@link String}>
     * <li>MASTER_VALVE {@link Boolean}
     * <li>VALVE_ID {@link Integer}
     * </ul>
     *
     * @param payload the {@link byte[]} payload data to process
     * @return a {@link Map} of processed response data
     */
    public static Map<String, Object> handleIrrigationSystemStatusReport(byte[] payload) {
        // Create our response map
        Map<String, Object> response = new HashMap<String, Object>();

        // We're using variable length fields, so track the offset
        int msgOffset = 2;

        // Process 'System Voltage'
        response.put("SYSTEM_VOLTAGE", Integer.valueOf(payload[msgOffset]));
        msgOffset += 1;

        // Process 'Sensor Status'
        switch ((int) payload[msgOffset]) {
            case (byte) 0x00:
                response.put("SENSOR_STATUS", "FLOW_SENSOR_DETECTED");
                break;
            case (byte) 0x01:
                response.put("SENSOR_STATUS", "PRESSURE_SENSOR_DETECTED");
                break;
            case (byte) 0x02:
                response.put("SENSOR_STATUS", "RAIN_SENSOR_DETECTED");
                break;
            case (byte) 0x03:
                response.put("SENSOR_STATUS", "MOISTURE_SENSOR_DETECTED");
                break;
            default:
                logger.debug("Unknown value {} for constant 'SENSOR_STATUS'", String.format("%02X", payload[msgOffset]));
                response.put("SENSOR_STATUS", "UNKNOWN_" + String.format("%02X", payload[msgOffset]));
                break;
        }
        msgOffset += 1;

        // Process 'Properties1'
        msgOffset += 1;

        // Process 'Flow Value'
        int valFlowValue = 0;
        int lenFlowValue = payload[msgOffset - 1] & 0x07;
        for (int cntFlowValue = 0; cntFlowValue < lenFlowValue; cntFlowValue++) {
            valFlowValue = (valFlowValue << 8) + payload[msgOffset + cntFlowValue];
        }
        response.put("FLOW_VALUE", valFlowValue);
        msgOffset += lenFlowValue;

        // Process 'Properties2'
        msgOffset += 1;

        // Process 'Pressure Value'
        int valPressureValue = 0;
        int lenPressureValue = payload[msgOffset - 1] & 0x07;
        for (int cntPressureValue = 0; cntPressureValue < lenPressureValue; cntPressureValue++) {
            valPressureValue = (valPressureValue << 8) + payload[msgOffset + cntPressureValue];
        }
        response.put("PRESSURE_VALUE", valPressureValue);
        msgOffset += lenPressureValue;

        // Process 'Shutoff Duration'
        response.put("SHUTOFF_DURATION", Integer.valueOf(payload[msgOffset]));
        msgOffset += 1;

        // Process 'System Error Status'
        List<String> responseSystemErrorStatus = new ArrayList<String>();
        int lenSystemErrorStatus = 1;
        for (int cntSystemErrorStatus = 0; cntSystemErrorStatus < lenSystemErrorStatus; cntSystemErrorStatus++) {
            if ((payload[msgOffset + (cntSystemErrorStatus / 8)] & cntSystemErrorStatus % 8) == 0) {
                continue;
            }
            switch (cntSystemErrorStatus) {
                case 0x00:
                    responseSystemErrorStatus.add("NOT_PROGRAMMED");
                    break;
                case 0x01:
                    responseSystemErrorStatus.add("EMERGENCY_SHUTDOWN");
                    break;
                case 0x02:
                    responseSystemErrorStatus.add("HIGH_THRESHOLD_TRIGGERED");
                    break;
                case 0x03:
                    responseSystemErrorStatus.add("LOW_THRESHOLD_TRIGGERED");
                    break;
                case 0x04:
                    responseSystemErrorStatus.add("VALVE_ERRORS");
                    break;
                default:
                    responseSystemErrorStatus.add("BITMASK_" + cntSystemErrorStatus);
                    break;
            }
        }
        response.put("SYSTEM_ERROR_STATUS", responseSystemErrorStatus);
        msgOffset += 1;

        // Process 'Properties3'
        response.put("MASTER_VALVE", Boolean.valueOf((payload[msgOffset] & 0x01) != 0));
        msgOffset += 1;

        // Process 'Valve ID'
        response.put("VALVE_ID", Integer.valueOf(payload[msgOffset]));
        msgOffset += 1;

        // Return the map of processed response data;
        return response;
    }

    /**
     * Creates a new message with the IRRIGATION_SYSTEM_CONFIG_SET command.<br>
     *
     * Irrigation System Config Set<br>
     *
     *
     * @param masterValveDelay {@link Integer}
     * @param highPressureThresholdValue {@link byte[]}
     * @param lowPressureThresholdValue {@link byte[]}
     * @param sensorPolarity {@link List<String>}
     * @return the {@link byte[]} array with the command to send
     */
    static public byte[] getIrrigationSystemConfigSet(Integer masterValveDelay, byte[] highPressureThresholdValue,
            byte[] lowPressureThresholdValue, List<String> sensorPolarity) {
        logger.debug("Creating command message IRRIGATION_SYSTEM_CONFIG_SET version 1");

        ByteArrayOutputStream outputData = new ByteArrayOutputStream();
        outputData.write(COMMAND_CLASS_KEY);
        outputData.write(IRRIGATION_SYSTEM_CONFIG_SET);

        // Process 'Master Valve Delay'
        outputData.write(masterValveDelay);

        // Process 'Properties1'
        int valProperties1 = 0;
        valProperties1 |= 0;
        valProperties1 |= ((1 << 3) & 0x18);
        valProperties1 |= ((1 << 5) & 0xE0);
        outputData.write(valProperties1);

        // Process 'High Pressure Threshold Value'
        try {
            outputData.write(highPressureThresholdValue);
        } catch (IOException e) {
        }

        // Process 'Properties2'
        int valProperties2 = 0;
        valProperties2 |= 0;
        valProperties2 |= ((1 << 3) & 0x18);
        valProperties2 |= ((1 << 5) & 0xE0);
        outputData.write(valProperties2);

        // Process 'Low Pressure Threshold Value'
        try {
            outputData.write(lowPressureThresholdValue);
        } catch (IOException e) {
        }

        // Process 'Sensor Polarity'
        int valSensorPolarity = 0;
        valSensorPolarity |= (sensorPolarity.contains("RAIN_SENSOR_POLARITY") ? 0x01 : 0);
        valSensorPolarity |= (sensorPolarity.contains("MOISTURE_SENSOR_POLARITY") ? 0x02 : 0);
        valSensorPolarity |= (sensorPolarity.contains("VALID") ? 0x80 : 0);
        outputData.write(valSensorPolarity);

        return outputData.toByteArray();
    }

    /**
     * Processes a received frame with the IRRIGATION_SYSTEM_CONFIG_SET command<br>
     *
     * Irrigation System Config Set<br>
     *
     *
     * The output data {@link Map} has the following properties<br>
     *
     * <ul>
     * <li>MASTER_VALVE_DELAY {@link Integer}
     * <li>HIGH_PRESSURE_THRESHOLD_VALUE {@link byte[]}
     * <li>LOW_PRESSURE_THRESHOLD_VALUE {@link byte[]}
     * <li>SENSOR_POLARITY {@link List}<{@link String}>
     * </ul>
     *
     * @param payload the {@link byte[]} payload data to process
     * @return a {@link Map} of processed response data
     */
    public static Map<String, Object> handleIrrigationSystemConfigSet(byte[] payload) {
        // Create our response map
        Map<String, Object> response = new HashMap<String, Object>();

        // We're using variable length fields, so track the offset
        int msgOffset = 2;

        // Process 'Master Valve Delay'
        response.put("MASTER_VALVE_DELAY", Integer.valueOf(payload[msgOffset]));
        msgOffset += 1;

        // Process 'Properties1'
        msgOffset += 1;

        // Process 'High Pressure Threshold Value'
        int valHighPressureThresholdValue = 0;
        int lenHighPressureThresholdValue = payload[msgOffset - 1] & 0x07;
        for (int cntHighPressureThresholdValue = 0; cntHighPressureThresholdValue < lenHighPressureThresholdValue; cntHighPressureThresholdValue++) {
            valHighPressureThresholdValue = (valHighPressureThresholdValue << 8) + payload[msgOffset + cntHighPressureThresholdValue];
        }
        response.put("HIGH_PRESSURE_THRESHOLD_VALUE", valHighPressureThresholdValue);
        msgOffset += lenHighPressureThresholdValue;

        // Process 'Properties2'
        msgOffset += 1;

        // Process 'Low Pressure Threshold Value'
        int valLowPressureThresholdValue = 0;
        int lenLowPressureThresholdValue = payload[msgOffset - 1] & 0x07;
        for (int cntLowPressureThresholdValue = 0; cntLowPressureThresholdValue < lenLowPressureThresholdValue; cntLowPressureThresholdValue++) {
            valLowPressureThresholdValue = (valLowPressureThresholdValue << 8) + payload[msgOffset + cntLowPressureThresholdValue];
        }
        response.put("LOW_PRESSURE_THRESHOLD_VALUE", valLowPressureThresholdValue);
        msgOffset += lenLowPressureThresholdValue;

        // Process 'Sensor Polarity'
        List<String> responseSensorPolarity = new ArrayList<String>();
        int lenSensorPolarity = 1;
        for (int cntSensorPolarity = 0; cntSensorPolarity < lenSensorPolarity; cntSensorPolarity++) {
            if ((payload[msgOffset + (cntSensorPolarity / 8)] & cntSensorPolarity % 8) == 0) {
                continue;
            }
            switch (cntSensorPolarity) {
                case 0x00:
                    responseSensorPolarity.add("RAIN_SENSOR_POLARITY");
                    break;
                case 0x01:
                    responseSensorPolarity.add("MOISTURE_SENSOR_POLARITY");
                    break;
                case 0x07:
                    responseSensorPolarity.add("VALID");
                    break;
                default:
                    responseSensorPolarity.add("BITMASK_" + cntSensorPolarity);
                    break;
            }
        }
        response.put("SENSOR_POLARITY", responseSensorPolarity);
        msgOffset += 1;

        // Return the map of processed response data;
        return response;
    }

    /**
     * Creates a new message with the IRRIGATION_SYSTEM_CONFIG_GET command.<br>
     *
     * Irrigation System Config Get<br>
     *
     *
     * @return the {@link byte[]} array with the command to send
     */
    static public byte[] getIrrigationSystemConfigGet() {
        logger.debug("Creating command message IRRIGATION_SYSTEM_CONFIG_GET version 1");

        ByteArrayOutputStream outputData = new ByteArrayOutputStream();
        outputData.write(COMMAND_CLASS_KEY);
        outputData.write(IRRIGATION_SYSTEM_CONFIG_GET);

        return outputData.toByteArray();
    }

    /**
     * Processes a received frame with the IRRIGATION_SYSTEM_CONFIG_GET command<br>
     *
     * Irrigation System Config Get<br>
     *
     *
     * @param payload the {@link byte[]} payload data to process
     * @return a {@link Map} of processed response data
     */
    public static Map<String, Object> handleIrrigationSystemConfigGet(byte[] payload) {
        // Create our response map
        Map<String, Object> response = new HashMap<String, Object>();

        // Return the map of processed response data;
        return response;
    }

    /**
     * Creates a new message with the IRRIGATION_SYSTEM_CONFIG_REPORT command.<br>
     *
     * Irrigation System Config Report<br>
     *
     *
     * @param masterValveDelay {@link Integer}
     * @param highPressureThresholdValue {@link byte[]}
     * @param lowPressureThresholdValue {@link byte[]}
     * @param sensorPolarity {@link List<String>}
     * @return the {@link byte[]} array with the command to send
     */
    static public byte[] getIrrigationSystemConfigReport(Integer masterValveDelay, byte[] highPressureThresholdValue,
            byte[] lowPressureThresholdValue, List<String> sensorPolarity) {
        logger.debug("Creating command message IRRIGATION_SYSTEM_CONFIG_REPORT version 1");

        ByteArrayOutputStream outputData = new ByteArrayOutputStream();
        outputData.write(COMMAND_CLASS_KEY);
        outputData.write(IRRIGATION_SYSTEM_CONFIG_REPORT);

        // Process 'Master Valve Delay'
        outputData.write(masterValveDelay);

        // Process 'Properties1'
        int valProperties1 = 0;
        valProperties1 |= 0;
        valProperties1 |= ((1 << 3) & 0x18);
        valProperties1 |= ((1 << 5) & 0xE0);
        outputData.write(valProperties1);

        // Process 'High Pressure Threshold Value'
        try {
            outputData.write(highPressureThresholdValue);
        } catch (IOException e) {
        }

        // Process 'Properties2'
        int valProperties2 = 0;
        valProperties2 |= 0;
        valProperties2 |= ((1 << 3) & 0x18);
        valProperties2 |= ((1 << 5) & 0xE0);
        outputData.write(valProperties2);

        // Process 'Low Pressure Threshold Value'
        try {
            outputData.write(lowPressureThresholdValue);
        } catch (IOException e) {
        }

        // Process 'Sensor Polarity'
        int valSensorPolarity = 0;
        valSensorPolarity |= (sensorPolarity.contains("RAIN_SENSOR_POLARITY") ? 0x01 : 0);
        valSensorPolarity |= (sensorPolarity.contains("MOISTURE_SENSOR_POLARITY") ? 0x02 : 0);
        valSensorPolarity |= (sensorPolarity.contains("VALID") ? 0x80 : 0);
        outputData.write(valSensorPolarity);

        return outputData.toByteArray();
    }

    /**
     * Processes a received frame with the IRRIGATION_SYSTEM_CONFIG_REPORT command<br>
     *
     * Irrigation System Config Report<br>
     *
     *
     * The output data {@link Map} has the following properties<br>
     *
     * <ul>
     * <li>MASTER_VALVE_DELAY {@link Integer}
     * <li>HIGH_PRESSURE_THRESHOLD_VALUE {@link byte[]}
     * <li>LOW_PRESSURE_THRESHOLD_VALUE {@link byte[]}
     * <li>SENSOR_POLARITY {@link List}<{@link String}>
     * </ul>
     *
     * @param payload the {@link byte[]} payload data to process
     * @return a {@link Map} of processed response data
     */
    public static Map<String, Object> handleIrrigationSystemConfigReport(byte[] payload) {
        // Create our response map
        Map<String, Object> response = new HashMap<String, Object>();

        // We're using variable length fields, so track the offset
        int msgOffset = 2;

        // Process 'Master Valve Delay'
        response.put("MASTER_VALVE_DELAY", Integer.valueOf(payload[msgOffset]));
        msgOffset += 1;

        // Process 'Properties1'
        msgOffset += 1;

        // Process 'High Pressure Threshold Value'
        int valHighPressureThresholdValue = 0;
        int lenHighPressureThresholdValue = payload[msgOffset - 1] & 0x07;
        for (int cntHighPressureThresholdValue = 0; cntHighPressureThresholdValue < lenHighPressureThresholdValue; cntHighPressureThresholdValue++) {
            valHighPressureThresholdValue = (valHighPressureThresholdValue << 8) + payload[msgOffset + cntHighPressureThresholdValue];
        }
        response.put("HIGH_PRESSURE_THRESHOLD_VALUE", valHighPressureThresholdValue);
        msgOffset += lenHighPressureThresholdValue;

        // Process 'Properties2'
        msgOffset += 1;

        // Process 'Low Pressure Threshold Value'
        int valLowPressureThresholdValue = 0;
        int lenLowPressureThresholdValue = payload[msgOffset - 1] & 0x07;
        for (int cntLowPressureThresholdValue = 0; cntLowPressureThresholdValue < lenLowPressureThresholdValue; cntLowPressureThresholdValue++) {
            valLowPressureThresholdValue = (valLowPressureThresholdValue << 8) + payload[msgOffset + cntLowPressureThresholdValue];
        }
        response.put("LOW_PRESSURE_THRESHOLD_VALUE", valLowPressureThresholdValue);
        msgOffset += lenLowPressureThresholdValue;

        // Process 'Sensor Polarity'
        List<String> responseSensorPolarity = new ArrayList<String>();
        int lenSensorPolarity = 1;
        for (int cntSensorPolarity = 0; cntSensorPolarity < lenSensorPolarity; cntSensorPolarity++) {
            if ((payload[msgOffset + (cntSensorPolarity / 8)] & cntSensorPolarity % 8) == 0) {
                continue;
            }
            switch (cntSensorPolarity) {
                case 0x00:
                    responseSensorPolarity.add("RAIN_SENSOR_POLARITY");
                    break;
                case 0x01:
                    responseSensorPolarity.add("MOISTURE_SENSOR_POLARITY");
                    break;
                case 0x07:
                    responseSensorPolarity.add("VALID");
                    break;
                default:
                    responseSensorPolarity.add("BITMASK_" + cntSensorPolarity);
                    break;
            }
        }
        response.put("SENSOR_POLARITY", responseSensorPolarity);
        msgOffset += 1;

        // Return the map of processed response data;
        return response;
    }

    /**
     * Creates a new message with the IRRIGATION_VALVE_INFO_GET command.<br>
     *
     * Irrigation Valve Info Get<br>
     *
     *
     * @param masterValve {@link Boolean}
     * @param valveId {@link Integer}
     * @return the {@link byte[]} array with the command to send
     */
    static public byte[] getIrrigationValveInfoGet(Boolean masterValve, Integer valveId) {
        logger.debug("Creating command message IRRIGATION_VALVE_INFO_GET version 1");

        ByteArrayOutputStream outputData = new ByteArrayOutputStream();
        outputData.write(COMMAND_CLASS_KEY);
        outputData.write(IRRIGATION_VALVE_INFO_GET);

        // Process 'Properties1'
        outputData.write(masterValve ? 0x01 : 0);

        // Process 'Valve ID'
        outputData.write(valveId);

        return outputData.toByteArray();
    }

    /**
     * Processes a received frame with the IRRIGATION_VALVE_INFO_GET command<br>
     *
     * Irrigation Valve Info Get<br>
     *
     *
     * The output data {@link Map} has the following properties<br>
     *
     * <ul>
     * <li>MASTER_VALVE {@link Boolean}
     * <li>VALVE_ID {@link Integer}
     * </ul>
     *
     * @param payload the {@link byte[]} payload data to process
     * @return a {@link Map} of processed response data
     */
    public static Map<String, Object> handleIrrigationValveInfoGet(byte[] payload) {
        // Create our response map
        Map<String, Object> response = new HashMap<String, Object>();

        // Process 'Properties1'
        response.put("MASTER_VALVE", Boolean.valueOf((payload[2] & 0x01) != 0));

        // Process 'Valve ID'
        response.put("VALVE_ID", Integer.valueOf(payload[3]));

        // Return the map of processed response data;
        return response;
    }

    /**
     * Creates a new message with the IRRIGATION_VALVE_INFO_REPORT command.<br>
     *
     * Irrigation Valve Info Report<br>
     *
     *
     * @param master {@link Boolean}
     * @param connected {@link Boolean}
     * @param valveId {@link Integer}
     * @param nominalCurrent {@link Integer}
     * @param valveErrorStatus {@link List<String>}
     * @return the {@link byte[]} array with the command to send
     */
    static public byte[] getIrrigationValveInfoReport(Boolean master, Boolean connected, Integer valveId,
            Integer nominalCurrent, List<String> valveErrorStatus) {
        logger.debug("Creating command message IRRIGATION_VALVE_INFO_REPORT version 1");

        ByteArrayOutputStream outputData = new ByteArrayOutputStream();
        outputData.write(COMMAND_CLASS_KEY);
        outputData.write(IRRIGATION_VALVE_INFO_REPORT);

        // Process 'Properties1'
        int valProperties1 = 0;
        valProperties1 |= master ? 0x01 : 0;
        valProperties1 |= connected ? 0x02 : 0;
        outputData.write(valProperties1);

        // Process 'Valve ID'
        outputData.write(valveId);

        // Process 'Nominal Current'
        outputData.write(nominalCurrent);

        // Process 'Valve Error Status'
        int valValveErrorStatus = 0;
        valValveErrorStatus |= (valveErrorStatus.contains("SHORT_CIRCUIT") ? 0x01 : 0);
        valValveErrorStatus |= (valveErrorStatus.contains("CURRENT_HIGH_THRESHOLD") ? 0x02 : 0);
        valValveErrorStatus |= (valveErrorStatus.contains("CURRENT_LOW_THRESHOLD") ? 0x04 : 0);
        valValveErrorStatus |= (valveErrorStatus.contains("MAXIMUM_FLOW") ? 0x08 : 0);
        valValveErrorStatus |= (valveErrorStatus.contains("FLOW_HIGH_THRESHOLD") ? 0x10 : 0);
        valValveErrorStatus |= (valveErrorStatus.contains("FLOW_LOW_THRESHOLD") ? 0x20 : 0);
        outputData.write(valValveErrorStatus);

        return outputData.toByteArray();
    }

    /**
     * Processes a received frame with the IRRIGATION_VALVE_INFO_REPORT command<br>
     *
     * Irrigation Valve Info Report<br>
     *
     *
     * The output data {@link Map} has the following properties<br>
     *
     * <ul>
     * <li>MASTER {@link Boolean}
     * <li>CONNECTED {@link Boolean}
     * <li>VALVE_ID {@link Integer}
     * <li>NOMINAL_CURRENT {@link Integer}
     * <li>VALVE_ERROR_STATUS {@link List}<{@link String}>
     * </ul>
     *
     * @param payload the {@link byte[]} payload data to process
     * @return a {@link Map} of processed response data
     */
    public static Map<String, Object> handleIrrigationValveInfoReport(byte[] payload) {
        // Create our response map
        Map<String, Object> response = new HashMap<String, Object>();

        // Process 'Properties1'
        response.put("MASTER", Boolean.valueOf((payload[2] & 0x01) != 0));
        response.put("CONNECTED", Boolean.valueOf((payload[2] & 0x02) != 0));

        // Process 'Valve ID'
        response.put("VALVE_ID", Integer.valueOf(payload[3]));

        // Process 'Nominal Current'
        response.put("NOMINAL_CURRENT", Integer.valueOf(payload[4]));

        // Process 'Valve Error Status'
        List<String> responseValveErrorStatus = new ArrayList<String>();
        int lenValveErrorStatus = 1;
        for (int cntValveErrorStatus = 0; cntValveErrorStatus < lenValveErrorStatus; cntValveErrorStatus++) {
            if ((payload[5 + (cntValveErrorStatus / 8)] & cntValveErrorStatus % 8) == 0) {
                continue;
            }
            switch (cntValveErrorStatus) {
                case 0x00:
                    responseValveErrorStatus.add("SHORT_CIRCUIT");
                    break;
                case 0x01:
                    responseValveErrorStatus.add("CURRENT_HIGH_THRESHOLD");
                    break;
                case 0x02:
                    responseValveErrorStatus.add("CURRENT_LOW_THRESHOLD");
                    break;
                case 0x03:
                    responseValveErrorStatus.add("MAXIMUM_FLOW");
                    break;
                case 0x04:
                    responseValveErrorStatus.add("FLOW_HIGH_THRESHOLD");
                    break;
                case 0x05:
                    responseValveErrorStatus.add("FLOW_LOW_THRESHOLD");
                    break;
                default:
                    responseValveErrorStatus.add("BITMASK_" + cntValveErrorStatus);
                    break;
            }
        }
        response.put("VALVE_ERROR_STATUS", responseValveErrorStatus);

        // Return the map of processed response data;
        return response;
    }

    /**
     * Creates a new message with the IRRIGATION_VALVE_CONFIG_SET command.<br>
     *
     * Irrigation Valve Config Set<br>
     *
     *
     * @param masterValve {@link Boolean}
     * @param valveId {@link Integer}
     * @param nominalCurrentHighThreshold {@link Integer}
     * @param nominalCurrentLowThreshold {@link Integer}
     * @param maximumFlowValue {@link byte[]}
     * @param flowHighThresholdValue {@link byte[]}
     * @param flowLowThresholdValue {@link byte[]}
     * @param sensorUsage {@link List<String>}
     * @return the {@link byte[]} array with the command to send
     */
    static public byte[] getIrrigationValveConfigSet(Boolean masterValve, Integer valveId,
            Integer nominalCurrentHighThreshold, Integer nominalCurrentLowThreshold, byte[] maximumFlowValue,
            byte[] flowHighThresholdValue, byte[] flowLowThresholdValue, List<String> sensorUsage) {
        logger.debug("Creating command message IRRIGATION_VALVE_CONFIG_SET version 1");

        ByteArrayOutputStream outputData = new ByteArrayOutputStream();
        outputData.write(COMMAND_CLASS_KEY);
        outputData.write(IRRIGATION_VALVE_CONFIG_SET);

        // Process 'Properties1'
        outputData.write(masterValve ? 0x01 : 0);

        // Process 'Valve ID'
        outputData.write(valveId);

        // Process 'Nominal Current High Threshold'
        outputData.write(nominalCurrentHighThreshold);

        // Process 'Nominal Current Low Threshold'
        outputData.write(nominalCurrentLowThreshold);

        // Process 'Properties2'
        int valProperties2 = 0;
        valProperties2 |= 0;
        valProperties2 |= ((1 << 3) & 0x18);
        valProperties2 |= ((1 << 5) & 0xE0);
        outputData.write(valProperties2);

        // Process 'Maximum Flow Value'
        try {
            outputData.write(maximumFlowValue);
        } catch (IOException e) {
        }

        // Process 'Properties3'
        int valProperties3 = 0;
        valProperties3 |= 0;
        valProperties3 |= ((1 << 3) & 0x18);
        valProperties3 |= ((1 << 5) & 0xE0);
        outputData.write(valProperties3);

        // Process 'Flow High Threshold Value'
        try {
            outputData.write(flowHighThresholdValue);
        } catch (IOException e) {
        }

        // Process 'Properties4'
        int valProperties4 = 0;
        valProperties4 |= 0;
        valProperties4 |= ((1 << 3) & 0x18);
        valProperties4 |= ((1 << 5) & 0xE0);
        outputData.write(valProperties4);

        // Process 'Flow Low Threshold Value'
        try {
            outputData.write(flowLowThresholdValue);
        } catch (IOException e) {
        }

        // Process 'Sensor Usage'
        int valSensorUsage = 0;
        valSensorUsage |= (sensorUsage.contains("USE_RAIN_SENSOR") ? 0x01 : 0);
        valSensorUsage |= (sensorUsage.contains("USE_MOISTURE_SENSOR") ? 0x02 : 0);
        outputData.write(valSensorUsage);

        return outputData.toByteArray();
    }

    /**
     * Processes a received frame with the IRRIGATION_VALVE_CONFIG_SET command<br>
     *
     * Irrigation Valve Config Set<br>
     *
     *
     * The output data {@link Map} has the following properties<br>
     *
     * <ul>
     * <li>MASTER_VALVE {@link Boolean}
     * <li>VALVE_ID {@link Integer}
     * <li>NOMINAL_CURRENT_HIGH_THRESHOLD {@link Integer}
     * <li>NOMINAL_CURRENT_LOW_THRESHOLD {@link Integer}
     * <li>MAXIMUM_FLOW_VALUE {@link byte[]}
     * <li>FLOW_HIGH_THRESHOLD_VALUE {@link byte[]}
     * <li>FLOW_LOW_THRESHOLD_VALUE {@link byte[]}
     * <li>SENSOR_USAGE {@link List}<{@link String}>
     * </ul>
     *
     * @param payload the {@link byte[]} payload data to process
     * @return a {@link Map} of processed response data
     */
    public static Map<String, Object> handleIrrigationValveConfigSet(byte[] payload) {
        // Create our response map
        Map<String, Object> response = new HashMap<String, Object>();

        // We're using variable length fields, so track the offset
        int msgOffset = 2;

        // Process 'Properties1'
        response.put("MASTER_VALVE", Boolean.valueOf((payload[msgOffset] & 0x01) != 0));
        msgOffset += 1;

        // Process 'Valve ID'
        response.put("VALVE_ID", Integer.valueOf(payload[msgOffset]));
        msgOffset += 1;

        // Process 'Nominal Current High Threshold'
        response.put("NOMINAL_CURRENT_HIGH_THRESHOLD", Integer.valueOf(payload[msgOffset]));
        msgOffset += 1;

        // Process 'Nominal Current Low Threshold'
        response.put("NOMINAL_CURRENT_LOW_THRESHOLD", Integer.valueOf(payload[msgOffset]));
        msgOffset += 1;

        // Process 'Properties2'
        msgOffset += 1;

        // Process 'Maximum Flow Value'
        int valMaximumFlowValue = 0;
        int lenMaximumFlowValue = payload[msgOffset - 1] & 0x07;
        for (int cntMaximumFlowValue = 0; cntMaximumFlowValue < lenMaximumFlowValue; cntMaximumFlowValue++) {
            valMaximumFlowValue = (valMaximumFlowValue << 8) + payload[msgOffset + cntMaximumFlowValue];
        }
        response.put("MAXIMUM_FLOW_VALUE", valMaximumFlowValue);
        msgOffset += lenMaximumFlowValue;

        // Process 'Properties3'
        msgOffset += 1;

        // Process 'Flow High Threshold Value'
        int valFlowHighThresholdValue = 0;
        int lenFlowHighThresholdValue = payload[msgOffset - 1] & 0x07;
        for (int cntFlowHighThresholdValue = 0; cntFlowHighThresholdValue < lenFlowHighThresholdValue; cntFlowHighThresholdValue++) {
            valFlowHighThresholdValue = (valFlowHighThresholdValue << 8) + payload[msgOffset + cntFlowHighThresholdValue];
        }
        response.put("FLOW_HIGH_THRESHOLD_VALUE", valFlowHighThresholdValue);
        msgOffset += lenFlowHighThresholdValue;

        // Process 'Properties4'
        msgOffset += 1;

        // Process 'Flow Low Threshold Value'
        int valFlowLowThresholdValue = 0;
        int lenFlowLowThresholdValue = payload[msgOffset - 1] & 0x07;
        for (int cntFlowLowThresholdValue = 0; cntFlowLowThresholdValue < lenFlowLowThresholdValue; cntFlowLowThresholdValue++) {
            valFlowLowThresholdValue = (valFlowLowThresholdValue << 8) + payload[msgOffset + cntFlowLowThresholdValue];
        }
        response.put("FLOW_LOW_THRESHOLD_VALUE", valFlowLowThresholdValue);
        msgOffset += lenFlowLowThresholdValue;

        // Process 'Sensor Usage'
        List<String> responseSensorUsage = new ArrayList<String>();
        int lenSensorUsage = 1;
        for (int cntSensorUsage = 0; cntSensorUsage < lenSensorUsage; cntSensorUsage++) {
            if ((payload[msgOffset + (cntSensorUsage / 8)] & cntSensorUsage % 8) == 0) {
                continue;
            }
            switch (cntSensorUsage) {
                case 0x00:
                    responseSensorUsage.add("USE_RAIN_SENSOR");
                    break;
                case 0x01:
                    responseSensorUsage.add("USE_MOISTURE_SENSOR");
                    break;
                default:
                    responseSensorUsage.add("BITMASK_" + cntSensorUsage);
                    break;
            }
        }
        response.put("SENSOR_USAGE", responseSensorUsage);
        msgOffset += 1;

        // Return the map of processed response data;
        return response;
    }

    /**
     * Creates a new message with the IRRIGATION_VALVE_CONFIG_GET command.<br>
     *
     * Irrigation Valve Config Get<br>
     *
     *
     * @param masterValve {@link Boolean}
     * @param valveId {@link Integer}
     * @return the {@link byte[]} array with the command to send
     */
    static public byte[] getIrrigationValveConfigGet(Boolean masterValve, Integer valveId) {
        logger.debug("Creating command message IRRIGATION_VALVE_CONFIG_GET version 1");

        ByteArrayOutputStream outputData = new ByteArrayOutputStream();
        outputData.write(COMMAND_CLASS_KEY);
        outputData.write(IRRIGATION_VALVE_CONFIG_GET);

        // Process 'Properties1'
        outputData.write(masterValve ? 0x01 : 0);

        // Process 'Valve ID'
        outputData.write(valveId);

        return outputData.toByteArray();
    }

    /**
     * Processes a received frame with the IRRIGATION_VALVE_CONFIG_GET command<br>
     *
     * Irrigation Valve Config Get<br>
     *
     *
     * The output data {@link Map} has the following properties<br>
     *
     * <ul>
     * <li>MASTER_VALVE {@link Boolean}
     * <li>VALVE_ID {@link Integer}
     * </ul>
     *
     * @param payload the {@link byte[]} payload data to process
     * @return a {@link Map} of processed response data
     */
    public static Map<String, Object> handleIrrigationValveConfigGet(byte[] payload) {
        // Create our response map
        Map<String, Object> response = new HashMap<String, Object>();

        // Process 'Properties1'
        response.put("MASTER_VALVE", Boolean.valueOf((payload[2] & 0x01) != 0));

        // Process 'Valve ID'
        response.put("VALVE_ID", Integer.valueOf(payload[3]));

        // Return the map of processed response data;
        return response;
    }

    /**
     * Creates a new message with the IRRIGATION_VALVE_CONFIG_REPORT command.<br>
     *
     * Irrigation Valve Config Report<br>
     *
     *
     * @param masterValve {@link Boolean}
     * @param valveId {@link Integer}
     * @param nominalCurrentHighThreshold {@link Integer}
     * @param nominalCurrentLowThreshold {@link Integer}
     * @param maximumFlowValue {@link byte[]}
     * @param flowHighThresholdValue {@link byte[]}
     * @param flowLowThresholdValue {@link byte[]}
     * @param sensorUsage {@link List<String>}
     * @return the {@link byte[]} array with the command to send
     */
    static public byte[] getIrrigationValveConfigReport(Boolean masterValve, Integer valveId,
            Integer nominalCurrentHighThreshold, Integer nominalCurrentLowThreshold, byte[] maximumFlowValue,
            byte[] flowHighThresholdValue, byte[] flowLowThresholdValue, List<String> sensorUsage) {
        logger.debug("Creating command message IRRIGATION_VALVE_CONFIG_REPORT version 1");

        ByteArrayOutputStream outputData = new ByteArrayOutputStream();
        outputData.write(COMMAND_CLASS_KEY);
        outputData.write(IRRIGATION_VALVE_CONFIG_REPORT);

        // Process 'Properties1'
        outputData.write(masterValve ? 0x01 : 0);

        // Process 'Valve ID'
        outputData.write(valveId);

        // Process 'Nominal Current High Threshold'
        outputData.write(nominalCurrentHighThreshold);

        // Process 'Nominal Current Low Threshold'
        outputData.write(nominalCurrentLowThreshold);

        // Process 'Properties2'
        int valProperties2 = 0;
        valProperties2 |= 0;
        valProperties2 |= ((1 << 3) & 0x18);
        valProperties2 |= ((1 << 5) & 0xE0);
        outputData.write(valProperties2);

        // Process 'Maximum Flow Value'
        try {
            outputData.write(maximumFlowValue);
        } catch (IOException e) {
        }

        // Process 'Properties3'
        int valProperties3 = 0;
        valProperties3 |= 0;
        valProperties3 |= ((1 << 3) & 0x18);
        valProperties3 |= ((1 << 5) & 0xE0);
        outputData.write(valProperties3);

        // Process 'Flow High Threshold Value'
        try {
            outputData.write(flowHighThresholdValue);
        } catch (IOException e) {
        }

        // Process 'Properties4'
        int valProperties4 = 0;
        valProperties4 |= 0;
        valProperties4 |= ((1 << 3) & 0x18);
        valProperties4 |= ((1 << 5) & 0xE0);
        outputData.write(valProperties4);

        // Process 'Flow Low Threshold Value'
        try {
            outputData.write(flowLowThresholdValue);
        } catch (IOException e) {
        }

        // Process 'Sensor Usage'
        int valSensorUsage = 0;
        valSensorUsage |= (sensorUsage.contains("USE_RAIN_SENSOR") ? 0x01 : 0);
        valSensorUsage |= (sensorUsage.contains("USE_MOISTURE_SENSOR") ? 0x02 : 0);
        outputData.write(valSensorUsage);

        return outputData.toByteArray();
    }

    /**
     * Processes a received frame with the IRRIGATION_VALVE_CONFIG_REPORT command<br>
     *
     * Irrigation Valve Config Report<br>
     *
     *
     * The output data {@link Map} has the following properties<br>
     *
     * <ul>
     * <li>MASTER_VALVE {@link Boolean}
     * <li>VALVE_ID {@link Integer}
     * <li>NOMINAL_CURRENT_HIGH_THRESHOLD {@link Integer}
     * <li>NOMINAL_CURRENT_LOW_THRESHOLD {@link Integer}
     * <li>MAXIMUM_FLOW_VALUE {@link byte[]}
     * <li>FLOW_HIGH_THRESHOLD_VALUE {@link byte[]}
     * <li>FLOW_LOW_THRESHOLD_VALUE {@link byte[]}
     * <li>SENSOR_USAGE {@link List}<{@link String}>
     * </ul>
     *
     * @param payload the {@link byte[]} payload data to process
     * @return a {@link Map} of processed response data
     */
    public static Map<String, Object> handleIrrigationValveConfigReport(byte[] payload) {
        // Create our response map
        Map<String, Object> response = new HashMap<String, Object>();

        // We're using variable length fields, so track the offset
        int msgOffset = 2;

        // Process 'Properties1'
        response.put("MASTER_VALVE", Boolean.valueOf((payload[msgOffset] & 0x01) != 0));
        msgOffset += 1;

        // Process 'Valve ID'
        response.put("VALVE_ID", Integer.valueOf(payload[msgOffset]));
        msgOffset += 1;

        // Process 'Nominal Current High Threshold'
        response.put("NOMINAL_CURRENT_HIGH_THRESHOLD", Integer.valueOf(payload[msgOffset]));
        msgOffset += 1;

        // Process 'Nominal Current Low Threshold'
        response.put("NOMINAL_CURRENT_LOW_THRESHOLD", Integer.valueOf(payload[msgOffset]));
        msgOffset += 1;

        // Process 'Properties2'
        msgOffset += 1;

        // Process 'Maximum Flow Value'
        int valMaximumFlowValue = 0;
        int lenMaximumFlowValue = payload[msgOffset - 1] & 0x07;
        for (int cntMaximumFlowValue = 0; cntMaximumFlowValue < lenMaximumFlowValue; cntMaximumFlowValue++) {
            valMaximumFlowValue = (valMaximumFlowValue << 8) + payload[msgOffset + cntMaximumFlowValue];
        }
        response.put("MAXIMUM_FLOW_VALUE", valMaximumFlowValue);
        msgOffset += lenMaximumFlowValue;

        // Process 'Properties3'
        msgOffset += 1;

        // Process 'Flow High Threshold Value'
        int valFlowHighThresholdValue = 0;
        int lenFlowHighThresholdValue = payload[msgOffset - 1] & 0x07;
        for (int cntFlowHighThresholdValue = 0; cntFlowHighThresholdValue < lenFlowHighThresholdValue; cntFlowHighThresholdValue++) {
            valFlowHighThresholdValue = (valFlowHighThresholdValue << 8) + payload[msgOffset + cntFlowHighThresholdValue];
        }
        response.put("FLOW_HIGH_THRESHOLD_VALUE", valFlowHighThresholdValue);
        msgOffset += lenFlowHighThresholdValue;

        // Process 'Properties4'
        msgOffset += 1;

        // Process 'Flow Low Threshold Value'
        int valFlowLowThresholdValue = 0;
        int lenFlowLowThresholdValue = payload[msgOffset - 1] & 0x07;
        for (int cntFlowLowThresholdValue = 0; cntFlowLowThresholdValue < lenFlowLowThresholdValue; cntFlowLowThresholdValue++) {
            valFlowLowThresholdValue = (valFlowLowThresholdValue << 8) + payload[msgOffset + cntFlowLowThresholdValue];
        }
        response.put("FLOW_LOW_THRESHOLD_VALUE", valFlowLowThresholdValue);
        msgOffset += lenFlowLowThresholdValue;

        // Process 'Sensor Usage'
        List<String> responseSensorUsage = new ArrayList<String>();
        int lenSensorUsage = 1;
        for (int cntSensorUsage = 0; cntSensorUsage < lenSensorUsage; cntSensorUsage++) {
            if ((payload[msgOffset + (cntSensorUsage / 8)] & cntSensorUsage % 8) == 0) {
                continue;
            }
            switch (cntSensorUsage) {
                case 0x00:
                    responseSensorUsage.add("USE_RAIN_SENSOR");
                    break;
                case 0x01:
                    responseSensorUsage.add("USE_MOISTURE_SENSOR");
                    break;
                default:
                    responseSensorUsage.add("BITMASK_" + cntSensorUsage);
                    break;
            }
        }
        response.put("SENSOR_USAGE", responseSensorUsage);
        msgOffset += 1;

        // Return the map of processed response data;
        return response;
    }

    /**
     * Creates a new message with the IRRIGATION_VALVE_RUN command.<br>
     *
     * Irrigation Valve Run<br>
     *
     *
     * @param masterValve {@link Boolean}
     * @param valveId {@link Integer}
     * @param duration {@link Integer}
     * @return the {@link byte[]} array with the command to send
     */
    static public byte[] getIrrigationValveRun(Boolean masterValve, Integer valveId, Integer duration) {
        logger.debug("Creating command message IRRIGATION_VALVE_RUN version 1");

        ByteArrayOutputStream outputData = new ByteArrayOutputStream();
        outputData.write(COMMAND_CLASS_KEY);
        outputData.write(IRRIGATION_VALVE_RUN);

        // Process 'Properties1'
        outputData.write(masterValve ? 0x01 : 0);

        // Process 'Valve ID'
        outputData.write(valveId);

        // Process 'Duration'
        outputData.write((duration >> 8) & 0xff);
        outputData.write(duration & 0xff);

        return outputData.toByteArray();
    }

    /**
     * Processes a received frame with the IRRIGATION_VALVE_RUN command<br>
     *
     * Irrigation Valve Run<br>
     *
     *
     * The output data {@link Map} has the following properties<br>
     *
     * <ul>
     * <li>MASTER_VALVE {@link Boolean}
     * <li>VALVE_ID {@link Integer}
     * <li>DURATION {@link Integer}
     * </ul>
     *
     * @param payload the {@link byte[]} payload data to process
     * @return a {@link Map} of processed response data
     */
    public static Map<String, Object> handleIrrigationValveRun(byte[] payload) {
        // Create our response map
        Map<String, Object> response = new HashMap<String, Object>();

        // Process 'Properties1'
        response.put("MASTER_VALVE", Boolean.valueOf((payload[2] & 0x01) != 0));

        // Process 'Valve ID'
        response.put("VALVE_ID", Integer.valueOf(payload[3]));

        // Process 'Duration'
        response.put("DURATION", Integer.valueOf(payload[4] << 8 + payload[5]));

        // Return the map of processed response data;
        return response;
    }

    /**
     * Creates a new message with the IRRIGATION_VALVE_TABLE_SET command.<br>
     *
     * Irrigation Valve Table Set<br>
     *
     *
     * @param valveTableId {@link Integer}
     * @return the {@link byte[]} array with the command to send
     */
    static public byte[] getIrrigationValveTableSet(Integer valveTableId) {
        logger.debug("Creating command message IRRIGATION_VALVE_TABLE_SET version 1");

        ByteArrayOutputStream outputData = new ByteArrayOutputStream();
        outputData.write(COMMAND_CLASS_KEY);
        outputData.write(IRRIGATION_VALVE_TABLE_SET);

        // Process 'Valve Table ID'
        outputData.write(valveTableId);

        // Process 'vg1'

        return outputData.toByteArray();
    }

    /**
     * Processes a received frame with the IRRIGATION_VALVE_TABLE_SET command<br>
     *
     * Irrigation Valve Table Set<br>
     *
     *
     * The output data {@link Map} has the following properties<br>
     *
     * <ul>
     * <li>VALVE_TABLE_ID {@link Integer}
     * </ul>
     *
     * @param payload the {@link byte[]} payload data to process
     * @return a {@link Map} of processed response data
     */
    public static Map<String, Object> handleIrrigationValveTableSet(byte[] payload) {
        // Create our response map
        Map<String, Object> response = new HashMap<String, Object>();

        // Process 'Valve Table ID'
        response.put("VALVE_TABLE_ID", Integer.valueOf(payload[2]));

        // Process 'vg1'

        // Create a list to hold the group vg1
        List<Map<String, Object>> variantList = new ArrayList<Map<String, Object>>();

        int offset = 3;
        while (offset < payload.length) {
            // Create a map to hold the members of this variant
            Map<String, Object> variant = new HashMap<String, Object>();

            // Process 'Valve ID'
            variant.put("VALVE_ID", Integer.valueOf(payload[3]));

            // Process 'Duration'
            variant.put("DURATION", Integer.valueOf(payload[4] << 8 + payload[5]));

        }

        // Add the variant list to the response
        response.put("VG1", variantList);

        // Return the map of processed response data;
        return response;
    }

    /**
     * Creates a new message with the IRRIGATION_VALVE_TABLE_GET command.<br>
     *
     * Irrigation Valve Table Get<br>
     *
     *
     * @param valveTableId {@link Integer}
     * @return the {@link byte[]} array with the command to send
     */
    static public byte[] getIrrigationValveTableGet(Integer valveTableId) {
        logger.debug("Creating command message IRRIGATION_VALVE_TABLE_GET version 1");

        ByteArrayOutputStream outputData = new ByteArrayOutputStream();
        outputData.write(COMMAND_CLASS_KEY);
        outputData.write(IRRIGATION_VALVE_TABLE_GET);

        // Process 'Valve Table ID'
        outputData.write(valveTableId);

        return outputData.toByteArray();
    }

    /**
     * Processes a received frame with the IRRIGATION_VALVE_TABLE_GET command<br>
     *
     * Irrigation Valve Table Get<br>
     *
     *
     * The output data {@link Map} has the following properties<br>
     *
     * <ul>
     * <li>VALVE_TABLE_ID {@link Integer}
     * </ul>
     *
     * @param payload the {@link byte[]} payload data to process
     * @return a {@link Map} of processed response data
     */
    public static Map<String, Object> handleIrrigationValveTableGet(byte[] payload) {
        // Create our response map
        Map<String, Object> response = new HashMap<String, Object>();

        // Process 'Valve Table ID'
        response.put("VALVE_TABLE_ID", Integer.valueOf(payload[2]));

        // Return the map of processed response data;
        return response;
    }

    /**
     * Creates a new message with the IRRIGATION_VALVE_TABLE_REPORT command.<br>
     *
     * Irrigation Valve Table Report<br>
     *
     *
     * @param valveTableId {@link Integer}
     * @return the {@link byte[]} array with the command to send
     */
    static public byte[] getIrrigationValveTableReport(Integer valveTableId) {
        logger.debug("Creating command message IRRIGATION_VALVE_TABLE_REPORT version 1");

        ByteArrayOutputStream outputData = new ByteArrayOutputStream();
        outputData.write(COMMAND_CLASS_KEY);
        outputData.write(IRRIGATION_VALVE_TABLE_REPORT);

        // Process 'Valve Table ID'
        outputData.write(valveTableId);

        // Process 'vg1'

        return outputData.toByteArray();
    }

    /**
     * Processes a received frame with the IRRIGATION_VALVE_TABLE_REPORT command<br>
     *
     * Irrigation Valve Table Report<br>
     *
     *
     * The output data {@link Map} has the following properties<br>
     *
     * <ul>
     * <li>VALVE_TABLE_ID {@link Integer}
     * </ul>
     *
     * @param payload the {@link byte[]} payload data to process
     * @return a {@link Map} of processed response data
     */
    public static Map<String, Object> handleIrrigationValveTableReport(byte[] payload) {
        // Create our response map
        Map<String, Object> response = new HashMap<String, Object>();

        // Process 'Valve Table ID'
        response.put("VALVE_TABLE_ID", Integer.valueOf(payload[2]));

        // Process 'vg1'

        // Create a list to hold the group vg1
        List<Map<String, Object>> variantList = new ArrayList<Map<String, Object>>();

        int offset = 3;
        while (offset < payload.length) {
            // Create a map to hold the members of this variant
            Map<String, Object> variant = new HashMap<String, Object>();

            // Process 'Valve ID'
            variant.put("VALVE_ID", Integer.valueOf(payload[3]));

            // Process 'Duration'
            variant.put("DURATION", Integer.valueOf(payload[4] << 8 + payload[5]));

        }

        // Add the variant list to the response
        response.put("VG1", variantList);

        // Return the map of processed response data;
        return response;
    }

    /**
     * Creates a new message with the IRRIGATION_VALVE_TABLE_RUN command.<br>
     *
     * Irrigation Valve Table Run<br>
     *
     *
     * @param valveTableId {@link byte[]}
     * @return the {@link byte[]} array with the command to send
     */
    static public byte[] getIrrigationValveTableRun(byte[] valveTableId) {
        logger.debug("Creating command message IRRIGATION_VALVE_TABLE_RUN version 1");

        ByteArrayOutputStream outputData = new ByteArrayOutputStream();
        outputData.write(COMMAND_CLASS_KEY);
        outputData.write(IRRIGATION_VALVE_TABLE_RUN);

        // Process 'Valve Table ID'
        try {
            outputData.write(valveTableId);
        } catch (IOException e) {
        }

        return outputData.toByteArray();
    }

    /**
     * Processes a received frame with the IRRIGATION_VALVE_TABLE_RUN command<br>
     *
     * Irrigation Valve Table Run<br>
     *
     *
     * The output data {@link Map} has the following properties<br>
     *
     * <ul>
     * <li>VALVE_TABLE_ID {@link byte[]}
     * </ul>
     *
     * @param payload the {@link byte[]} payload data to process
     * @return a {@link Map} of processed response data
     */
    public static Map<String, Object> handleIrrigationValveTableRun(byte[] payload) {
        // Create our response map
        Map<String, Object> response = new HashMap<String, Object>();

        // We're using variable length fields, so track the offset
        int msgOffset = 2;

        // Process 'Valve Table ID'
        ByteArrayOutputStream valValveTableId = new ByteArrayOutputStream();
        while (msgOffset < payload.length) {
            valValveTableId.write(payload[msgOffset]);
            msgOffset++;
        }
        response.put("VALVE_TABLE_ID", valValveTableId);

        // Return the map of processed response data;
        return response;
    }

    /**
     * Creates a new message with the IRRIGATION_SYSTEM_SHUTOFF command.<br>
     *
     * Irrigation System Shutoff<br>
     *
     *
     * @param duration {@link Integer}
     * @return the {@link byte[]} array with the command to send
     */
    static public byte[] getIrrigationSystemShutoff(Integer duration) {
        logger.debug("Creating command message IRRIGATION_SYSTEM_SHUTOFF version 1");

        ByteArrayOutputStream outputData = new ByteArrayOutputStream();
        outputData.write(COMMAND_CLASS_KEY);
        outputData.write(IRRIGATION_SYSTEM_SHUTOFF);

        // Process 'Duration'
        outputData.write(duration);

        return outputData.toByteArray();
    }

    /**
     * Processes a received frame with the IRRIGATION_SYSTEM_SHUTOFF command<br>
     *
     * Irrigation System Shutoff<br>
     *
     *
     * The output data {@link Map} has the following properties<br>
     *
     * <ul>
     * <li>DURATION {@link Integer}
     * </ul>
     *
     * @param payload the {@link byte[]} payload data to process
     * @return a {@link Map} of processed response data
     */
    public static Map<String, Object> handleIrrigationSystemShutoff(byte[] payload) {
        // Create our response map
        Map<String, Object> response = new HashMap<String, Object>();

        // Process 'Duration'
        response.put("DURATION", Integer.valueOf(payload[2]));

        // Return the map of processed response data;
        return response;
    }

}
