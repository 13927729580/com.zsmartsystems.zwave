/**
 * Copyright (c) 2014-2016 by the respective copyright holders.
 *
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Eclipse Public License v1.0
 * which accompanies this distribution, and is available at
 * http://www.eclipse.org/legal/epl-v10.html
 */
package com.zsmartsystems.zwave.commandclass.impl;

import java.io.ByteArrayOutputStream;
import java.io.IOException;
import java.lang.IllegalArgumentException;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

/**
 * Class to implement the Z-Wave command class <b>COMMAND_CLASS_SECURITY_2</b> version <b>1</b>.<br>
 *
 * Command Class Security 2<br>
 *
 * This class provides static methods for processing received messages (message handler) and
 * methods to get a message to send on the Z-Wave network.<br>
 *
 * Note that this code is autogenerated. Manual changes may be overwritten.
 *
 * @author Chris Jackson - Initial contribution of Java code generator
 */
public class CommandClassSecurity2V1 {
    private static final Logger logger = LoggerFactory.getLogger(CommandClassSecurity2V1.class);

    /**
     * Integer command class key for COMMAND_CLASS_SECURITY_2
     */
    public final static int COMMAND_CLASS_KEY = 0x9F;

    /**
     * S2 Nonce Get Command Constant
     */
    public final static int SECURITY_2_NONCE_GET = 0x01;
    /**
     * S2 Nonce Report Command Constant
     */
    public final static int SECURITY_2_NONCE_REPORT = 0x02;
    /**
     * S2 Message Encapsulation Command Constant
     */
    public final static int SECURITY_2_MESSAGE_ENCAPSULATION = 0x03;
    /**
     * KEX Get Command Constant
     */
    public final static int KEX_GET = 0x04;
    /**
     * KEX Report Command Constant
     */
    public final static int KEX_REPORT = 0x05;
    /**
     * KEX Set Command Constant
     */
    public final static int KEX_SET = 0x06;
    /**
     * KEX Fail Command Constant
     */
    public final static int KEX_FAIL = 0x07;
    /**
     * Public Key Report Command Constant
     */
    public final static int PUBLIC_KEY_REPORT = 0x08;
    /**
     * S2 Network Key Get Command Constant
     */
    public final static int SECURITY_2_NETWORK_KEY_GET = 0x09;
    /**
     * S2 Network Key Report Command Constant
     */
    public final static int SECURITY_2_NETWORK_KEY_REPORT = 0x0A;
    /**
     * S2 Network Key Verify Command Constant
     */
    public final static int SECURITY_2_NETWORK_KEY_VERIFY = 0x0B;
    /**
     * S2 Transfer End Command Constant
     */
    public final static int SECURITY_2_TRANSFER_END = 0x0C;
    /**
     * S2 Commands Supported Get Command Constant
     */
    public final static int SECURITY_2_COMMANDS_SUPPORTED_GET = 0x0D;
    /**
     * S2 Commands Supported Report Command Constant
     */
    public final static int SECURITY_2_COMMANDS_SUPPORTED_REPORT = 0x0E;
    /**
     * S2 Capabilities Get Command Constant
     */
    public final static int SECURITY_2_CAPABILITIES_GET = 0x0F;
    /**
     * S2 Capabilities Report Command Constant
     */
    public final static int SECURITY_2_CAPABILITIES_REPORT = 0x10;

    /**
     * Creates a new message with the SECURITY_2_NONCE_GET command.<br>
     *
     * S2 Nonce Get<br>
     *
     *
     * @param sequenceNumber {@link Integer}
     * @return the {@link byte[]} array with the command to send
     */
    static public byte[] getSecurity2NonceGet(Integer sequenceNumber) {
        logger.debug("Creating command message SECURITY_2_NONCE_GET version 1");

        ByteArrayOutputStream outputData = new ByteArrayOutputStream();
        outputData.write(COMMAND_CLASS_KEY);
        outputData.write(SECURITY_2_NONCE_GET);

        // Process 'Sequence Number'
        outputData.write(sequenceNumber);

        return outputData.toByteArray();
    }

    /**
     * Processes a received frame with the SECURITY_2_NONCE_GET command<br>
     *
     * S2 Nonce Get<br>
     *
     *
     * The output data {@link Map} has the following properties<br>
     *
     * <ul>
     * <li>SEQUENCE_NUMBER {@link Integer}
     * </ul>
     *
     * @param payload the {@link byte[]} payload data to process
     * @return a {@link Map} of processed response data
     */
    public static Map<String, Object> handleSecurity2NonceGet(byte[] payload) {
        // Create our response map
        Map<String, Object> response = new HashMap<String, Object>();

        // Process 'Sequence Number'
        response.put("SEQUENCE_NUMBER", Integer.valueOf(payload[2]));

        // Return the map of processed response data;
        return response;
    }

    /**
     * Creates a new message with the SECURITY_2_NONCE_REPORT command.<br>
     *
     * S2 Nonce Report<br>
     *
     *
     * @param sequenceNumber {@link Integer}
     * @param sos {@link Boolean}
     * @param mos {@link Boolean}
     * @param receiversEntropyInput {@link byte[]}
     * @return the {@link byte[]} array with the command to send
     */
    static public byte[] getSecurity2NonceReport(Integer sequenceNumber, Boolean sos, Boolean mos,
            byte[] receiversEntropyInput) {
        logger.debug("Creating command message SECURITY_2_NONCE_REPORT version 1");

        ByteArrayOutputStream outputData = new ByteArrayOutputStream();
        outputData.write(COMMAND_CLASS_KEY);
        outputData.write(SECURITY_2_NONCE_REPORT);

        // Process 'Sequence Number'
        outputData.write(sequenceNumber);

        // Process 'Properties1'
        int valProperties1 = 0;
        valProperties1 |= sos ? 0x01 : 0;
        valProperties1 |= mos ? 0x02 : 0;
        outputData.write(valProperties1);

        // Process 'Receivers Entropy Input'
        try {
            outputData.write(receiversEntropyInput);
        } catch (IOException e) {
        }

        return outputData.toByteArray();
    }

    /**
     * Processes a received frame with the SECURITY_2_NONCE_REPORT command<br>
     *
     * S2 Nonce Report<br>
     *
     *
     * The output data {@link Map} has the following properties<br>
     *
     * <ul>
     * <li>SEQUENCE_NUMBER {@link Integer}
     * <li>SOS {@link Boolean}
     * <li>MOS {@link Boolean}
     * <li>RECEIVERS_ENTROPY_INPUT {@link byte[]}
     * </ul>
     *
     * @param payload the {@link byte[]} payload data to process
     * @return a {@link Map} of processed response data
     */
    public static Map<String, Object> handleSecurity2NonceReport(byte[] payload) {
        // Create our response map
        Map<String, Object> response = new HashMap<String, Object>();

        // Process 'Sequence Number'
        response.put("SEQUENCE_NUMBER", Integer.valueOf(payload[2]));

        // Process 'Properties1'
        response.put("SOS", Boolean.valueOf((payload[3] & 0x01) != 0));
        response.put("MOS", Boolean.valueOf((payload[3] & 0x02) != 0));

        // Process 'Receivers Entropy Input'
        byte[] valReceiversEntropyInput = new byte[16];
        for (int cntReceiversEntropyInput = 0; cntReceiversEntropyInput < 16; cntReceiversEntropyInput++) {
            valReceiversEntropyInput[cntReceiversEntropyInput] = payload[4 + cntReceiversEntropyInput];
        }
        response.put("RECEIVERS_ENTROPY_INPUT", valReceiversEntropyInput);

        // Return the map of processed response data;
        return response;
    }

    /**
     * Creates a new message with the SECURITY_2_MESSAGE_ENCAPSULATION command.<br>
     *
     * S2 Message Encapsulation<br>
     *
     *
     * @param sequenceNumber {@link Integer}
     * @param extension {@link Boolean}
     * @param encryptedExtension {@link Boolean}
     * @param ccmCiphertextObject {@link byte[]}
     * @return the {@link byte[]} array with the command to send
     */
    static public byte[] getSecurity2MessageEncapsulation(Integer sequenceNumber, Boolean extension,
            Boolean encryptedExtension, byte[] ccmCiphertextObject) {
        logger.debug("Creating command message SECURITY_2_MESSAGE_ENCAPSULATION version 1");

        ByteArrayOutputStream outputData = new ByteArrayOutputStream();
        outputData.write(COMMAND_CLASS_KEY);
        outputData.write(SECURITY_2_MESSAGE_ENCAPSULATION);

        // Process 'Sequence Number'
        outputData.write(sequenceNumber);

        // Process 'Properties1'
        int valProperties1 = 0;
        valProperties1 |= extension ? 0x01 : 0;
        valProperties1 |= encryptedExtension ? 0x02 : 0;
        outputData.write(valProperties1);

        // Process 'vg1'

        // Process 'CCM Ciphertext Object'
        try {
            outputData.write(ccmCiphertextObject);
        } catch (IOException e) {
        }

        return outputData.toByteArray();
    }

    /**
     * Processes a received frame with the SECURITY_2_MESSAGE_ENCAPSULATION command<br>
     *
     * S2 Message Encapsulation<br>
     *
     *
     * The output data {@link Map} has the following properties<br>
     *
     * <ul>
     * <li>SEQUENCE_NUMBER {@link Integer}
     * <li>EXTENSION {@link Boolean}
     * <li>ENCRYPTED_EXTENSION {@link Boolean}
     * <li>CCM_CIPHERTEXT_OBJECT {@link byte[]}
     * </ul>
     *
     * @param payload the {@link byte[]} payload data to process
     * @return a {@link Map} of processed response data
     */
    public static Map<String, Object> handleSecurity2MessageEncapsulation(byte[] payload) {
        // Create our response map
        Map<String, Object> response = new HashMap<String, Object>();

        // We're using variable length fields, so track the offset
        int msgOffset = 2;

        // Process 'Sequence Number'
        response.put("SEQUENCE_NUMBER", Integer.valueOf(payload[msgOffset]));
        msgOffset += 1;

        // Process 'Properties1'
        response.put("EXTENSION", Boolean.valueOf((payload[msgOffset] & 0x01) != 0));
        response.put("ENCRYPTED_EXTENSION", Boolean.valueOf((payload[msgOffset] & 0x02) != 0));
        msgOffset += 1;

        // Process 'vg1'

        // Create a list to hold the group vg1
        List<Map<String, Object>> variantList = new ArrayList<Map<String, Object>>();

        int offset = msgOffset;
        while (offset < payload.length) {
            // Create a map to hold the members of this variant
            Map<String, Object> variant = new HashMap<String, Object>();

            // Process 'Extension Length'
            variant.put("EXTENSION_LENGTH", Integer.valueOf(payload[msgOffset]));
            msgOffset += 1;

            // Process 'Properties1'
            variant.put("TYPE", Integer.valueOf(payload[msgOffset] & 0x3F));
            variant.put("CRITICAL", Boolean.valueOf((payload[msgOffset] & 0x40) != 0));
            variant.put("MORE_TO_FOLLOW", Boolean.valueOf((payload[msgOffset] & 0x80) != 0));
            msgOffset += 1;

            // Process 'Extension'
            int valExtension = 0;
            int lenExtension = payload[msgOffset - 2];
            for (int cntExtension = 0; cntExtension < lenExtension; cntExtension++) {
                valExtension = (valExtension << 8) + payload[msgOffset + cntExtension];
            }
            variant.put("EXTENSION", valExtension);
            msgOffset += lenExtension;

        }

        // Add the variant list to the response
        response.put("VG1", variantList);

        // Process 'CCM Ciphertext Object'
        ByteArrayOutputStream valCcmCiphertextObject = new ByteArrayOutputStream();
        while (msgOffset < payload.length) {
            valCcmCiphertextObject.write(payload[msgOffset]);
            msgOffset++;
        }
        response.put("CCM_CIPHERTEXT_OBJECT", valCcmCiphertextObject);

        // Return the map of processed response data;
        return response;
    }

    /**
     * Creates a new message with the KEX_GET command.<br>
     *
     * KEX Get<br>
     *
     *
     * @return the {@link byte[]} array with the command to send
     */
    static public byte[] getKexGet() {
        logger.debug("Creating command message KEX_GET version 1");

        ByteArrayOutputStream outputData = new ByteArrayOutputStream();
        outputData.write(COMMAND_CLASS_KEY);
        outputData.write(KEX_GET);

        return outputData.toByteArray();
    }

    /**
     * Processes a received frame with the KEX_GET command<br>
     *
     * KEX Get<br>
     *
     *
     * @param payload the {@link byte[]} payload data to process
     * @return a {@link Map} of processed response data
     */
    public static Map<String, Object> handleKexGet(byte[] payload) {
        // Create our response map
        Map<String, Object> response = new HashMap<String, Object>();

        // Return the map of processed response data;
        return response;
    }

    /**
     * Creates a new message with the KEX_REPORT command.<br>
     *
     * KEX Report<br>
     *
     *
     * @param echo {@link Boolean}
     * @param requestCsa {@link Boolean}
     * @param supportedKexSchemes {@link Integer}
     * @param supportedEcdhProfiles {@link Integer}
     * @param requestedKeys {@link List<String>}
     * @return the {@link byte[]} array with the command to send
     */
    static public byte[] getKexReport(Boolean echo, Boolean requestCsa, Integer supportedKexSchemes,
            Integer supportedEcdhProfiles, List<String> requestedKeys) {
        logger.debug("Creating command message KEX_REPORT version 1");

        ByteArrayOutputStream outputData = new ByteArrayOutputStream();
        outputData.write(COMMAND_CLASS_KEY);
        outputData.write(KEX_REPORT);

        // Process 'Properties1'
        int valProperties1 = 0;
        valProperties1 |= echo ? 0x01 : 0;
        valProperties1 |= requestCsa ? 0x02 : 0;
        outputData.write(valProperties1);

        // Process 'Supported KEX Schemes'
        outputData.write(supportedKexSchemes);

        // Process 'Supported ECDH Profiles'
        outputData.write(supportedEcdhProfiles);

        // Process 'Requested Keys'
        int valRequestedKeys = 0;
        valRequestedKeys |= (requestedKeys.contains("UNAUTHENTICATED") ? 0x01 : 0);
        valRequestedKeys |= (requestedKeys.contains("AUTHENTICATED") ? 0x02 : 0);
        valRequestedKeys |= (requestedKeys.contains("ACCESS") ? 0x04 : 0);
        valRequestedKeys |= (requestedKeys.contains("S0") ? 0x80 : 0);
        outputData.write(valRequestedKeys);

        return outputData.toByteArray();
    }

    /**
     * Processes a received frame with the KEX_REPORT command<br>
     *
     * KEX Report<br>
     *
     *
     * The output data {@link Map} has the following properties<br>
     *
     * <ul>
     * <li>ECHO {@link Boolean}
     * <li>REQUEST_CSA {@link Boolean}
     * <li>SUPPORTED_KEX_SCHEMES {@link Integer}
     * <li>SUPPORTED_ECDH_PROFILES {@link Integer}
     * <li>REQUESTED_KEYS {@link List}<{@link String}>
     * </ul>
     *
     * @param payload the {@link byte[]} payload data to process
     * @return a {@link Map} of processed response data
     */
    public static Map<String, Object> handleKexReport(byte[] payload) {
        // Create our response map
        Map<String, Object> response = new HashMap<String, Object>();

        // Process 'Properties1'
        response.put("ECHO", Boolean.valueOf((payload[2] & 0x01) != 0));
        response.put("REQUEST_CSA", Boolean.valueOf((payload[2] & 0x02) != 0));

        // Process 'Supported KEX Schemes'
        response.put("SUPPORTED_KEX_SCHEMES", Integer.valueOf(payload[3]));

        // Process 'Supported ECDH Profiles'
        response.put("SUPPORTED_ECDH_PROFILES", Integer.valueOf(payload[4]));

        // Process 'Requested Keys'
        List<String> responseRequestedKeys = new ArrayList<String>();
        int lenRequestedKeys = 1;
        for (int cntRequestedKeys = 0; cntRequestedKeys < lenRequestedKeys; cntRequestedKeys++) {
            if ((payload[5 + (cntRequestedKeys / 8)] & cntRequestedKeys % 8) == 0) {
                continue;
            }
            switch (cntRequestedKeys) {
                case 0x00:
                    responseRequestedKeys.add("UNAUTHENTICATED");
                    break;
                case 0x01:
                    responseRequestedKeys.add("AUTHENTICATED");
                    break;
                case 0x02:
                    responseRequestedKeys.add("ACCESS");
                    break;
                case 0x07:
                    responseRequestedKeys.add("S0");
                    break;
                default:
                    responseRequestedKeys.add("BITMASK_" + cntRequestedKeys);
                    break;
            }
        }
        response.put("REQUESTED_KEYS", responseRequestedKeys);

        // Return the map of processed response data;
        return response;
    }

    /**
     * Creates a new message with the KEX_SET command.<br>
     *
     * KEX Set<br>
     *
     *
     * @param echo {@link Boolean}
     * @param requestCsa {@link Boolean}
     * @param selectedKexScheme {@link Integer}
     * @param selectedEcdhProfile {@link Integer}
     * @param grantedKeys {@link List<String>}
     * @return the {@link byte[]} array with the command to send
     */
    static public byte[] getKexSet(Boolean echo, Boolean requestCsa, Integer selectedKexScheme,
            Integer selectedEcdhProfile, List<String> grantedKeys) {
        logger.debug("Creating command message KEX_SET version 1");

        ByteArrayOutputStream outputData = new ByteArrayOutputStream();
        outputData.write(COMMAND_CLASS_KEY);
        outputData.write(KEX_SET);

        // Process 'Properties1'
        int valProperties1 = 0;
        valProperties1 |= echo ? 0x01 : 0;
        valProperties1 |= requestCsa ? 0x02 : 0;
        outputData.write(valProperties1);

        // Process 'Selected KEX Scheme'
        outputData.write(selectedKexScheme);

        // Process 'Selected ECDH Profile'
        outputData.write(selectedEcdhProfile);

        // Process 'Granted Keys'
        int valGrantedKeys = 0;
        valGrantedKeys |= (grantedKeys.contains("UNAUTHENTICATED") ? 0x01 : 0);
        valGrantedKeys |= (grantedKeys.contains("AUTHENTICATED") ? 0x02 : 0);
        valGrantedKeys |= (grantedKeys.contains("ACCESS") ? 0x04 : 0);
        valGrantedKeys |= (grantedKeys.contains("S0") ? 0x80 : 0);
        outputData.write(valGrantedKeys);

        return outputData.toByteArray();
    }

    /**
     * Processes a received frame with the KEX_SET command<br>
     *
     * KEX Set<br>
     *
     *
     * The output data {@link Map} has the following properties<br>
     *
     * <ul>
     * <li>ECHO {@link Boolean}
     * <li>REQUEST_CSA {@link Boolean}
     * <li>SELECTED_KEX_SCHEME {@link Integer}
     * <li>SELECTED_ECDH_PROFILE {@link Integer}
     * <li>GRANTED_KEYS {@link List}<{@link String}>
     * </ul>
     *
     * @param payload the {@link byte[]} payload data to process
     * @return a {@link Map} of processed response data
     */
    public static Map<String, Object> handleKexSet(byte[] payload) {
        // Create our response map
        Map<String, Object> response = new HashMap<String, Object>();

        // Process 'Properties1'
        response.put("ECHO", Boolean.valueOf((payload[2] & 0x01) != 0));
        response.put("REQUEST_CSA", Boolean.valueOf((payload[2] & 0x02) != 0));

        // Process 'Selected KEX Scheme'
        response.put("SELECTED_KEX_SCHEME", Integer.valueOf(payload[3]));

        // Process 'Selected ECDH Profile'
        response.put("SELECTED_ECDH_PROFILE", Integer.valueOf(payload[4]));

        // Process 'Granted Keys'
        List<String> responseGrantedKeys = new ArrayList<String>();
        int lenGrantedKeys = 1;
        for (int cntGrantedKeys = 0; cntGrantedKeys < lenGrantedKeys; cntGrantedKeys++) {
            if ((payload[5 + (cntGrantedKeys / 8)] & cntGrantedKeys % 8) == 0) {
                continue;
            }
            switch (cntGrantedKeys) {
                case 0x00:
                    responseGrantedKeys.add("UNAUTHENTICATED");
                    break;
                case 0x01:
                    responseGrantedKeys.add("AUTHENTICATED");
                    break;
                case 0x02:
                    responseGrantedKeys.add("ACCESS");
                    break;
                case 0x07:
                    responseGrantedKeys.add("S0");
                    break;
                default:
                    responseGrantedKeys.add("BITMASK_" + cntGrantedKeys);
                    break;
            }
        }
        response.put("GRANTED_KEYS", responseGrantedKeys);

        // Return the map of processed response data;
        return response;
    }

    /**
     * Creates a new message with the KEX_FAIL command.<br>
     *
     * KEX Fail<br>
     *
     *
     * @param kexFailType {@link String}
     * @return the {@link byte[]} array with the command to send
     */
    static public byte[] getKexFail(String kexFailType) {
        logger.debug("Creating command message KEX_FAIL version 1");

        ByteArrayOutputStream outputData = new ByteArrayOutputStream();
        outputData.write(COMMAND_CLASS_KEY);
        outputData.write(KEX_FAIL);

        // Process 'KEX Fail Type'
        switch (kexFailType) {
            case "KEX_KEY":
                outputData.write(0x01);
                break;
            case "KEX_SCHEME":
                outputData.write(0x02);
                break;
            case "KEX_CURVES":
                outputData.write(0x03);
                break;
            case "DECRYPT":
                outputData.write(0x05);
                break;
            case "CANCEL":
                outputData.write(0x06);
                break;
            case "AUTH":
                outputData.write(0x07);
                break;
            case "KEY_GET":
                outputData.write(0x08);
                break;
            case "KEY_VERIFY":
                outputData.write(0x09);
                break;
            case "KEY_REPORT":
                outputData.write(0x0A);
                break;
            default:
                throw new IllegalArgumentException("Unknown constant value for kexFailType: " + kexFailType);
        }

        return outputData.toByteArray();
    }

    /**
     * Processes a received frame with the KEX_FAIL command<br>
     *
     * KEX Fail<br>
     *
     *
     * The output data {@link Map} has the following properties<br>
     *
     * <ul>
     * <li>KEX_FAIL_TYPE {@link String}
     * </ul>
     *
     * @param payload the {@link byte[]} payload data to process
     * @return a {@link Map} of processed response data
     */
    public static Map<String, Object> handleKexFail(byte[] payload) {
        // Create our response map
        Map<String, Object> response = new HashMap<String, Object>();

        // Process 'KEX Fail Type'
        switch ((int) payload[2]) {
            case (byte) 0x01:
                response.put("KEX_FAIL_TYPE", "KEX_KEY");
                break;
            case (byte) 0x02:
                response.put("KEX_FAIL_TYPE", "KEX_SCHEME");
                break;
            case (byte) 0x03:
                response.put("KEX_FAIL_TYPE", "KEX_CURVES");
                break;
            case (byte) 0x05:
                response.put("KEX_FAIL_TYPE", "DECRYPT");
                break;
            case (byte) 0x06:
                response.put("KEX_FAIL_TYPE", "CANCEL");
                break;
            case (byte) 0x07:
                response.put("KEX_FAIL_TYPE", "AUTH");
                break;
            case (byte) 0x08:
                response.put("KEX_FAIL_TYPE", "KEY_GET");
                break;
            case (byte) 0x09:
                response.put("KEX_FAIL_TYPE", "KEY_VERIFY");
                break;
            case (byte) 0x0A:
                response.put("KEX_FAIL_TYPE", "KEY_REPORT");
                break;
            default:
                logger.debug("Unknown value {} for constant 'KEX_FAIL_TYPE'", String.format("%02X", payload[2]));
                response.put("KEX_FAIL_TYPE", "UNKNOWN_" + String.format("%02X", payload[2]));
                break;
        }

        // Return the map of processed response data;
        return response;
    }

    /**
     * Creates a new message with the PUBLIC_KEY_REPORT command.<br>
     *
     * Public Key Report<br>
     *
     *
     * @param includingNode {@link Boolean}
     * @param ecdhPublicKey {@link byte[]}
     * @return the {@link byte[]} array with the command to send
     */
    static public byte[] getPublicKeyReport(Boolean includingNode, byte[] ecdhPublicKey) {
        logger.debug("Creating command message PUBLIC_KEY_REPORT version 1");

        ByteArrayOutputStream outputData = new ByteArrayOutputStream();
        outputData.write(COMMAND_CLASS_KEY);
        outputData.write(PUBLIC_KEY_REPORT);

        // Process 'Properties1'
        outputData.write(includingNode ? 0x01 : 0);

        // Process 'ECDH Public Key'
        try {
            outputData.write(ecdhPublicKey);
        } catch (IOException e) {
        }

        return outputData.toByteArray();
    }

    /**
     * Processes a received frame with the PUBLIC_KEY_REPORT command<br>
     *
     * Public Key Report<br>
     *
     *
     * The output data {@link Map} has the following properties<br>
     *
     * <ul>
     * <li>INCLUDING_NODE {@link Boolean}
     * <li>ECDH_PUBLIC_KEY {@link byte[]}
     * </ul>
     *
     * @param payload the {@link byte[]} payload data to process
     * @return a {@link Map} of processed response data
     */
    public static Map<String, Object> handlePublicKeyReport(byte[] payload) {
        // Create our response map
        Map<String, Object> response = new HashMap<String, Object>();

        // We're using variable length fields, so track the offset
        int msgOffset = 2;

        // Process 'Properties1'
        response.put("INCLUDING_NODE", Boolean.valueOf((payload[msgOffset] & 0x01) != 0));
        msgOffset += 1;

        // Process 'ECDH Public Key'
        ByteArrayOutputStream valEcdhPublicKey = new ByteArrayOutputStream();
        while (msgOffset < payload.length) {
            valEcdhPublicKey.write(payload[msgOffset]);
            msgOffset++;
        }
        response.put("ECDH_PUBLIC_KEY", valEcdhPublicKey);

        // Return the map of processed response data;
        return response;
    }

    /**
     * Creates a new message with the SECURITY_2_NETWORK_KEY_GET command.<br>
     *
     * S2 Network Key Get<br>
     *
     *
     * @param requestedKey {@link Integer}
     * @return the {@link byte[]} array with the command to send
     */
    static public byte[] getSecurity2NetworkKeyGet(Integer requestedKey) {
        logger.debug("Creating command message SECURITY_2_NETWORK_KEY_GET version 1");

        ByteArrayOutputStream outputData = new ByteArrayOutputStream();
        outputData.write(COMMAND_CLASS_KEY);
        outputData.write(SECURITY_2_NETWORK_KEY_GET);

        // Process 'Requested Key'
        outputData.write(requestedKey);

        return outputData.toByteArray();
    }

    /**
     * Processes a received frame with the SECURITY_2_NETWORK_KEY_GET command<br>
     *
     * S2 Network Key Get<br>
     *
     *
     * The output data {@link Map} has the following properties<br>
     *
     * <ul>
     * <li>REQUESTED_KEY {@link Integer}
     * </ul>
     *
     * @param payload the {@link byte[]} payload data to process
     * @return a {@link Map} of processed response data
     */
    public static Map<String, Object> handleSecurity2NetworkKeyGet(byte[] payload) {
        // Create our response map
        Map<String, Object> response = new HashMap<String, Object>();

        // Process 'Requested Key'
        switch ((int) payload[2]) {
            case 0x00:
                response.put("REQUESTED_KEY", "UNAUTHENTICATED");
                break;
            case 0x01:
                response.put("REQUESTED_KEY", "AUTHENTICATED");
                break;
            case 0x02:
                response.put("REQUESTED_KEY", "ACCESS");
                break;
            case 0x07:
                response.put("REQUESTED_KEY", "S0");
                break;
            default:
                logger.debug("");
                break;
        }

        // Return the map of processed response data;
        return response;
    }

    /**
     * Creates a new message with the SECURITY_2_NETWORK_KEY_REPORT command.<br>
     *
     * S2 Network Key Report<br>
     *
     *
     * @param grantedKey {@link Integer}
     * @param networkKey {@link byte[]}
     * @return the {@link byte[]} array with the command to send
     */
    static public byte[] getSecurity2NetworkKeyReport(Integer grantedKey, byte[] networkKey) {
        logger.debug("Creating command message SECURITY_2_NETWORK_KEY_REPORT version 1");

        ByteArrayOutputStream outputData = new ByteArrayOutputStream();
        outputData.write(COMMAND_CLASS_KEY);
        outputData.write(SECURITY_2_NETWORK_KEY_REPORT);

        // Process 'Granted Key'
        outputData.write(grantedKey);

        // Process 'Network Key'
        try {
            outputData.write(networkKey);
        } catch (IOException e) {
        }

        return outputData.toByteArray();
    }

    /**
     * Processes a received frame with the SECURITY_2_NETWORK_KEY_REPORT command<br>
     *
     * S2 Network Key Report<br>
     *
     *
     * The output data {@link Map} has the following properties<br>
     *
     * <ul>
     * <li>GRANTED_KEY {@link Integer}
     * <li>NETWORK_KEY {@link byte[]}
     * </ul>
     *
     * @param payload the {@link byte[]} payload data to process
     * @return a {@link Map} of processed response data
     */
    public static Map<String, Object> handleSecurity2NetworkKeyReport(byte[] payload) {
        // Create our response map
        Map<String, Object> response = new HashMap<String, Object>();

        // Process 'Granted Key'
        switch ((int) payload[2]) {
            case 0x00:
                response.put("GRANTED_KEY", "UNAUTHENTICATED");
                break;
            case 0x01:
                response.put("GRANTED_KEY", "AUTHENTICATED");
                break;
            case 0x02:
                response.put("GRANTED_KEY", "ACCESS");
                break;
            case 0x07:
                response.put("GRANTED_KEY", "S0");
                break;
            default:
                logger.debug("");
                break;
        }

        // Process 'Network Key'
        byte[] valNetworkKey = new byte[16];
        for (int cntNetworkKey = 0; cntNetworkKey < 16; cntNetworkKey++) {
            valNetworkKey[cntNetworkKey] = payload[3 + cntNetworkKey];
        }
        response.put("NETWORK_KEY", valNetworkKey);

        // Return the map of processed response data;
        return response;
    }

    /**
     * Creates a new message with the SECURITY_2_NETWORK_KEY_VERIFY command.<br>
     *
     * S2 Network Key Verify<br>
     *
     *
     * @return the {@link byte[]} array with the command to send
     */
    static public byte[] getSecurity2NetworkKeyVerify() {
        logger.debug("Creating command message SECURITY_2_NETWORK_KEY_VERIFY version 1");

        ByteArrayOutputStream outputData = new ByteArrayOutputStream();
        outputData.write(COMMAND_CLASS_KEY);
        outputData.write(SECURITY_2_NETWORK_KEY_VERIFY);

        return outputData.toByteArray();
    }

    /**
     * Processes a received frame with the SECURITY_2_NETWORK_KEY_VERIFY command<br>
     *
     * S2 Network Key Verify<br>
     *
     *
     * @param payload the {@link byte[]} payload data to process
     * @return a {@link Map} of processed response data
     */
    public static Map<String, Object> handleSecurity2NetworkKeyVerify(byte[] payload) {
        // Create our response map
        Map<String, Object> response = new HashMap<String, Object>();

        // Return the map of processed response data;
        return response;
    }

    /**
     * Creates a new message with the SECURITY_2_TRANSFER_END command.<br>
     *
     * S2 Transfer End<br>
     *
     *
     * @param keyRequestComplete {@link Boolean}
     * @param keyVerified {@link Boolean}
     * @return the {@link byte[]} array with the command to send
     */
    static public byte[] getSecurity2TransferEnd(Boolean keyRequestComplete, Boolean keyVerified) {
        logger.debug("Creating command message SECURITY_2_TRANSFER_END version 1");

        ByteArrayOutputStream outputData = new ByteArrayOutputStream();
        outputData.write(COMMAND_CLASS_KEY);
        outputData.write(SECURITY_2_TRANSFER_END);

        // Process 'Properties1'
        int valProperties1 = 0;
        valProperties1 |= keyRequestComplete ? 0x01 : 0;
        valProperties1 |= keyVerified ? 0x02 : 0;
        outputData.write(valProperties1);

        return outputData.toByteArray();
    }

    /**
     * Processes a received frame with the SECURITY_2_TRANSFER_END command<br>
     *
     * S2 Transfer End<br>
     *
     *
     * The output data {@link Map} has the following properties<br>
     *
     * <ul>
     * <li>KEY_REQUEST_COMPLETE {@link Boolean}
     * <li>KEY_VERIFIED {@link Boolean}
     * </ul>
     *
     * @param payload the {@link byte[]} payload data to process
     * @return a {@link Map} of processed response data
     */
    public static Map<String, Object> handleSecurity2TransferEnd(byte[] payload) {
        // Create our response map
        Map<String, Object> response = new HashMap<String, Object>();

        // Process 'Properties1'
        response.put("KEY_REQUEST_COMPLETE", Boolean.valueOf((payload[2] & 0x01) != 0));
        response.put("KEY_VERIFIED", Boolean.valueOf((payload[2] & 0x02) != 0));

        // Return the map of processed response data;
        return response;
    }

    /**
     * Creates a new message with the SECURITY_2_COMMANDS_SUPPORTED_GET command.<br>
     *
     * S2 Commands Supported Get<br>
     *
     *
     * @return the {@link byte[]} array with the command to send
     */
    static public byte[] getSecurity2CommandsSupportedGet() {
        logger.debug("Creating command message SECURITY_2_COMMANDS_SUPPORTED_GET version 1");

        ByteArrayOutputStream outputData = new ByteArrayOutputStream();
        outputData.write(COMMAND_CLASS_KEY);
        outputData.write(SECURITY_2_COMMANDS_SUPPORTED_GET);

        return outputData.toByteArray();
    }

    /**
     * Processes a received frame with the SECURITY_2_COMMANDS_SUPPORTED_GET command<br>
     *
     * S2 Commands Supported Get<br>
     *
     *
     * @param payload the {@link byte[]} payload data to process
     * @return a {@link Map} of processed response data
     */
    public static Map<String, Object> handleSecurity2CommandsSupportedGet(byte[] payload) {
        // Create our response map
        Map<String, Object> response = new HashMap<String, Object>();

        // Return the map of processed response data;
        return response;
    }

    /**
     * Creates a new message with the SECURITY_2_COMMANDS_SUPPORTED_REPORT command.<br>
     *
     * S2 Commands Supported Report<br>
     *
     *
     * @param commandClass {@link List<Integer>}
     * @return the {@link byte[]} array with the command to send
     */
    static public byte[] getSecurity2CommandsSupportedReport(List<Integer> commandClass) {
        logger.debug("Creating command message SECURITY_2_COMMANDS_SUPPORTED_REPORT version 1");

        ByteArrayOutputStream outputData = new ByteArrayOutputStream();
        outputData.write(COMMAND_CLASS_KEY);
        outputData.write(SECURITY_2_COMMANDS_SUPPORTED_REPORT);

        // Process 'Command Class'
        for (Integer valCommandClass : commandClass) {
            outputData.write(valCommandClass);
        }

        return outputData.toByteArray();
    }

    /**
     * Processes a received frame with the SECURITY_2_COMMANDS_SUPPORTED_REPORT command<br>
     *
     * S2 Commands Supported Report<br>
     *
     *
     * The output data {@link Map} has the following properties<br>
     *
     * <ul>
     * <li>COMMAND_CLASS {@link List}<{@link Integer}>
     * </ul>
     *
     * @param payload the {@link byte[]} payload data to process
     * @return a {@link Map} of processed response data
     */
    public static Map<String, Object> handleSecurity2CommandsSupportedReport(byte[] payload) {
        // Create our response map
        Map<String, Object> response = new HashMap<String, Object>();

        // We're using variable length fields, so track the offset
        int msgOffset = 2;

        // Process 'Command Class'
        List<Integer> valCommandClass = new ArrayList<Integer>();
        while (msgOffset < payload.length) {
            valCommandClass.add(payload[msgOffset] & 0xFF);
            msgOffset++;
        }
        response.put("COMMAND_CLASS", valCommandClass);

        // Return the map of processed response data;
        return response;
    }

    /**
     * Creates a new message with the SECURITY_2_CAPABILITIES_GET command.<br>
     *
     * S2 Capabilities Get<br>
     *
     *
     * @return the {@link byte[]} array with the command to send
     */
    static public byte[] getSecurity2CapabilitiesGet() {
        logger.debug("Creating command message SECURITY_2_CAPABILITIES_GET version 1");

        ByteArrayOutputStream outputData = new ByteArrayOutputStream();
        outputData.write(COMMAND_CLASS_KEY);
        outputData.write(SECURITY_2_CAPABILITIES_GET);

        return outputData.toByteArray();
    }

    /**
     * Processes a received frame with the SECURITY_2_CAPABILITIES_GET command<br>
     *
     * S2 Capabilities Get<br>
     *
     *
     * @param payload the {@link byte[]} payload data to process
     * @return a {@link Map} of processed response data
     */
    public static Map<String, Object> handleSecurity2CapabilitiesGet(byte[] payload) {
        // Create our response map
        Map<String, Object> response = new HashMap<String, Object>();

        // Return the map of processed response data;
        return response;
    }

    /**
     * Creates a new message with the SECURITY_2_CAPABILITIES_REPORT command.<br>
     *
     * S2 Capabilities Report<br>
     *
     *
     * @param supportedSpans {@link Integer}
     * @param supportedMpans {@link Integer}
     * @return the {@link byte[]} array with the command to send
     */
    static public byte[] getSecurity2CapabilitiesReport(Integer supportedSpans, Integer supportedMpans) {
        logger.debug("Creating command message SECURITY_2_CAPABILITIES_REPORT version 1");

        ByteArrayOutputStream outputData = new ByteArrayOutputStream();
        outputData.write(COMMAND_CLASS_KEY);
        outputData.write(SECURITY_2_CAPABILITIES_REPORT);

        // Process 'Supported SPANs'
        outputData.write(supportedSpans);

        // Process 'Supported MPANs'
        outputData.write(supportedMpans);

        return outputData.toByteArray();
    }

    /**
     * Processes a received frame with the SECURITY_2_CAPABILITIES_REPORT command<br>
     *
     * S2 Capabilities Report<br>
     *
     *
     * The output data {@link Map} has the following properties<br>
     *
     * <ul>
     * <li>SUPPORTED_SPANS {@link Integer}
     * <li>SUPPORTED_MPANS {@link Integer}
     * </ul>
     *
     * @param payload the {@link byte[]} payload data to process
     * @return a {@link Map} of processed response data
     */
    public static Map<String, Object> handleSecurity2CapabilitiesReport(byte[] payload) {
        // Create our response map
        Map<String, Object> response = new HashMap<String, Object>();

        // Process 'Supported SPANs'
        response.put("SUPPORTED_SPANS", Integer.valueOf(payload[2]));

        // Process 'Supported MPANs'
        response.put("SUPPORTED_MPANS", Integer.valueOf(payload[3]));

        // Return the map of processed response data;
        return response;
    }

}
