/**
 * Copyright (c) 2016-2017 by the respective copyright holders.
 *
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Eclipse Public License v1.0
 * which accompanies this distribution, and is available at
 * http://www.eclipse.org/legal/epl-v10.html
 */
package com.zsmartsystems.zwave.commandclass.impl;

import java.io.ByteArrayOutputStream;
import java.io.IOException;
import java.lang.IllegalArgumentException;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

/**
 * Class to implement the Z-Wave command class <b>COMMAND_CLASS_SECURITY_2</b> version <b>1</b>.
 * <p>
 * Command Class Security 2
 * <p>
 * This class provides static methods for processing received messages (message handler) and
 * methods to get a message to send on the Z-Wave network.
 * <p>
 * Note that this code is autogenerated. Manual changes may be overwritten.
 *
 * @author Chris Jackson - Initial contribution of Java code generator
 */
public class CommandClassSecurity2V1 {
    private static final Logger logger = LoggerFactory.getLogger(CommandClassSecurity2V1.class);

    /**
     * Integer command class key for COMMAND_CLASS_SECURITY_2
     */
    public final static int COMMAND_CLASS_KEY = 0x9F;

    /**
     * S2 Nonce Get Command Constant
     */
    public final static int SECURITY_2_NONCE_GET = 0x01;
    /**
     * S2 Nonce Report Command Constant
     */
    public final static int SECURITY_2_NONCE_REPORT = 0x02;
    /**
     * S2 Message Encapsulation Command Constant
     */
    public final static int SECURITY_2_MESSAGE_ENCAPSULATION = 0x03;
    /**
     * KEX Get Command Constant
     */
    public final static int KEX_GET = 0x04;
    /**
     * KEX Report Command Constant
     */
    public final static int KEX_REPORT = 0x05;
    /**
     * KEX Set Command Constant
     */
    public final static int KEX_SET = 0x06;
    /**
     * KEX Fail Command Constant
     */
    public final static int KEX_FAIL = 0x07;
    /**
     * Public Key Report Command Constant
     */
    public final static int PUBLIC_KEY_REPORT = 0x08;
    /**
     * S2 Network Key Get Command Constant
     */
    public final static int SECURITY_2_NETWORK_KEY_GET = 0x09;
    /**
     * S2 Network Key Report Command Constant
     */
    public final static int SECURITY_2_NETWORK_KEY_REPORT = 0x0A;
    /**
     * S2 Network Key Verify Command Constant
     */
    public final static int SECURITY_2_NETWORK_KEY_VERIFY = 0x0B;
    /**
     * S2 Transfer End Command Constant
     */
    public final static int SECURITY_2_TRANSFER_END = 0x0C;
    /**
     * S2 Commands Supported Get Command Constant
     */
    public final static int SECURITY_2_COMMANDS_SUPPORTED_GET = 0x0D;
    /**
     * S2 Commands Supported Report Command Constant
     */
    public final static int SECURITY_2_COMMANDS_SUPPORTED_REPORT = 0x0E;
    /**
     * S2 Capabilities Get Command Constant
     */
    public final static int SECURITY_2_CAPABILITIES_GET = 0x0F;
    /**
     * S2 Capabilities Report Command Constant
     */
    public final static int SECURITY_2_CAPABILITIES_REPORT = 0x10;


    /**
     * Map holding constants for Properties1
     */
    private static Map<Integer, String> constantProperties1 = new HashMap<Integer, String>();

    /**
     * Map holding constants for Requested Keys
     */
    private static Map<Integer, String> constantRequestedKeys = new HashMap<Integer, String>();

    /**
     * Map holding constants for Granted Keys
     */
    private static Map<Integer, String> constantGrantedKeys = new HashMap<Integer, String>();

    /**
     * Map holding constants for Granted Key
     */
    private static Map<Integer, String> constantGrantedKey = new HashMap<Integer, String>();

    /**
     * Map holding constants for KEX Fail Type
     */
    private static Map<Integer, String> constantKexFailType = new HashMap<Integer, String>();

    /**
     * Map holding constants for Requested Key
     */
    private static Map<Integer, String> constantRequestedKey = new HashMap<Integer, String>();
    static {

        // Constants for Properties1
        constantProperties1.put(0x01, "SOS");
        constantProperties1.put(0x02, "MOS");

        // Constants for Requested Keys
        constantRequestedKeys.put(0x00, "UNAUTHENTICATED");
        constantRequestedKeys.put(0x01, "AUTHENTICATED");
        constantRequestedKeys.put(0x02, "ACCESS");
        constantRequestedKeys.put(0x07, "S0");

        // Constants for Granted Keys
        constantGrantedKeys.put(0x00, "UNAUTHENTICATED");
        constantGrantedKeys.put(0x01, "AUTHENTICATED");
        constantGrantedKeys.put(0x02, "ACCESS");
        constantGrantedKeys.put(0x07, "S0");

        // Constants for Granted Key
        constantGrantedKey.put(0x00, "UNAUTHENTICATED");
        constantGrantedKey.put(0x01, "AUTHENTICATED");
        constantGrantedKey.put(0x02, "ACCESS");
        constantGrantedKey.put(0x07, "S0");

        // Constants for KEX Fail Type
        constantKexFailType.put(0x01, "KEX_KEY");
        constantKexFailType.put(0x02, "KEX_SCHEME");
        constantKexFailType.put(0x03, "KEX_CURVES");
        constantKexFailType.put(0x05, "DECRYPT");
        constantKexFailType.put(0x06, "CANCEL");
        constantKexFailType.put(0x07, "AUTH");
        constantKexFailType.put(0x08, "KEY_GET");
        constantKexFailType.put(0x09, "KEY_VERIFY");
        constantKexFailType.put(0x0A, "KEY_REPORT");

        // Constants for Requested Key
        constantRequestedKey.put(0x00, "UNAUTHENTICATED");
        constantRequestedKey.put(0x01, "AUTHENTICATED");
        constantRequestedKey.put(0x02, "ACCESS");
        constantRequestedKey.put(0x07, "S0");
    }

    /**
     * Creates a new message with the SECURITY_2_NONCE_GET command.
     * <p>
     * S2 Nonce Get
     *
     * @param sequenceNumber {@link Integer}
     * @return the {@link byte[]} array with the command to send
     */
    static public byte[] getSecurity2NonceGet(Integer sequenceNumber) {
        logger.debug("Creating command message SECURITY_2_NONCE_GET version 1");

        ByteArrayOutputStream outputData = new ByteArrayOutputStream();
        outputData.write(COMMAND_CLASS_KEY);
        outputData.write(SECURITY_2_NONCE_GET);

        // Process 'Sequence Number'
        outputData.write(sequenceNumber);

        return outputData.toByteArray();
    }

    /**
     * Processes a received frame with the SECURITY_2_NONCE_GET command.
     * <p>
     * S2 Nonce Get
     * <p>
     * The output data {@link Map} has the following properties -:
     *
     * <ul>
     * <li>SEQUENCE_NUMBER {@link Integer}
     * </ul>
     *
     * @param payload the {@link byte[]} payload data to process
     * @return a {@link Map} of processed response data
     */
    public static Map<String, Object> handleSecurity2NonceGet(byte[] payload) {
        // Create our response map
        Map<String, Object> response = new HashMap<String, Object>();

        // Process 'Sequence Number'
        response.put("SEQUENCE_NUMBER", Integer.valueOf(payload[2]));

        // Return the map of processed response data;
        return response;
    }


    /**
     * Creates a new message with the SECURITY_2_NONCE_REPORT command.
     * <p>
     * S2 Nonce Report
     *
     * @param sequenceNumber {@link Integer}
     * @param sos {@link Boolean}
     * @param mos {@link Boolean}
     * @param receiversEntropyInput {@link byte[]}
     * @return the {@link byte[]} array with the command to send
     */
    static public byte[] getSecurity2NonceReport(Integer sequenceNumber, Boolean sos, Boolean mos,
            byte[] receiversEntropyInput) {
        logger.debug("Creating command message SECURITY_2_NONCE_REPORT version 1");

        ByteArrayOutputStream outputData = new ByteArrayOutputStream();
        outputData.write(COMMAND_CLASS_KEY);
        outputData.write(SECURITY_2_NONCE_REPORT);

        // Process 'Sequence Number'
        outputData.write(sequenceNumber);

        // Process 'Properties1'
        int valProperties1 = 0;
        valProperties1 |= sos ? 0x01 : 0;
        valProperties1 |= mos ? 0x02 : 0;
        outputData.write(valProperties1);

        // Process 'Receivers Entropy Input'
        if (receiversEntropyInput != null) {
            if (receiversEntropyInput.length > 16) {
                throw new IllegalArgumentException("Length of array receiversEntropyInput exceeds maximum length of 16 bytes
            }
            try {
                outputData.write(receiversEntropyInput);
            } catch (IOException e) {
            }
        }

        return outputData.toByteArray();
    }

    /**
     * Processes a received frame with the SECURITY_2_NONCE_REPORT command.
     * <p>
     * S2 Nonce Report
     * <p>
     * The output data {@link Map} has the following properties -:
     *
     * <ul>
     * <li>SEQUENCE_NUMBER {@link Integer}
     * <li>SOS {@link Boolean}
     * <li>MOS {@link Boolean}
     * <li>RECEIVERS_ENTROPY_INPUT {@link byte[]}
     * </ul>
     *
     * @param payload the {@link byte[]} payload data to process
     * @return a {@link Map} of processed response data
     */
    public static Map<String, Object> handleSecurity2NonceReport(byte[] payload) {
        // Create our response map
        Map<String, Object> response = new HashMap<String, Object>();

        // Process 'Sequence Number'
        response.put("SEQUENCE_NUMBER", Integer.valueOf(payload[2]));

        // Process 'Properties1'
        response.put("SOS", Boolean.valueOf((payload[3] & 0x01) != 0));
        response.put("MOS", Boolean.valueOf((payload[3] & 0x02) != 0));

        // Process 'Receivers Entropy Input'
        byte[] valReceiversEntropyInput = new byte[16];
        for (int cntReceiversEntropyInput = 0; cntReceiversEntropyInput < 16; cntReceiversEntropyInput++) {
            valReceiversEntropyInput[cntReceiversEntropyInput] = payload[4 + cntReceiversEntropyInput];
        }
        response.put("RECEIVERS_ENTROPY_INPUT", valReceiversEntropyInput);

        // Return the map of processed response data;
        return response;
    }


    /**
     * Creates a new message with the SECURITY_2_MESSAGE_ENCAPSULATION command.
     * <p>
     * S2 Message Encapsulation
     *
     * @param sequenceNumber {@link Integer}
     * @param extension {@link Boolean}
     * @param encryptedExtension {@link Boolean}
     * @param ccmCiphertextObject {@link byte[]}
     * @return the {@link byte[]} array with the command to send
     */
    static public byte[] getSecurity2MessageEncapsulation(Integer sequenceNumber, Boolean extension,
            Boolean encryptedExtension, byte[] ccmCiphertextObject) {
        logger.debug("Creating command message SECURITY_2_MESSAGE_ENCAPSULATION version 1");

        ByteArrayOutputStream outputData = new ByteArrayOutputStream();
        outputData.write(COMMAND_CLASS_KEY);
        outputData.write(SECURITY_2_MESSAGE_ENCAPSULATION);

        // Process 'Sequence Number'
        outputData.write(sequenceNumber);

        // Process 'Properties1'
        int valProperties1 = 0;
        valProperties1 |= extension ? 0x01 : 0;
        valProperties1 |= encryptedExtension ? 0x02 : 0;
        outputData.write(valProperties1);

        // Process 'vg1'

        // Process 'CCM Ciphertext Object'
        if (ccmCiphertextObject != null) {
            try {
                outputData.write(ccmCiphertextObject);
            } catch (IOException e) {
            }
        }

        return outputData.toByteArray();
    }

    /**
     * Processes a received frame with the SECURITY_2_MESSAGE_ENCAPSULATION command.
     * <p>
     * S2 Message Encapsulation
     * <p>
     * The output data {@link Map} has the following properties -:
     *
     * <ul>
     * <li>SEQUENCE_NUMBER {@link Integer}
     * <li>EXTENSION {@link Boolean}
     * <li>ENCRYPTED_EXTENSION {@link Boolean}
     * <li>CCM_CIPHERTEXT_OBJECT {@link byte[]}
     * </ul>
     *
     * @param payload the {@link byte[]} payload data to process
     * @return a {@link Map} of processed response data
     */
    public static Map<String, Object> handleSecurity2MessageEncapsulation(byte[] payload) {
        // Create our response map
        Map<String, Object> response = new HashMap<String, Object>();

        // We're using variable length fields, so track the offset
        int msgOffset = 2;

        // Process 'Sequence Number'
        response.put("SEQUENCE_NUMBER", Integer.valueOf(payload[msgOffset]));
        msgOffset += 1;

        // Process 'Properties1'
        response.put("EXTENSION", Boolean.valueOf((payload[msgOffset] & 0x01) != 0));
        response.put("ENCRYPTED_EXTENSION", Boolean.valueOf((payload[msgOffset] & 0x02) != 0));
        msgOffset += 1;

        // Process 'vg1'

        // Create a list to hold the group vg1
        List<Map<String, Object>> variantList = new ArrayList<Map<String, Object>>();

        int offset = msgOffset;
        while (offset < payload.length) {
            // Create a map to hold the members of this variant
            Map<String, Object> variant = new HashMap<String, Object>();

            // Process 'Extension Length'
            variant.put("EXTENSION_LENGTH", Integer.valueOf(payload[msgOffset]));
            msgOffset += 1;

            // Process 'Properties1'
            variant.put("TYPE", Integer.valueOf(payload[msgOffset] & 0x3F));
            variant.put("CRITICAL", Boolean.valueOf((payload[msgOffset] & 0x40) != 0));
            variant.put("MORE_TO_FOLLOW", Boolean.valueOf((payload[msgOffset] & 0x80) != 0));
            msgOffset += 1;

            // Process 'Extension'
            variant.put("EXTENSION", Integer.valueOf(payload[msgOffset]));
            msgOffset += payload[msgOffset - 2];

        }

        // Add the variant list to the response
        response.put("VG1", variantList);

        // Process 'CCM Ciphertext Object'
        ByteArrayOutputStream valCcmCiphertextObject = new ByteArrayOutputStream();
        while (msgOffset < payload.length) {
            valCcmCiphertextObject.write(payload[msgOffset]);
            msgOffset++;
        }
        response.put("CCM_CIPHERTEXT_OBJECT", valCcmCiphertextObject);

        // Return the map of processed response data;
        return response;
    }


    /**
     * Creates a new message with the KEX_GET command.
     * <p>
     * KEX Get
     *
     * @return the {@link byte[]} array with the command to send
     */
    static public byte[] getKexGet() {
        logger.debug("Creating command message KEX_GET version 1");

        ByteArrayOutputStream outputData = new ByteArrayOutputStream();
        outputData.write(COMMAND_CLASS_KEY);
        outputData.write(KEX_GET);

        return outputData.toByteArray();
    }

    /**
     * Processes a received frame with the KEX_GET command.
     * <p>
     * KEX Get
     *
     * @param payload the {@link byte[]} payload data to process
     * @return a {@link Map} of processed response data
     */
    public static Map<String, Object> handleKexGet(byte[] payload) {
        // Create our response map
        Map<String, Object> response = new HashMap<String, Object>();

        // Return the map of processed response data;
        return response;
    }


    /**
     * Creates a new message with the KEX_REPORT command.
     * <p>
     * KEX Report
     *
     * @param echo {@link Boolean}
     * @param requestCsa {@link Boolean}
     * @param supportedKexSchemes {@link Integer}
     * @param supportedEcdhProfiles {@link Integer}
     * @param requestedKeys {@link List<String>}
     *            Can be one of the following -:
     *            <ul>
     *            <li>UNAUTHENTICATED
     *            <li>AUTHENTICATED
     *            <li>ACCESS
     *            <li>S0
     *            </ul>
     * @return the {@link byte[]} array with the command to send
     */
    static public byte[] getKexReport(Boolean echo, Boolean requestCsa, Integer supportedKexSchemes,
            Integer supportedEcdhProfiles, List<String> requestedKeys) {
        logger.debug("Creating command message KEX_REPORT version 1");

        ByteArrayOutputStream outputData = new ByteArrayOutputStream();
        outputData.write(COMMAND_CLASS_KEY);
        outputData.write(KEX_REPORT);

        // Process 'Properties1'
        int valProperties1 = 0;
        valProperties1 |= echo ? 0x01 : 0;
        valProperties1 |= requestCsa ? 0x02 : 0;
        outputData.write(valProperties1);

        // Process 'Supported KEX Schemes'
        outputData.write(supportedKexSchemes);

        // Process 'Supported ECDH Profiles'
        outputData.write(supportedEcdhProfiles);

        // Process 'Requested Keys'
        int valRequestedKeys = 0;
        valRequestedKeys |= (requestedKeys.contains("UNAUTHENTICATED") ? 0x01 : 0);
        valRequestedKeys |= (requestedKeys.contains("AUTHENTICATED") ? 0x02 : 0);
        valRequestedKeys |= (requestedKeys.contains("ACCESS") ? 0x04 : 0);
        valRequestedKeys |= (requestedKeys.contains("S0") ? 0x80 : 0);
        outputData.write(valRequestedKeys);

        return outputData.toByteArray();
    }

    /**
     * Processes a received frame with the KEX_REPORT command.
     * <p>
     * KEX Report
     * <p>
     * The output data {@link Map} has the following properties -:
     *
     * <ul>
     * <li>ECHO {@link Boolean}
     * <li>REQUEST_CSA {@link Boolean}
     * <li>SUPPORTED_KEX_SCHEMES {@link Integer}
     * <li>SUPPORTED_ECDH_PROFILES {@link Integer}
     * <li>REQUESTED_KEYS {@link List}<{@link String}>
     * </ul>
     *
     * @param payload the {@link byte[]} payload data to process
     * @return a {@link Map} of processed response data
     */
    public static Map<String, Object> handleKexReport(byte[] payload) {
        // Create our response map
        Map<String, Object> response = new HashMap<String, Object>();

        // Process 'Properties1'
        response.put("ECHO", Boolean.valueOf((payload[2] & 0x01) != 0));
        response.put("REQUEST_CSA", Boolean.valueOf((payload[2] & 0x02) != 0));

        // Process 'Supported KEX Schemes'
        response.put("SUPPORTED_KEX_SCHEMES", Integer.valueOf(payload[3]));

        // Process 'Supported ECDH Profiles'
        response.put("SUPPORTED_ECDH_PROFILES", Integer.valueOf(payload[4]));

        // Process 'Requested Keys'
        List<String> responseRequestedKeys = new ArrayList<String>();
        int lenRequestedKeys = 1;
        for (int cntRequestedKeys = 0; cntRequestedKeys < lenRequestedKeys; cntRequestedKeys++) {
            if ((payload[5 + (cntRequestedKeys / 8)] & (1 << cntRequestedKeys % 8)) == 0) {
                continue;
            }
            responseRequestedKeys.add(constantRequestedKeys.get(cntRequestedKeys));
        }
        response.put("REQUESTED_KEYS", responseRequestedKeys);

        // Return the map of processed response data;
        return response;
    }


    /**
     * Creates a new message with the KEX_SET command.
     * <p>
     * KEX Set
     *
     * @param echo {@link Boolean}
     * @param requestCsa {@link Boolean}
     * @param selectedKexScheme {@link Integer}
     * @param selectedEcdhProfile {@link Integer}
     * @param grantedKeys {@link List<String>}
     *            Can be one of the following -:
     *            <ul>
     *            <li>UNAUTHENTICATED
     *            <li>AUTHENTICATED
     *            <li>ACCESS
     *            <li>S0
     *            </ul>
     * @return the {@link byte[]} array with the command to send
     */
    static public byte[] getKexSet(Boolean echo, Boolean requestCsa, Integer selectedKexScheme,
            Integer selectedEcdhProfile, List<String> grantedKeys) {
        logger.debug("Creating command message KEX_SET version 1");

        ByteArrayOutputStream outputData = new ByteArrayOutputStream();
        outputData.write(COMMAND_CLASS_KEY);
        outputData.write(KEX_SET);

        // Process 'Properties1'
        int valProperties1 = 0;
        valProperties1 |= echo ? 0x01 : 0;
        valProperties1 |= requestCsa ? 0x02 : 0;
        outputData.write(valProperties1);

        // Process 'Selected KEX Scheme'
        outputData.write(selectedKexScheme);

        // Process 'Selected ECDH Profile'
        outputData.write(selectedEcdhProfile);

        // Process 'Granted Keys'
        int valGrantedKeys = 0;
        valGrantedKeys |= (grantedKeys.contains("UNAUTHENTICATED") ? 0x01 : 0);
        valGrantedKeys |= (grantedKeys.contains("AUTHENTICATED") ? 0x02 : 0);
        valGrantedKeys |= (grantedKeys.contains("ACCESS") ? 0x04 : 0);
        valGrantedKeys |= (grantedKeys.contains("S0") ? 0x80 : 0);
        outputData.write(valGrantedKeys);

        return outputData.toByteArray();
    }

    /**
     * Processes a received frame with the KEX_SET command.
     * <p>
     * KEX Set
     * <p>
     * The output data {@link Map} has the following properties -:
     *
     * <ul>
     * <li>ECHO {@link Boolean}
     * <li>REQUEST_CSA {@link Boolean}
     * <li>SELECTED_KEX_SCHEME {@link Integer}
     * <li>SELECTED_ECDH_PROFILE {@link Integer}
     * <li>GRANTED_KEYS {@link List}<{@link String}>
     * </ul>
     *
     * @param payload the {@link byte[]} payload data to process
     * @return a {@link Map} of processed response data
     */
    public static Map<String, Object> handleKexSet(byte[] payload) {
        // Create our response map
        Map<String, Object> response = new HashMap<String, Object>();

        // Process 'Properties1'
        response.put("ECHO", Boolean.valueOf((payload[2] & 0x01) != 0));
        response.put("REQUEST_CSA", Boolean.valueOf((payload[2] & 0x02) != 0));

        // Process 'Selected KEX Scheme'
        response.put("SELECTED_KEX_SCHEME", Integer.valueOf(payload[3]));

        // Process 'Selected ECDH Profile'
        response.put("SELECTED_ECDH_PROFILE", Integer.valueOf(payload[4]));

        // Process 'Granted Keys'
        List<String> responseGrantedKeys = new ArrayList<String>();
        int lenGrantedKeys = 1;
        for (int cntGrantedKeys = 0; cntGrantedKeys < lenGrantedKeys; cntGrantedKeys++) {
            if ((payload[5 + (cntGrantedKeys / 8)] & (1 << cntGrantedKeys % 8)) == 0) {
                continue;
            }
            responseGrantedKeys.add(constantGrantedKeys.get(cntGrantedKeys));
        }
        response.put("GRANTED_KEYS", responseGrantedKeys);

        // Return the map of processed response data;
        return response;
    }


    /**
     * Creates a new message with the KEX_FAIL command.
     * <p>
     * KEX Fail
     *
     * @param kexFailType {@link String}
     *            Can be one of the following -:
     *            <ul>
     *            <li>KEX_KEY
     *            <li>KEX_SCHEME
     *            <li>KEX_CURVES
     *            <li>DECRYPT
     *            <li>CANCEL
     *            <li>AUTH
     *            <li>KEY_GET
     *            <li>KEY_VERIFY
     *            <li>KEY_REPORT
     *            </ul>
     * @return the {@link byte[]} array with the command to send
     */
    static public byte[] getKexFail(String kexFailType) {
        logger.debug("Creating command message KEX_FAIL version 1");

        ByteArrayOutputStream outputData = new ByteArrayOutputStream();
        outputData.write(COMMAND_CLASS_KEY);
        outputData.write(KEX_FAIL);

        // Process 'KEX Fail Type'
        boolean foundKexFailType = false;
        for (Integer entry : constantKexFailType.keySet()) {
            if (constantKexFailType.get(entry).equals(kexFailType)) {
                outputData.write(entry);
                foundKexFailType = true;
                break;
            }
        }
        if (!foundKexFailType) {
            throw new IllegalArgumentException("Unknown constant value '" + kexFailType + "' for kexFailType");
        }

        return outputData.toByteArray();
    }

    /**
     * Processes a received frame with the KEX_FAIL command.
     * <p>
     * KEX Fail
     * <p>
     * The output data {@link Map} has the following properties -:
     *
     * <ul>
     * <li>KEX_FAIL_TYPE {@link String}
     * </ul>
     *
     * @param payload the {@link byte[]} payload data to process
     * @return a {@link Map} of processed response data
     */
    public static Map<String, Object> handleKexFail(byte[] payload) {
        // Create our response map
        Map<String, Object> response = new HashMap<String, Object>();

        // Process 'KEX Fail Type'
        response.put("KEX_FAIL_TYPE", constantKexFailType.get(payload[2] & 0xff));

        // Return the map of processed response data;
        return response;
    }


    /**
     * Creates a new message with the PUBLIC_KEY_REPORT command.
     * <p>
     * Public Key Report
     *
     * @param includingNode {@link Boolean}
     * @param ecdhPublicKey {@link byte[]}
     * @return the {@link byte[]} array with the command to send
     */
    static public byte[] getPublicKeyReport(Boolean includingNode, byte[] ecdhPublicKey) {
        logger.debug("Creating command message PUBLIC_KEY_REPORT version 1");

        ByteArrayOutputStream outputData = new ByteArrayOutputStream();
        outputData.write(COMMAND_CLASS_KEY);
        outputData.write(PUBLIC_KEY_REPORT);

        // Process 'Properties1'
        outputData.write(includingNode ? 0x01 : 0);

        // Process 'ECDH Public Key'
        if (ecdhPublicKey != null) {
            try {
                outputData.write(ecdhPublicKey);
            } catch (IOException e) {
            }
        }

        return outputData.toByteArray();
    }

    /**
     * Processes a received frame with the PUBLIC_KEY_REPORT command.
     * <p>
     * Public Key Report
     * <p>
     * The output data {@link Map} has the following properties -:
     *
     * <ul>
     * <li>INCLUDING_NODE {@link Boolean}
     * <li>ECDH_PUBLIC_KEY {@link byte[]}
     * </ul>
     *
     * @param payload the {@link byte[]} payload data to process
     * @return a {@link Map} of processed response data
     */
    public static Map<String, Object> handlePublicKeyReport(byte[] payload) {
        // Create our response map
        Map<String, Object> response = new HashMap<String, Object>();

        // We're using variable length fields, so track the offset
        int msgOffset = 2;

        // Process 'Properties1'
        response.put("INCLUDING_NODE", Boolean.valueOf((payload[msgOffset] & 0x01) != 0));
        msgOffset += 1;

        // Process 'ECDH Public Key'
        ByteArrayOutputStream valEcdhPublicKey = new ByteArrayOutputStream();
        while (msgOffset < payload.length) {
            valEcdhPublicKey.write(payload[msgOffset]);
            msgOffset++;
        }
        response.put("ECDH_PUBLIC_KEY", valEcdhPublicKey);

        // Return the map of processed response data;
        return response;
    }


    /**
     * Creates a new message with the SECURITY_2_NETWORK_KEY_GET command.
     * <p>
     * S2 Network Key Get
     *
     * @param requestedKey {@link String}
     *            Can be one of the following -:
     *            <ul>
     *            <li>UNAUTHENTICATED
     *            <li>AUTHENTICATED
     *            <li>ACCESS
     *            <li>S0
     *            </ul>
     * @return the {@link byte[]} array with the command to send
     */
    static public byte[] getSecurity2NetworkKeyGet(String requestedKey) {
        logger.debug("Creating command message SECURITY_2_NETWORK_KEY_GET version 1");

        ByteArrayOutputStream outputData = new ByteArrayOutputStream();
        outputData.write(COMMAND_CLASS_KEY);
        outputData.write(SECURITY_2_NETWORK_KEY_GET);

        // Process 'Requested Key'
        boolean foundRequestedKey = false;
        for (Integer entry : constantRequestedKey.keySet()) {
            if (constantRequestedKey.get(entry).equals(requestedKey)) {
                outputData.write(entry);
                foundRequestedKey = true;
                break;
            }
        }
        if (!foundRequestedKey) {
            throw new IllegalArgumentException("Unknown constant value '" + requestedKey + "' for requestedKey");
        }

        return outputData.toByteArray();
    }

    /**
     * Processes a received frame with the SECURITY_2_NETWORK_KEY_GET command.
     * <p>
     * S2 Network Key Get
     * <p>
     * The output data {@link Map} has the following properties -:
     *
     * <ul>
     * <li>REQUESTED_KEY {@link String}
     * </ul>
     *
     * @param payload the {@link byte[]} payload data to process
     * @return a {@link Map} of processed response data
     */
    public static Map<String, Object> handleSecurity2NetworkKeyGet(byte[] payload) {
        // Create our response map
        Map<String, Object> response = new HashMap<String, Object>();

        // Process 'Requested Key'
        response.put("REQUESTED_KEY", constantRequestedKey.get(payload[2] & 0xff));

        // Return the map of processed response data;
        return response;
    }


    /**
     * Creates a new message with the SECURITY_2_NETWORK_KEY_REPORT command.
     * <p>
     * S2 Network Key Report
     *
     * @param grantedKey {@link String}
     *            Can be one of the following -:
     *            <ul>
     *            <li>UNAUTHENTICATED
     *            <li>AUTHENTICATED
     *            <li>ACCESS
     *            <li>S0
     *            </ul>
     * @param networkKey {@link byte[]}
     * @return the {@link byte[]} array with the command to send
     */
    static public byte[] getSecurity2NetworkKeyReport(String grantedKey, byte[] networkKey) {
        logger.debug("Creating command message SECURITY_2_NETWORK_KEY_REPORT version 1");

        ByteArrayOutputStream outputData = new ByteArrayOutputStream();
        outputData.write(COMMAND_CLASS_KEY);
        outputData.write(SECURITY_2_NETWORK_KEY_REPORT);

        // Process 'Granted Key'
        boolean foundGrantedKey = false;
        for (Integer entry : constantGrantedKey.keySet()) {
            if (constantGrantedKey.get(entry).equals(grantedKey)) {
                outputData.write(entry);
                foundGrantedKey = true;
                break;
            }
        }
        if (!foundGrantedKey) {
            throw new IllegalArgumentException("Unknown constant value '" + grantedKey + "' for grantedKey");
        }

        // Process 'Network Key'
        if (networkKey != null) {
            if (networkKey.length > 16) {
                throw new IllegalArgumentException("Length of array networkKey exceeds maximum length of 16 bytes
            }
            try {
                outputData.write(networkKey);
            } catch (IOException e) {
            }
        }

        return outputData.toByteArray();
    }

    /**
     * Processes a received frame with the SECURITY_2_NETWORK_KEY_REPORT command.
     * <p>
     * S2 Network Key Report
     * <p>
     * The output data {@link Map} has the following properties -:
     *
     * <ul>
     * <li>GRANTED_KEY {@link String}
     * <li>NETWORK_KEY {@link byte[]}
     * </ul>
     *
     * @param payload the {@link byte[]} payload data to process
     * @return a {@link Map} of processed response data
     */
    public static Map<String, Object> handleSecurity2NetworkKeyReport(byte[] payload) {
        // Create our response map
        Map<String, Object> response = new HashMap<String, Object>();

        // Process 'Granted Key'
        response.put("GRANTED_KEY", constantGrantedKey.get(payload[2] & 0xff));

        // Process 'Network Key'
        byte[] valNetworkKey = new byte[16];
        for (int cntNetworkKey = 0; cntNetworkKey < 16; cntNetworkKey++) {
            valNetworkKey[cntNetworkKey] = payload[3 + cntNetworkKey];
        }
        response.put("NETWORK_KEY", valNetworkKey);

        // Return the map of processed response data;
        return response;
    }


    /**
     * Creates a new message with the SECURITY_2_NETWORK_KEY_VERIFY command.
     * <p>
     * S2 Network Key Verify
     *
     * @return the {@link byte[]} array with the command to send
     */
    static public byte[] getSecurity2NetworkKeyVerify() {
        logger.debug("Creating command message SECURITY_2_NETWORK_KEY_VERIFY version 1");

        ByteArrayOutputStream outputData = new ByteArrayOutputStream();
        outputData.write(COMMAND_CLASS_KEY);
        outputData.write(SECURITY_2_NETWORK_KEY_VERIFY);

        return outputData.toByteArray();
    }

    /**
     * Processes a received frame with the SECURITY_2_NETWORK_KEY_VERIFY command.
     * <p>
     * S2 Network Key Verify
     *
     * @param payload the {@link byte[]} payload data to process
     * @return a {@link Map} of processed response data
     */
    public static Map<String, Object> handleSecurity2NetworkKeyVerify(byte[] payload) {
        // Create our response map
        Map<String, Object> response = new HashMap<String, Object>();

        // Return the map of processed response data;
        return response;
    }


    /**
     * Creates a new message with the SECURITY_2_TRANSFER_END command.
     * <p>
     * S2 Transfer End
     *
     * @param keyRequestComplete {@link Boolean}
     * @param keyVerified {@link Boolean}
     * @return the {@link byte[]} array with the command to send
     */
    static public byte[] getSecurity2TransferEnd(Boolean keyRequestComplete, Boolean keyVerified) {
        logger.debug("Creating command message SECURITY_2_TRANSFER_END version 1");

        ByteArrayOutputStream outputData = new ByteArrayOutputStream();
        outputData.write(COMMAND_CLASS_KEY);
        outputData.write(SECURITY_2_TRANSFER_END);

        // Process 'Properties1'
        int valProperties1 = 0;
        valProperties1 |= keyRequestComplete ? 0x01 : 0;
        valProperties1 |= keyVerified ? 0x02 : 0;
        outputData.write(valProperties1);

        return outputData.toByteArray();
    }

    /**
     * Processes a received frame with the SECURITY_2_TRANSFER_END command.
     * <p>
     * S2 Transfer End
     * <p>
     * The output data {@link Map} has the following properties -:
     *
     * <ul>
     * <li>KEY_REQUEST_COMPLETE {@link Boolean}
     * <li>KEY_VERIFIED {@link Boolean}
     * </ul>
     *
     * @param payload the {@link byte[]} payload data to process
     * @return a {@link Map} of processed response data
     */
    public static Map<String, Object> handleSecurity2TransferEnd(byte[] payload) {
        // Create our response map
        Map<String, Object> response = new HashMap<String, Object>();

        // Process 'Properties1'
        response.put("KEY_REQUEST_COMPLETE", Boolean.valueOf((payload[2] & 0x01) != 0));
        response.put("KEY_VERIFIED", Boolean.valueOf((payload[2] & 0x02) != 0));

        // Return the map of processed response data;
        return response;
    }


    /**
     * Creates a new message with the SECURITY_2_COMMANDS_SUPPORTED_GET command.
     * <p>
     * S2 Commands Supported Get
     *
     * @return the {@link byte[]} array with the command to send
     */
    static public byte[] getSecurity2CommandsSupportedGet() {
        logger.debug("Creating command message SECURITY_2_COMMANDS_SUPPORTED_GET version 1");

        ByteArrayOutputStream outputData = new ByteArrayOutputStream();
        outputData.write(COMMAND_CLASS_KEY);
        outputData.write(SECURITY_2_COMMANDS_SUPPORTED_GET);

        return outputData.toByteArray();
    }

    /**
     * Processes a received frame with the SECURITY_2_COMMANDS_SUPPORTED_GET command.
     * <p>
     * S2 Commands Supported Get
     *
     * @param payload the {@link byte[]} payload data to process
     * @return a {@link Map} of processed response data
     */
    public static Map<String, Object> handleSecurity2CommandsSupportedGet(byte[] payload) {
        // Create our response map
        Map<String, Object> response = new HashMap<String, Object>();

        // Return the map of processed response data;
        return response;
    }


    /**
     * Creates a new message with the SECURITY_2_COMMANDS_SUPPORTED_REPORT command.
     * <p>
     * S2 Commands Supported Report
     *
     * @param commandClass {@link List<Integer>}
     * @return the {@link byte[]} array with the command to send
     */
    static public byte[] getSecurity2CommandsSupportedReport(List<Integer> commandClass) {
        logger.debug("Creating command message SECURITY_2_COMMANDS_SUPPORTED_REPORT version 1");

        ByteArrayOutputStream outputData = new ByteArrayOutputStream();
        outputData.write(COMMAND_CLASS_KEY);
        outputData.write(SECURITY_2_COMMANDS_SUPPORTED_REPORT);

        // Process 'Command Class'
        for (Integer valCommandClass : commandClass) {
            outputData.write(valCommandClass);
        }

        return outputData.toByteArray();
    }

    /**
     * Processes a received frame with the SECURITY_2_COMMANDS_SUPPORTED_REPORT command.
     * <p>
     * S2 Commands Supported Report
     * <p>
     * The output data {@link Map} has the following properties -:
     *
     * <ul>
     * <li>COMMAND_CLASS {@link List}<{@link Integer}>
     * </ul>
     *
     * @param payload the {@link byte[]} payload data to process
     * @return a {@link Map} of processed response data
     */
    public static Map<String, Object> handleSecurity2CommandsSupportedReport(byte[] payload) {
        // Create our response map
        Map<String, Object> response = new HashMap<String, Object>();

        // We're using variable length fields, so track the offset
        int msgOffset = 2;

        // Process 'Command Class'
        List<Integer> valCommandClass = new ArrayList<Integer>();
        while (msgOffset < payload.length) {
            valCommandClass.add(payload[msgOffset] & 0xFF);
            msgOffset++;
        }
        response.put("COMMAND_CLASS", valCommandClass);

        // Return the map of processed response data;
        return response;
    }


    /**
     * Creates a new message with the SECURITY_2_CAPABILITIES_GET command.
     * <p>
     * S2 Capabilities Get
     *
     * @return the {@link byte[]} array with the command to send
     */
    static public byte[] getSecurity2CapabilitiesGet() {
        logger.debug("Creating command message SECURITY_2_CAPABILITIES_GET version 1");

        ByteArrayOutputStream outputData = new ByteArrayOutputStream();
        outputData.write(COMMAND_CLASS_KEY);
        outputData.write(SECURITY_2_CAPABILITIES_GET);

        return outputData.toByteArray();
    }

    /**
     * Processes a received frame with the SECURITY_2_CAPABILITIES_GET command.
     * <p>
     * S2 Capabilities Get
     *
     * @param payload the {@link byte[]} payload data to process
     * @return a {@link Map} of processed response data
     */
    public static Map<String, Object> handleSecurity2CapabilitiesGet(byte[] payload) {
        // Create our response map
        Map<String, Object> response = new HashMap<String, Object>();

        // Return the map of processed response data;
        return response;
    }


    /**
     * Creates a new message with the SECURITY_2_CAPABILITIES_REPORT command.
     * <p>
     * S2 Capabilities Report
     *
     * @param supportedSpans {@link Integer}
     * @param supportedMpans {@link Integer}
     * @return the {@link byte[]} array with the command to send
     */
    static public byte[] getSecurity2CapabilitiesReport(Integer supportedSpans, Integer supportedMpans) {
        logger.debug("Creating command message SECURITY_2_CAPABILITIES_REPORT version 1");

        ByteArrayOutputStream outputData = new ByteArrayOutputStream();
        outputData.write(COMMAND_CLASS_KEY);
        outputData.write(SECURITY_2_CAPABILITIES_REPORT);

        // Process 'Supported SPANs'
        outputData.write(supportedSpans);

        // Process 'Supported MPANs'
        outputData.write(supportedMpans);

        return outputData.toByteArray();
    }

    /**
     * Processes a received frame with the SECURITY_2_CAPABILITIES_REPORT command.
     * <p>
     * S2 Capabilities Report
     * <p>
     * The output data {@link Map} has the following properties -:
     *
     * <ul>
     * <li>SUPPORTED_SPANS {@link Integer}
     * <li>SUPPORTED_MPANS {@link Integer}
     * </ul>
     *
     * @param payload the {@link byte[]} payload data to process
     * @return a {@link Map} of processed response data
     */
    public static Map<String, Object> handleSecurity2CapabilitiesReport(byte[] payload) {
        // Create our response map
        Map<String, Object> response = new HashMap<String, Object>();

        // Process 'Supported SPANs'
        response.put("SUPPORTED_SPANS", Integer.valueOf(payload[2]));

        // Process 'Supported MPANs'
        response.put("SUPPORTED_MPANS", Integer.valueOf(payload[3]));

        // Return the map of processed response data;
        return response;
    }

}
