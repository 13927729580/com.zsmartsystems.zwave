/**
 * Copyright (c) 2016-2017 by the respective copyright holders.
 *
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Eclipse Public License v1.0
 * which accompanies this distribution, and is available at
 * http://www.eclipse.org/legal/epl-v10.html
 */
package com.zsmartsystems.zwave.commandclass.impl;

import java.io.ByteArrayOutputStream;
import java.io.IOException;
import java.util.HashMap;
import java.util.Map;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

/**
 * Class to implement the Z-Wave command class <b>COMMAND_CLASS_ZIP_GATEWAY</b> version <b>1</b>.<br>
 * <p>
 * Command Class Z/IP Gateway<br>
 *
 * This class provides static methods for processing received messages (message handler) and
 * methods to get a message to send on the Z-Wave network.<br>
 * <p>
 * Note that this code is autogenerated. Manual changes may be overwritten.
 *
 * @author Chris Jackson - Initial contribution of Java code generator
 */
public class CommandClassZipGatewayV1 {
    private static final Logger logger = LoggerFactory.getLogger(CommandClassZipGatewayV1.class);

    /**
     * Integer command class key for COMMAND_CLASS_ZIP_GATEWAY
     */
    public final static int COMMAND_CLASS_KEY = 0x5F;

    /**
     * Gateway Mode Set Command Constant
     */
    public final static int GATEWAY_MODE_SET = 0x01;
    /**
     * Gateway Mode Get Command Constant
     */
    public final static int GATEWAY_MODE_GET = 0x02;
    /**
     * Gateway Mode Report Command Constant
     */
    public final static int GATEWAY_MODE_REPORT = 0x03;
    /**
     * Gateway Peer Set Command Constant
     */
    public final static int GATEWAY_PEER_SET = 0x04;
    /**
     * Gateway Peer Get Command Constant
     */
    public final static int GATEWAY_PEER_GET = 0x05;
    /**
     * Gateway Peer Report Command Constant
     */
    public final static int GATEWAY_PEER_REPORT = 0x06;
    /**
     * Gateway Lock Set Command Constant
     */
    public final static int GATEWAY_LOCK_SET = 0x07;
    /**
     * Unsolicited Destination Set Command Constant
     */
    public final static int UNSOLICITED_DESTINATION_SET = 0x08;
    /**
     * Unsolicited Destination Get Command Constant
     */
    public final static int UNSOLICITED_DESTINATION_GET = 0x09;
    /**
     * Unsolicited Destination Report Command Constant
     */
    public final static int UNSOLICITED_DESTINATION_REPORT = 0x0A;
    /**
     * Application Node Info Set Command Constant
     */
    public final static int COMMAND_APPLICATION_NODE_INFO_SET = 0x0B;
    /**
     * Application Node Info Get Command Constant
     */
    public final static int COMMAND_APPLICATION_NODE_INFO_GET = 0x0C;
    /**
     * Application Node Info Report Command Constant
     */
    public final static int COMMAND_APPLICATION_NODE_INFO_REPORT = 0x0D;

    // Constants for Mode
    private static Map<Integer, String> constantMode = new HashMap<Integer, String>();

    static {
        // Constants for Mode
        constantMode.put(0x01, "STAND_ALONE");
        constantMode.put(0x02, "PORTAL");
    }

    /**
     * Creates a new message with the GATEWAY_MODE_SET command.<br>
     * <p>
     * Gateway Mode Set<br>
     *
     * @param mode {@link String}
     * @return the {@link byte[]} array with the command to send
     */
    static public byte[] getGatewayModeSet(String mode) {
        logger.debug("Creating command message GATEWAY_MODE_SET version 1");

        ByteArrayOutputStream outputData = new ByteArrayOutputStream();
        outputData.write(COMMAND_CLASS_KEY);
        outputData.write(GATEWAY_MODE_SET);

        // Process 'Mode'
        for (Integer entry : constantMode.keySet()) {
            if (constantMode.get(entry).equals(mode)) {
                outputData.write(entry);
                break;
            }
        }

        return outputData.toByteArray();
    }

    /**
     * Processes a received frame with the GATEWAY_MODE_SET command<br>
     * <p>
     * Gateway Mode Set<br>
     * <p>
     * The output data {@link Map} has the following properties<br>
     *
     * <ul>
     * <li>MODE {@link String}
     * </ul>
     *
     * @param payload the {@link byte[]} payload data to process
     * @return a {@link Map} of processed response data
     */
    public static Map<String, Object> handleGatewayModeSet(byte[] payload) {
        // Create our response map
        Map<String, Object> response = new HashMap<String, Object>();

        // Process 'Mode'
        constantMode.get((int) payload[2]);

        // Return the map of processed response data;
        return response;
    }

    /**
     * Creates a new message with the GATEWAY_MODE_GET command.<br>
     * <p>
     * Gateway Mode Get<br>
     *
     * @return the {@link byte[]} array with the command to send
     */
    static public byte[] getGatewayModeGet() {
        logger.debug("Creating command message GATEWAY_MODE_GET version 1");

        ByteArrayOutputStream outputData = new ByteArrayOutputStream();
        outputData.write(COMMAND_CLASS_KEY);
        outputData.write(GATEWAY_MODE_GET);

        return outputData.toByteArray();
    }

    /**
     * Processes a received frame with the GATEWAY_MODE_GET command<br>
     * <p>
     * Gateway Mode Get<br>
     *
     * @param payload the {@link byte[]} payload data to process
     * @return a {@link Map} of processed response data
     */
    public static Map<String, Object> handleGatewayModeGet(byte[] payload) {
        // Create our response map
        Map<String, Object> response = new HashMap<String, Object>();

        // Return the map of processed response data;
        return response;
    }

    /**
     * Creates a new message with the GATEWAY_MODE_REPORT command.<br>
     * <p>
     * Gateway Mode Report<br>
     *
     * @param mode {@link String}
     * @return the {@link byte[]} array with the command to send
     */
    static public byte[] getGatewayModeReport(String mode) {
        logger.debug("Creating command message GATEWAY_MODE_REPORT version 1");

        ByteArrayOutputStream outputData = new ByteArrayOutputStream();
        outputData.write(COMMAND_CLASS_KEY);
        outputData.write(GATEWAY_MODE_REPORT);

        // Process 'Mode'
        for (Integer entry : constantMode.keySet()) {
            if (constantMode.get(entry).equals(mode)) {
                outputData.write(entry);
                break;
            }
        }

        return outputData.toByteArray();
    }

    /**
     * Processes a received frame with the GATEWAY_MODE_REPORT command<br>
     * <p>
     * Gateway Mode Report<br>
     * <p>
     * The output data {@link Map} has the following properties<br>
     *
     * <ul>
     * <li>MODE {@link String}
     * </ul>
     *
     * @param payload the {@link byte[]} payload data to process
     * @return a {@link Map} of processed response data
     */
    public static Map<String, Object> handleGatewayModeReport(byte[] payload) {
        // Create our response map
        Map<String, Object> response = new HashMap<String, Object>();

        // Process 'Mode'
        constantMode.get((int) payload[2]);

        // Return the map of processed response data;
        return response;
    }

    /**
     * Creates a new message with the GATEWAY_PEER_SET command.<br>
     * <p>
     * Gateway Peer Set<br>
     *
     * @param peerProfile {@link Integer}
     * @param ipv6Address {@link byte[]}
     * @param port {@link Integer}
     * @param peerNameLength {@link Integer}
     * @param peerName {@link byte[]}
     * @return the {@link byte[]} array with the command to send
     */
    static public byte[] getGatewayPeerSet(Integer peerProfile, byte[] ipv6Address, Integer port, Integer peerNameLength,
            byte[] peerName) {
        logger.debug("Creating command message GATEWAY_PEER_SET version 1");

        ByteArrayOutputStream outputData = new ByteArrayOutputStream();
        outputData.write(COMMAND_CLASS_KEY);
        outputData.write(GATEWAY_PEER_SET);

        // Process 'Peer Profile'
        outputData.write(peerProfile);

        // Process 'IPv6 Address'
        try {
            outputData.write(ipv6Address);
        } catch (IOException e) {
        }

        // Process 'Port'
        outputData.write((port >> 8) & 0xff);
        outputData.write(port & 0xff);

        // Process 'Properties1'
        outputData.write(peerNameLength & 0x3F);

        // Process 'Peer Name'
        try {
            outputData.write(peerName);
        } catch (IOException e) {
        }

        return outputData.toByteArray();
    }

    /**
     * Processes a received frame with the GATEWAY_PEER_SET command<br>
     * <p>
     * Gateway Peer Set<br>
     * <p>
     * The output data {@link Map} has the following properties<br>
     *
     * <ul>
     * <li>PEER_PROFILE {@link Integer}
     * <li>IPV6_ADDRESS {@link byte[]}
     * <li>PORT {@link Integer}
     * <li>PEER_NAME_LENGTH {@link Integer}
     * <li>PEER_NAME {@link byte[]}
     * </ul>
     *
     * @param payload the {@link byte[]} payload data to process
     * @return a {@link Map} of processed response data
     */
    public static Map<String, Object> handleGatewayPeerSet(byte[] payload) {
        // Create our response map
        Map<String, Object> response = new HashMap<String, Object>();

        // We're using variable length fields, so track the offset
        int msgOffset = 2;

        // Process 'Peer Profile'
        response.put("PEER_PROFILE", Integer.valueOf(payload[msgOffset]));
        msgOffset += 1;

        // Process 'IPv6 Address'
        byte[] valIpv6Address = new byte[16];
        for (int cntIpv6Address = 0; cntIpv6Address < 16; cntIpv6Address++) {
            valIpv6Address[cntIpv6Address] = payload[msgOffset + cntIpv6Address];
        }
        response.put("IPV6_ADDRESS", valIpv6Address);
        msgOffset += 16;

        // Process 'Port'
        response.put("PORT", Integer.valueOf(payload[msgOffset] << 8 + payload[msgOffset + 12]));
        msgOffset += 2;

        // Process 'Properties1'
        response.put("PEER_NAME_LENGTH", Integer.valueOf(payload[msgOffset] & 0x3F));
        msgOffset += 1;

        // Process 'Peer Name'
        int valPeerName = 0;
        int lenPeerName = payload[msgOffset - 1] & 0x3F;
        for (int cntPeerName = 0; cntPeerName < lenPeerName; cntPeerName++) {
            valPeerName = (valPeerName << 8) + payload[msgOffset + cntPeerName];
        }
        response.put("PEER_NAME", valPeerName);
        msgOffset += lenPeerName;

        // Return the map of processed response data;
        return response;
    }

    /**
     * Creates a new message with the GATEWAY_PEER_GET command.<br>
     * <p>
     * Gateway Peer Get<br>
     *
     * @param peerProfile {@link Integer}
     * @return the {@link byte[]} array with the command to send
     */
    static public byte[] getGatewayPeerGet(Integer peerProfile) {
        logger.debug("Creating command message GATEWAY_PEER_GET version 1");

        ByteArrayOutputStream outputData = new ByteArrayOutputStream();
        outputData.write(COMMAND_CLASS_KEY);
        outputData.write(GATEWAY_PEER_GET);

        // Process 'Peer Profile'
        outputData.write(peerProfile);

        return outputData.toByteArray();
    }

    /**
     * Processes a received frame with the GATEWAY_PEER_GET command<br>
     * <p>
     * Gateway Peer Get<br>
     * <p>
     * The output data {@link Map} has the following properties<br>
     *
     * <ul>
     * <li>PEER_PROFILE {@link Integer}
     * </ul>
     *
     * @param payload the {@link byte[]} payload data to process
     * @return a {@link Map} of processed response data
     */
    public static Map<String, Object> handleGatewayPeerGet(byte[] payload) {
        // Create our response map
        Map<String, Object> response = new HashMap<String, Object>();

        // Process 'Peer Profile'
        response.put("PEER_PROFILE", Integer.valueOf(payload[2]));

        // Return the map of processed response data;
        return response;
    }

    /**
     * Creates a new message with the GATEWAY_PEER_REPORT command.<br>
     * <p>
     * Gateway Peer Report<br>
     *
     * @param peerProfile {@link Integer}
     * @param peerCount {@link Integer}
     * @param ipv6Address {@link byte[]}
     * @param port {@link Integer}
     * @param peerNameLength {@link Integer}
     * @param peerName {@link byte[]}
     * @return the {@link byte[]} array with the command to send
     */
    static public byte[] getGatewayPeerReport(Integer peerProfile, Integer peerCount, byte[] ipv6Address, Integer port,
            Integer peerNameLength, byte[] peerName) {
        logger.debug("Creating command message GATEWAY_PEER_REPORT version 1");

        ByteArrayOutputStream outputData = new ByteArrayOutputStream();
        outputData.write(COMMAND_CLASS_KEY);
        outputData.write(GATEWAY_PEER_REPORT);

        // Process 'Peer Profile'
        outputData.write(peerProfile);

        // Process 'Peer Count'
        outputData.write(peerCount);

        // Process 'IPv6 Address'
        try {
            outputData.write(ipv6Address);
        } catch (IOException e) {
        }

        // Process 'Port'
        outputData.write((port >> 8) & 0xff);
        outputData.write(port & 0xff);

        // Process 'Properties1'
        outputData.write(peerNameLength & 0x3F);

        // Process 'Peer Name'
        try {
            outputData.write(peerName);
        } catch (IOException e) {
        }

        return outputData.toByteArray();
    }

    /**
     * Processes a received frame with the GATEWAY_PEER_REPORT command<br>
     * <p>
     * Gateway Peer Report<br>
     * <p>
     * The output data {@link Map} has the following properties<br>
     *
     * <ul>
     * <li>PEER_PROFILE {@link Integer}
     * <li>PEER_COUNT {@link Integer}
     * <li>IPV6_ADDRESS {@link byte[]}
     * <li>PORT {@link Integer}
     * <li>PEER_NAME_LENGTH {@link Integer}
     * <li>PEER_NAME {@link byte[]}
     * </ul>
     *
     * @param payload the {@link byte[]} payload data to process
     * @return a {@link Map} of processed response data
     */
    public static Map<String, Object> handleGatewayPeerReport(byte[] payload) {
        // Create our response map
        Map<String, Object> response = new HashMap<String, Object>();

        // We're using variable length fields, so track the offset
        int msgOffset = 2;

        // Process 'Peer Profile'
        response.put("PEER_PROFILE", Integer.valueOf(payload[msgOffset]));
        msgOffset += 1;

        // Process 'Peer Count'
        response.put("PEER_COUNT", Integer.valueOf(payload[msgOffset]));
        msgOffset += 1;

        // Process 'IPv6 Address'
        byte[] valIpv6Address = new byte[16];
        for (int cntIpv6Address = 0; cntIpv6Address < 16; cntIpv6Address++) {
            valIpv6Address[cntIpv6Address] = payload[msgOffset + cntIpv6Address];
        }
        response.put("IPV6_ADDRESS", valIpv6Address);
        msgOffset += 16;

        // Process 'Port'
        response.put("PORT", Integer.valueOf(payload[msgOffset] << 8 + payload[msgOffset + 12]));
        msgOffset += 2;

        // Process 'Properties1'
        response.put("PEER_NAME_LENGTH", Integer.valueOf(payload[msgOffset] & 0x3F));
        msgOffset += 1;

        // Process 'Peer Name'
        int valPeerName = 0;
        int lenPeerName = payload[msgOffset - 1] & 0x3F;
        for (int cntPeerName = 0; cntPeerName < lenPeerName; cntPeerName++) {
            valPeerName = (valPeerName << 8) + payload[msgOffset + cntPeerName];
        }
        response.put("PEER_NAME", valPeerName);
        msgOffset += lenPeerName;

        // Return the map of processed response data;
        return response;
    }

    /**
     * Creates a new message with the GATEWAY_LOCK_SET command.<br>
     * <p>
     * Gateway Lock Set<br>
     *
     * @param lock {@link Boolean}
     * @param show {@link Boolean}
     * @return the {@link byte[]} array with the command to send
     */
    static public byte[] getGatewayLockSet(Boolean lock, Boolean show) {
        logger.debug("Creating command message GATEWAY_LOCK_SET version 1");

        ByteArrayOutputStream outputData = new ByteArrayOutputStream();
        outputData.write(COMMAND_CLASS_KEY);
        outputData.write(GATEWAY_LOCK_SET);

        // Process 'Properties1'
        int valProperties1 = 0;
        valProperties1 |= lock ? 0x01 : 0;
        valProperties1 |= show ? 0x02 : 0;
        outputData.write(valProperties1);

        return outputData.toByteArray();
    }

    /**
     * Processes a received frame with the GATEWAY_LOCK_SET command<br>
     * <p>
     * Gateway Lock Set<br>
     * <p>
     * The output data {@link Map} has the following properties<br>
     *
     * <ul>
     * <li>LOCK {@link Boolean}
     * <li>SHOW {@link Boolean}
     * </ul>
     *
     * @param payload the {@link byte[]} payload data to process
     * @return a {@link Map} of processed response data
     */
    public static Map<String, Object> handleGatewayLockSet(byte[] payload) {
        // Create our response map
        Map<String, Object> response = new HashMap<String, Object>();

        // Process 'Properties1'
        response.put("LOCK", Boolean.valueOf((payload[2] & 0x01) != 0));
        response.put("SHOW", Boolean.valueOf((payload[2] & 0x02) != 0));

        // Return the map of processed response data;
        return response;
    }

    /**
     * Creates a new message with the UNSOLICITED_DESTINATION_SET command.<br>
     * <p>
     * Unsolicited Destination Set<br>
     *
     * @param unsolicitedIpv6Destination {@link byte[]}
     * @param unsolicitedDestinationPort {@link Integer}
     * @return the {@link byte[]} array with the command to send
     */
    static public byte[] getUnsolicitedDestinationSet(byte[] unsolicitedIpv6Destination,
            Integer unsolicitedDestinationPort) {
        logger.debug("Creating command message UNSOLICITED_DESTINATION_SET version 1");

        ByteArrayOutputStream outputData = new ByteArrayOutputStream();
        outputData.write(COMMAND_CLASS_KEY);
        outputData.write(UNSOLICITED_DESTINATION_SET);

        // Process 'Unsolicited IPv6 Destination'
        try {
            outputData.write(unsolicitedIpv6Destination);
        } catch (IOException e) {
        }

        // Process 'Unsolicited Destination Port'
        outputData.write((unsolicitedDestinationPort >> 8) & 0xff);
        outputData.write(unsolicitedDestinationPort & 0xff);

        return outputData.toByteArray();
    }

    /**
     * Processes a received frame with the UNSOLICITED_DESTINATION_SET command<br>
     * <p>
     * Unsolicited Destination Set<br>
     * <p>
     * The output data {@link Map} has the following properties<br>
     *
     * <ul>
     * <li>UNSOLICITED_IPV6_DESTINATION {@link byte[]}
     * <li>UNSOLICITED_DESTINATION_PORT {@link Integer}
     * </ul>
     *
     * @param payload the {@link byte[]} payload data to process
     * @return a {@link Map} of processed response data
     */
    public static Map<String, Object> handleUnsolicitedDestinationSet(byte[] payload) {
        // Create our response map
        Map<String, Object> response = new HashMap<String, Object>();

        // Process 'Unsolicited IPv6 Destination'
        byte[] valUnsolicitedIpv6Destination = new byte[16];
        for (int cntUnsolicitedIpv6Destination = 0; cntUnsolicitedIpv6Destination < 16; cntUnsolicitedIpv6Destination++) {
            valUnsolicitedIpv6Destination[cntUnsolicitedIpv6Destination] = payload[2 + cntUnsolicitedIpv6Destination];
        }
        response.put("UNSOLICITED_IPV6_DESTINATION", valUnsolicitedIpv6Destination);

        // Process 'Unsolicited Destination Port'
        response.put("UNSOLICITED_DESTINATION_PORT", Integer.valueOf(payload[18] << 8 + payload[19]));

        // Return the map of processed response data;
        return response;
    }

    /**
     * Creates a new message with the UNSOLICITED_DESTINATION_GET command.<br>
     * <p>
     * Unsolicited Destination Get<br>
     *
     * @return the {@link byte[]} array with the command to send
     */
    static public byte[] getUnsolicitedDestinationGet() {
        logger.debug("Creating command message UNSOLICITED_DESTINATION_GET version 1");

        ByteArrayOutputStream outputData = new ByteArrayOutputStream();
        outputData.write(COMMAND_CLASS_KEY);
        outputData.write(UNSOLICITED_DESTINATION_GET);

        return outputData.toByteArray();
    }

    /**
     * Processes a received frame with the UNSOLICITED_DESTINATION_GET command<br>
     * <p>
     * Unsolicited Destination Get<br>
     *
     * @param payload the {@link byte[]} payload data to process
     * @return a {@link Map} of processed response data
     */
    public static Map<String, Object> handleUnsolicitedDestinationGet(byte[] payload) {
        // Create our response map
        Map<String, Object> response = new HashMap<String, Object>();

        // Return the map of processed response data;
        return response;
    }

    /**
     * Creates a new message with the UNSOLICITED_DESTINATION_REPORT command.<br>
     * <p>
     * Unsolicited Destination Report<br>
     *
     * @param unsolicitedIpv6Destination {@link byte[]}
     * @param unsolicitedDestinationPort {@link Integer}
     * @return the {@link byte[]} array with the command to send
     */
    static public byte[] getUnsolicitedDestinationReport(byte[] unsolicitedIpv6Destination,
            Integer unsolicitedDestinationPort) {
        logger.debug("Creating command message UNSOLICITED_DESTINATION_REPORT version 1");

        ByteArrayOutputStream outputData = new ByteArrayOutputStream();
        outputData.write(COMMAND_CLASS_KEY);
        outputData.write(UNSOLICITED_DESTINATION_REPORT);

        // Process 'Unsolicited IPv6 Destination'
        try {
            outputData.write(unsolicitedIpv6Destination);
        } catch (IOException e) {
        }

        // Process 'Unsolicited Destination Port'
        outputData.write((unsolicitedDestinationPort >> 8) & 0xff);
        outputData.write(unsolicitedDestinationPort & 0xff);

        return outputData.toByteArray();
    }

    /**
     * Processes a received frame with the UNSOLICITED_DESTINATION_REPORT command<br>
     * <p>
     * Unsolicited Destination Report<br>
     * <p>
     * The output data {@link Map} has the following properties<br>
     *
     * <ul>
     * <li>UNSOLICITED_IPV6_DESTINATION {@link byte[]}
     * <li>UNSOLICITED_DESTINATION_PORT {@link Integer}
     * </ul>
     *
     * @param payload the {@link byte[]} payload data to process
     * @return a {@link Map} of processed response data
     */
    public static Map<String, Object> handleUnsolicitedDestinationReport(byte[] payload) {
        // Create our response map
        Map<String, Object> response = new HashMap<String, Object>();

        // Process 'Unsolicited IPv6 Destination'
        byte[] valUnsolicitedIpv6Destination = new byte[16];
        for (int cntUnsolicitedIpv6Destination = 0; cntUnsolicitedIpv6Destination < 16; cntUnsolicitedIpv6Destination++) {
            valUnsolicitedIpv6Destination[cntUnsolicitedIpv6Destination] = payload[2 + cntUnsolicitedIpv6Destination];
        }
        response.put("UNSOLICITED_IPV6_DESTINATION", valUnsolicitedIpv6Destination);

        // Process 'Unsolicited Destination Port'
        response.put("UNSOLICITED_DESTINATION_PORT", Integer.valueOf(payload[18] << 8 + payload[19]));

        // Return the map of processed response data;
        return response;
    }

    /**
     * Creates a new message with the COMMAND_APPLICATION_NODE_INFO_SET command.<br>
     * <p>
     * Application Node Info Set<br>
     *
     * @param nonSecureCommandClass {@link byte[]}
     * @param securityScheme0CommandClass {@link byte[]}
     * @return the {@link byte[]} array with the command to send
     */
    static public byte[] getCommandApplicationNodeInfoSet(byte[] nonSecureCommandClass,
            byte[] securityScheme0CommandClass) {
        logger.debug("Creating command message COMMAND_APPLICATION_NODE_INFO_SET version 1");

        ByteArrayOutputStream outputData = new ByteArrayOutputStream();
        outputData.write(COMMAND_CLASS_KEY);
        outputData.write(COMMAND_APPLICATION_NODE_INFO_SET);

        // Process 'Non-Secure Command Class'
        try {
            outputData.write(nonSecureCommandClass);
        } catch (IOException e) {
        }

        // Process 'Security Scheme 0 MARK'
        outputData.write(0xF1);

        // Process 'Security Scheme 0 Command Class'
        try {
            outputData.write(securityScheme0CommandClass);
        } catch (IOException e) {
        }

        return outputData.toByteArray();
    }

    /**
     * Processes a received frame with the COMMAND_APPLICATION_NODE_INFO_SET command<br>
     * <p>
     * Application Node Info Set<br>
     * <p>
     * The output data {@link Map} has the following properties<br>
     *
     * <ul>
     * <li>NON_SECURE_COMMAND_CLASS {@link byte[]}
     * <li>SECURITY_SCHEME_0_COMMAND_CLASS {@link byte[]}
     * </ul>
     *
     * @param payload the {@link byte[]} payload data to process
     * @return a {@link Map} of processed response data
     */
    public static Map<String, Object> handleCommandApplicationNodeInfoSet(byte[] payload) {
        // Create our response map
        Map<String, Object> response = new HashMap<String, Object>();

        // We're using variable length fields, so track the offset
        int msgOffset = 2;

        // Process 'Non-Secure Command Class'
        ByteArrayOutputStream valNonSecureCommandClass = new ByteArrayOutputStream();
        while (msgOffset < payload.length) {
            // Detect the marker
            if (((payload[msgOffset] & 0xFF) == 0xF1) && ((payload[msgOffset + 1] & 0xFF) == 0x00)) {
                break;
            }
            valNonSecureCommandClass.write(payload[msgOffset]);
            msgOffset++;
        }
        response.put("NON_SECURE_COMMAND_CLASS", valNonSecureCommandClass);

        // Process 'Security Scheme 0 MARK'
        // Adjust position to account for the marker
        msgOffset += 2;

        // Process 'Security Scheme 0 Command Class'
        ByteArrayOutputStream valSecurityScheme0CommandClass = new ByteArrayOutputStream();
        while (msgOffset < payload.length) {
            valSecurityScheme0CommandClass.write(payload[msgOffset]);
            msgOffset++;
        }
        response.put("SECURITY_SCHEME_0_COMMAND_CLASS", valSecurityScheme0CommandClass);

        // Return the map of processed response data;
        return response;
    }

    /**
     * Creates a new message with the COMMAND_APPLICATION_NODE_INFO_GET command.<br>
     * <p>
     * Application Node Info Get<br>
     *
     * @return the {@link byte[]} array with the command to send
     */
    static public byte[] getCommandApplicationNodeInfoGet() {
        logger.debug("Creating command message COMMAND_APPLICATION_NODE_INFO_GET version 1");

        ByteArrayOutputStream outputData = new ByteArrayOutputStream();
        outputData.write(COMMAND_CLASS_KEY);
        outputData.write(COMMAND_APPLICATION_NODE_INFO_GET);

        return outputData.toByteArray();
    }

    /**
     * Processes a received frame with the COMMAND_APPLICATION_NODE_INFO_GET command<br>
     * <p>
     * Application Node Info Get<br>
     *
     * @param payload the {@link byte[]} payload data to process
     * @return a {@link Map} of processed response data
     */
    public static Map<String, Object> handleCommandApplicationNodeInfoGet(byte[] payload) {
        // Create our response map
        Map<String, Object> response = new HashMap<String, Object>();

        // Return the map of processed response data;
        return response;
    }

    /**
     * Creates a new message with the COMMAND_APPLICATION_NODE_INFO_REPORT command.<br>
     * <p>
     * Application Node Info Report<br>
     *
     * @param nonSecureCommandClass {@link byte[]}
     * @param securityScheme0CommandClass {@link byte[]}
     * @return the {@link byte[]} array with the command to send
     */
    static public byte[] getCommandApplicationNodeInfoReport(byte[] nonSecureCommandClass,
            byte[] securityScheme0CommandClass) {
        logger.debug("Creating command message COMMAND_APPLICATION_NODE_INFO_REPORT version 1");

        ByteArrayOutputStream outputData = new ByteArrayOutputStream();
        outputData.write(COMMAND_CLASS_KEY);
        outputData.write(COMMAND_APPLICATION_NODE_INFO_REPORT);

        // Process 'Non-Secure Command Class'
        try {
            outputData.write(nonSecureCommandClass);
        } catch (IOException e) {
        }

        // Process 'Security Scheme 0 MARK'
        outputData.write(0xF1);

        // Process 'Security Scheme 0 Command Class'
        try {
            outputData.write(securityScheme0CommandClass);
        } catch (IOException e) {
        }

        return outputData.toByteArray();
    }

    /**
     * Processes a received frame with the COMMAND_APPLICATION_NODE_INFO_REPORT command<br>
     * <p>
     * Application Node Info Report<br>
     * <p>
     * The output data {@link Map} has the following properties<br>
     *
     * <ul>
     * <li>NON_SECURE_COMMAND_CLASS {@link byte[]}
     * <li>SECURITY_SCHEME_0_COMMAND_CLASS {@link byte[]}
     * </ul>
     *
     * @param payload the {@link byte[]} payload data to process
     * @return a {@link Map} of processed response data
     */
    public static Map<String, Object> handleCommandApplicationNodeInfoReport(byte[] payload) {
        // Create our response map
        Map<String, Object> response = new HashMap<String, Object>();

        // We're using variable length fields, so track the offset
        int msgOffset = 2;

        // Process 'Non-Secure Command Class'
        ByteArrayOutputStream valNonSecureCommandClass = new ByteArrayOutputStream();
        while (msgOffset < payload.length) {
            // Detect the marker
            if (((payload[msgOffset] & 0xFF) == 0xF1) && ((payload[msgOffset + 1] & 0xFF) == 0x00)) {
                break;
            }
            valNonSecureCommandClass.write(payload[msgOffset]);
            msgOffset++;
        }
        response.put("NON_SECURE_COMMAND_CLASS", valNonSecureCommandClass);

        // Process 'Security Scheme 0 MARK'
        // Adjust position to account for the marker
        msgOffset += 2;

        // Process 'Security Scheme 0 Command Class'
        ByteArrayOutputStream valSecurityScheme0CommandClass = new ByteArrayOutputStream();
        while (msgOffset < payload.length) {
            valSecurityScheme0CommandClass.write(payload[msgOffset]);
            msgOffset++;
        }
        response.put("SECURITY_SCHEME_0_COMMAND_CLASS", valSecurityScheme0CommandClass);

        // Return the map of processed response data;
        return response;
    }

}
