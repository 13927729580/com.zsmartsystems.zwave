/**
 * Copyright (c) 2016-2017 by the respective copyright holders.
 *
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Eclipse Public License v1.0
 * which accompanies this distribution, and is available at
 * http://www.eclipse.org/legal/epl-v10.html
 */
package com.zsmartsystems.zwave.commandclass.impl;

import java.io.ByteArrayOutputStream;
import java.util.HashMap;
import java.util.Map;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

/**
 * Class to implement the Z-Wave command class <b>ZWAVE_CMD_CLASS</b> version <b>1</b>.
 * <p>
 * Z-Wave protocol Command Class
 * <p>
 * This class provides static methods for processing received messages (message handler) and
 * methods to get a message to send on the Z-Wave network.
 * <p>
 * Command class key is 0x01.
 * <p>
 * Note that this code is autogenerated. Manual changes may be overwritten.
 *
 * @author Chris Jackson - Initial contribution of Java code generator
 */
public class ZwaveCmdClassV1 {
    private static final Logger logger = LoggerFactory.getLogger(ZwaveCmdClassV1.class);

    /**
     * Integer command class key for ZWAVE_CMD_CLASS
     */
    public final static int COMMAND_CLASS_KEY = 0x01;

    /**
     * NOP Command Constant
     */
    public final static int ZWAVE_CMD_NOP = 0x00;
    /**
     * Node Info Command Constant
     * SDS10264-2
     */
    public final static int NODE_INFO = 0x01;
    /**
     * Request Node Info Command Constant
     * SDS10264-2
     */
    public final static int REQUEST_NODE_INFO = 0x02;
    /**
     * Assign Id Command Constant
     * SDS10264-2
     */
    public final static int ASSIGN_ID = 0x03;
    /**
     * Find Nodes In Range Command Constant
     * SDS10264-2
     */
    public final static int FIND_NODES_IN_RANGE = 0x04;
    /**
     * Get Nodes In Range Command Constant
     * SDS10264-2
     */
    public final static int GET_NODES_IN_RANGE = 0x05;
    /**
     * Node Range Info Command Constant
     * SDS10264-2
     */
    public final static int NODE_RANGE_INFO = 0x06;
    /**
     * Command Complete Command Constant
     * SDS10264-2
     */
    public final static int COMMAND_COMPLETE = 0x07;
    /**
     * Transfer Presentation Command Constant
     * SDS10264-2
     */
    public final static int TRANSFER_PRESENTATION = 0x08;
    /**
     * Transfer Node Info Command Constant
     * SDS10264-2
     */
    public final static int TRANSFER_NODE_INFO = 0x09;
    /**
     * Transfer Range Info Command Constant
     * SDS10264-2
     */
    public final static int TRANSFER_RANGE_INFO = 0x0A;
    /**
     * Transfer End Command Constant
     * SDS10264-2
     */
    public final static int TRANSFER_END = 0x0B;
    /**
     * Assign Return Route Command Constant
     * SDS10264-2
     */
    public final static int ASSIGN_RETURN_ROUTE = 0x0C;
    /**
     * New Node Registered Command Constant
     * SDS10264-2
     */
    public final static int NEW_NODE_REGISTERED = 0x0D;
    /**
     * New Range Registered Command Constant
     * SDS10264-2
     */
    public final static int NEW_RANGE_REGISTERED = 0x0E;
    /**
     * Transfer New Primary Complete Command Constant
     * SDS10264-2
     */
    public final static int TRANSFER_NEW_PRIMARY_COMPLETE = 0x0F;
    /**
     * Automatic Controller Update Start Command Constant
     */
    public final static int CMD_AUTOMATIC_CONTROLLER_UPDATE_START = 0x10;
    /**
     * SUC Node ID Command Constant
     */
    public final static int CMD_SUC_NODE_ID = 0x11;
    /**
     * Set SUC Command Constant
     */
    public final static int CMD_SET_SUC = 0x12;
    /**
     * Set SUC ACK Command Constant
     */
    public final static int CMD_SET_SUC_ACK = 0x13;
    /**
     * Assign SUC Return Route Command Constant
     */
    public final static int CMD_ASSIGN_SUC_RETURN_ROUTE = 0x14;
    /**
     * Static Route Request Command Constant
     */
    public final static int CMD_STATIC_ROUTE_REQUEST = 0x15;
    /**
     * Lost Command Constant
     * SDS10264-2
     */
    public final static int LOST = 0x16;
    /**
     * Accept Lost Command Constant
     * SDS10264-2
     */
    public final static int ACCEPT_LOST = 0x17;
    /**
     * NOP Power Command Constant
     */
    public final static int CMD_NOP_POWER = 0x18;
    /**
     * Reserve Node ID Command Constant
     */
    public final static int ZWAVE_CMD_RESERVE_NODE_IDS = 0x19;
    /**
     * Reserved ID Command Constant
     */
    public final static int CMD_RESERVED_IDS = 0x1A;
    /**
     * Cmd Nodes Exist Command Constant
     */
    public final static int CMD_NODES_EXIST = 0x1F;
    /**
     * Cmd Nodes Exist Reply Command Constant
     */
    public final static int CMD_NODES_EXIST_REPLY = 0x20;
    /**
     * Cmd Set Nwi Mode Command Constant
     */
    public final static int CMD_SET_NWI_MODE = 0x22;
    /**
     * Exclude Request Command Constant
     * INS13044
     */
    public final static int EXCLUDE_REQUEST = 0x23;
    /**
     * Assign Return Route Priority Command Constant
     */
    public final static int ASSIGN_RETURN_ROUTE_PRIORITY = 0x24;
    /**
     * Assign SUC Return Route Priority Command Constant
     */
    public final static int ASSIGN_SUC_RETURN_ROUTE_PRIORITY = 0x25;

    /**
     * Map holding constants for NodeInfoMaxBaudRate
     */
    private static Map<Integer, String> constantNodeInfoMaxBaudRate = new HashMap<Integer, String>();

    /**
     * Map holding constants for NodeInfoCommandClasses
     */
    private static Map<Integer, String> constantNodeInfoCommandClasses = new HashMap<Integer, String>();

    /**
     * Map holding constants for NodeInfoCapability
     */
    private static Map<Integer, String> constantNodeInfoCapability = new HashMap<Integer, String>();

    /**
     * Map holding constants for NodeInfoSecurity
     */
    private static Map<Integer, String> constantNodeInfoSecurity = new HashMap<Integer, String>();

    /**
     * Map holding constants for NodeInfoBasicDeviceClass
     */
    private static Map<Integer, String> constantNodeInfoBasicDeviceClass = new HashMap<Integer, String>();

    /**
     * Map holding constants for NodeInfoProtocolVersion
     */
    private static Map<Integer, String> constantNodeInfoProtocolVersion = new HashMap<Integer, String>();

    /**
     * Map holding constants for NodeInfoSpeedExtension
     */
    private static Map<Integer, String> constantNodeInfoSpeedExtension = new HashMap<Integer, String>();

    /**
     * Map holding constants for NodeInfoGenericDeviceClass
     */
    private static Map<Integer, String> constantNodeInfoGenericDeviceClass = new HashMap<Integer, String>();

    static {
        // Constants for NodeInfoMaxBaudRate
        constantNodeInfoMaxBaudRate.put(0x00, "9_6_KBPS");
        constantNodeInfoMaxBaudRate.put(0x01, "40_KBPS");

        // Constants for NodeInfoCommandClasses
        constantNodeInfoCommandClasses.put(0x00, "COMMAND_CLASS_NO_OPERATION");
        constantNodeInfoCommandClasses.put(0x01, "ZWAVE_CMD_CLASS");
        constantNodeInfoCommandClasses.put(0x02, "COMMAND_CLASS_ZENSOR_NET");
        constantNodeInfoCommandClasses.put(0x22, "COMMAND_CLASS_APPLICATION_STATUS");
        constantNodeInfoCommandClasses.put(0x23, "COMMAND_CLASS_ZIP");
        constantNodeInfoCommandClasses.put(0x20, "COMMAND_CLASS_BASIC");
        constantNodeInfoCommandClasses.put(0x21, "COMMAND_CLASS_CONTROLLER_REPLICATION");
        constantNodeInfoCommandClasses.put(0x26, "COMMAND_CLASS_SWITCH_MULTILEVEL");
        constantNodeInfoCommandClasses.put(0x27, "COMMAND_CLASS_SWITCH_ALL");
        constantNodeInfoCommandClasses.put(0x24, "COMMAND_CLASS_SECURITY_PANEL_MODE");
        constantNodeInfoCommandClasses.put(0x25, "COMMAND_CLASS_SWITCH_BINARY");
        constantNodeInfoCommandClasses.put(0x2A, "COMMAND_CLASS_CHIMNEY_FAN");
        constantNodeInfoCommandClasses.put(0x2B, "COMMAND_CLASS_SCENE_ACTIVATION");
        constantNodeInfoCommandClasses.put(0x28, "COMMAND_CLASS_SWITCH_TOGGLE_BINARY");
        constantNodeInfoCommandClasses.put(0x29, "COMMAND_CLASS_SWITCH_TOGGLE_MULTILEVEL");
        constantNodeInfoCommandClasses.put(0x2E, "COMMAND_CLASS_SECURITY_PANEL_ZONE");
        constantNodeInfoCommandClasses.put(0x2F, "COMMAND_CLASS_SECURITY_PANEL_ZONE_SENSOR");
        constantNodeInfoCommandClasses.put(0x2C, "COMMAND_CLASS_SCENE_ACTUATOR_CONF");
        constantNodeInfoCommandClasses.put(0x2D, "COMMAND_CLASS_SCENE_CONTROLLER_CONF");
        constantNodeInfoCommandClasses.put(0x33, "COMMAND_CLASS_SWITCH_COLOR");
        constantNodeInfoCommandClasses.put(0x32, "COMMAND_CLASS_METER");
        constantNodeInfoCommandClasses.put(0x31, "COMMAND_CLASS_SENSOR_MULTILEVEL");
        constantNodeInfoCommandClasses.put(0x30, "COMMAND_CLASS_SENSOR_BINARY");
        constantNodeInfoCommandClasses.put(0x37, "COMMAND_CLASS_HRV_STATUS");
        constantNodeInfoCommandClasses.put(0x36, "COMMAND_CLASS_BASIC_TARIFF_INFO");
        constantNodeInfoCommandClasses.put(0x35, "COMMAND_CLASS_METER_PULSE");
        constantNodeInfoCommandClasses.put(0x34, "COMMAND_CLASS_NETWORK_MANAGEMENT_INCLUSION");
        constantNodeInfoCommandClasses.put(0x3B, "COMMAND_CLASS_DCP_MONITOR");
        constantNodeInfoCommandClasses.put(0x3A, "COMMAND_CLASS_DCP_CONFIG");
        constantNodeInfoCommandClasses.put(0x39, "COMMAND_CLASS_HRV_CONTROL");
        constantNodeInfoCommandClasses.put(0x38, "COMMAND_CLASS_THERMOSTAT_HEATING");
        constantNodeInfoCommandClasses.put(0x3F, "COMMAND_CLASS_PREPAYMENT");
        constantNodeInfoCommandClasses.put(0x3E, "COMMAND_CLASS_METER_TBL_PUSH");
        constantNodeInfoCommandClasses.put(0x3D, "COMMAND_CLASS_METER_TBL_MONITOR");
        constantNodeInfoCommandClasses.put(0x3C, "COMMAND_CLASS_METER_TBL_CONFIG");
        constantNodeInfoCommandClasses.put(0x44, "COMMAND_CLASS_THERMOSTAT_FAN_MODE");
        constantNodeInfoCommandClasses.put(0x45, "COMMAND_CLASS_THERMOSTAT_FAN_STATE");
        constantNodeInfoCommandClasses.put(0x46, "COMMAND_CLASS_CLIMATE_CONTROL_SCHEDULE");
        constantNodeInfoCommandClasses.put(0x47, "COMMAND_CLASS_THERMOSTAT_SETBACK");
        constantNodeInfoCommandClasses.put(0x40, "COMMAND_CLASS_THERMOSTAT_MODE");
        constantNodeInfoCommandClasses.put(0x41, "COMMAND_CLASS_PREPAYMENT_ENCAPSULATION");
        constantNodeInfoCommandClasses.put(0x42, "COMMAND_CLASS_THERMOSTAT_OPERATING_STATE");
        constantNodeInfoCommandClasses.put(0x43, "COMMAND_CLASS_THERMOSTAT_SETPOINT");
        constantNodeInfoCommandClasses.put(0x4C, "COMMAND_CLASS_DOOR_LOCK_LOGGING");
        constantNodeInfoCommandClasses.put(0x4D, "COMMAND_CLASS_NETWORK_MANAGEMENT_BASIC");
        constantNodeInfoCommandClasses.put(0x4E, "COMMAND_CLASS_SCHEDULE_ENTRY_LOCK");
        constantNodeInfoCommandClasses.put(0x4F, "COMMAND_CLASS_ZIP_6LOWPAN");
        constantNodeInfoCommandClasses.put(0x48, "COMMAND_CLASS_RATE_TBL_CONFIG");
        constantNodeInfoCommandClasses.put(0x49, "COMMAND_CLASS_RATE_TBL_MONITOR");
        constantNodeInfoCommandClasses.put(0x4A, "COMMAND_CLASS_TARIFF_CONFIG");
        constantNodeInfoCommandClasses.put(0x4B, "COMMAND_CLASS_TARIFF_TBL_MONITOR");
        constantNodeInfoCommandClasses.put(0x55, "COMMAND_CLASS_TRANSPORT_SERVICE");
        constantNodeInfoCommandClasses.put(0x54, "COMMAND_CLASS_NETWORK_MANAGEMENT_PRIMARY");
        constantNodeInfoCommandClasses.put(0x57, "COMMAND_CLASS_APPLICATION_CAPABILITY");
        constantNodeInfoCommandClasses.put(0x56, "COMMAND_CLASS_CRC_16_ENCAP");
        constantNodeInfoCommandClasses.put(0x51, "COMMAND_CLASS_MTP_WINDOW_COVERING");
        constantNodeInfoCommandClasses.put(0x50, "COMMAND_CLASS_BASIC_WINDOW_COVERING");
        constantNodeInfoCommandClasses.put(0x53, "COMMAND_CLASS_SCHEDULE");
        constantNodeInfoCommandClasses.put(0x52, "COMMAND_CLASS_NETWORK_MANAGEMENT_PROXY");
        constantNodeInfoCommandClasses.put(0x5D, "COMMAND_CLASS_ANTITHEFT");
        constantNodeInfoCommandClasses.put(0x5C, "COMMAND_CLASS_IP_ASSOCIATION");
        constantNodeInfoCommandClasses.put(0x5F, "COMMAND_CLASS_ZIP_GATEWAY");
        constantNodeInfoCommandClasses.put(0x5E, "COMMAND_CLASS_ZWAVEPLUS_INFO");
        constantNodeInfoCommandClasses.put(0x59, "COMMAND_CLASS_ASSOCIATION_GRP_INFO");
        constantNodeInfoCommandClasses.put(0x58, "COMMAND_CLASS_ZIP_ND");
        constantNodeInfoCommandClasses.put(0x5B, "COMMAND_CLASS_CENTRAL_SCENE");
        constantNodeInfoCommandClasses.put(0x5A, "COMMAND_CLASS_DEVICE_RESET_LOCALLY");
        constantNodeInfoCommandClasses.put(0x66, "COMMAND_CLASS_BARRIER_OPERATOR");
        constantNodeInfoCommandClasses.put(0x67, "COMMAND_CLASS_NETWORK_MANAGEMENT_INSTALLATION_MAINTENANCE");
        constantNodeInfoCommandClasses.put(0x64, "COMMAND_CLASS_HUMIDITY_CONTROL_SETPOINT");
        constantNodeInfoCommandClasses.put(0x65, "COMMAND_CLASS_DMX");
        constantNodeInfoCommandClasses.put(0x62, "COMMAND_CLASS_DOOR_LOCK");
        constantNodeInfoCommandClasses.put(0x63, "COMMAND_CLASS_USER_CODE");
        constantNodeInfoCommandClasses.put(0x60, "COMMAND_CLASS_MULTI_CHANNEL");
        constantNodeInfoCommandClasses.put(0x61, "COMMAND_CLASS_ZIP_PORTAL");
        constantNodeInfoCommandClasses.put(0x6E, "COMMAND_CLASS_HUMIDITY_CONTROL_OPERATING_STATE");
        constantNodeInfoCommandClasses.put(0x6F, "COMMAND_CLASS_ENTRY_CONTROL");
        constantNodeInfoCommandClasses.put(0x6C, "COMMAND_CLASS_SUPERVISION");
        constantNodeInfoCommandClasses.put(0x6D, "COMMAND_CLASS_HUMIDITY_CONTROL_MODE");
        constantNodeInfoCommandClasses.put(0x6A, "COMMAND_CLASS_WINDOW_COVERING");
        constantNodeInfoCommandClasses.put(0x6B, "COMMAND_CLASS_IRRIGATION");
        constantNodeInfoCommandClasses.put(0x68, "COMMAND_CLASS_ZIP_NAMING");
        constantNodeInfoCommandClasses.put(0x69, "COMMAND_CLASS_MAILBOX");
        constantNodeInfoCommandClasses.put(0x77, "COMMAND_CLASS_NODE_NAMING");
        constantNodeInfoCommandClasses.put(0x76, "COMMAND_CLASS_LOCK");
        constantNodeInfoCommandClasses.put(0x75, "COMMAND_CLASS_PROTECTION");
        constantNodeInfoCommandClasses.put(0x74, "COMMAND_CLASS_INCLUSION_CONTROLLER");
        constantNodeInfoCommandClasses.put(0x73, "COMMAND_CLASS_POWERLEVEL");
        constantNodeInfoCommandClasses.put(0x72, "COMMAND_CLASS_MANUFACTURER_SPECIFIC");
        constantNodeInfoCommandClasses.put(0x71, "COMMAND_CLASS_ALARM");
        constantNodeInfoCommandClasses.put(0x70, "COMMAND_CLASS_CONFIGURATION");
        constantNodeInfoCommandClasses.put(0x7D, "COMMAND_CLASS_REMOTE_ASSOCIATION");
        constantNodeInfoCommandClasses.put(0x7C, "COMMAND_CLASS_REMOTE_ASSOCIATION_ACTIVATE");
        constantNodeInfoCommandClasses.put(0x7B, "COMMAND_CLASS_GROUPING_NAME");
        constantNodeInfoCommandClasses.put(0x7A, "COMMAND_CLASS_FIRMWARE_UPDATE_MD");
        constantNodeInfoCommandClasses.put(0x89, "COMMAND_CLASS_LANGUAGE");
        constantNodeInfoCommandClasses.put(0x88, "COMMAND_CLASS_PROPRIETARY");
        constantNodeInfoCommandClasses.put(0x8B, "COMMAND_CLASS_TIME_PARAMETERS");
        constantNodeInfoCommandClasses.put(0x8A, "COMMAND_CLASS_TIME");
        constantNodeInfoCommandClasses.put(0x8C, "COMMAND_CLASS_GEOGRAPHIC_LOCATION");
        constantNodeInfoCommandClasses.put(0x8F, "COMMAND_CLASS_MULTI_CMD");
        constantNodeInfoCommandClasses.put(0x8E, "COMMAND_CLASS_MULTI_CHANNEL_ASSOCIATION");
        constantNodeInfoCommandClasses.put(0x81, "COMMAND_CLASS_CLOCK");
        constantNodeInfoCommandClasses.put(0x80, "COMMAND_CLASS_BATTERY");
        constantNodeInfoCommandClasses.put(0x82, "COMMAND_CLASS_HAIL");
        constantNodeInfoCommandClasses.put(0x85, "COMMAND_CLASS_ASSOCIATION");
        constantNodeInfoCommandClasses.put(0x84, "COMMAND_CLASS_WAKE_UP");
        constantNodeInfoCommandClasses.put(0x87, "COMMAND_CLASS_INDICATOR");
        constantNodeInfoCommandClasses.put(0x86, "COMMAND_CLASS_VERSION");
        constantNodeInfoCommandClasses.put(0x98, "COMMAND_CLASS_SECURITY");
        constantNodeInfoCommandClasses.put(0x99, "COMMAND_CLASS_AV_TAGGING_MD");
        constantNodeInfoCommandClasses.put(0x9A, "COMMAND_CLASS_IP_CONFIGURATION");
        constantNodeInfoCommandClasses.put(0x9B, "COMMAND_CLASS_ASSOCIATION_COMMAND_CONFIGURATION");
        constantNodeInfoCommandClasses.put(0x9C, "COMMAND_CLASS_SENSOR_ALARM");
        constantNodeInfoCommandClasses.put(0x9D, "COMMAND_CLASS_SILENCE_ALARM");
        constantNodeInfoCommandClasses.put(0x9E, "COMMAND_CLASS_SENSOR_CONFIGURATION");
        constantNodeInfoCommandClasses.put(0x9F, "COMMAND_CLASS_SECURITY_2");
        constantNodeInfoCommandClasses.put(0x90, "COMMAND_CLASS_ENERGY_PRODUCTION");
        constantNodeInfoCommandClasses.put(0x91, "COMMAND_CLASS_MANUFACTURER_PROPRIETARY");
        constantNodeInfoCommandClasses.put(0x92, "COMMAND_CLASS_SCREEN_MD");
        constantNodeInfoCommandClasses.put(0x93, "COMMAND_CLASS_SCREEN_ATTRIBUTES");
        constantNodeInfoCommandClasses.put(0x94, "COMMAND_CLASS_SIMPLE_AV_CONTROL");
        constantNodeInfoCommandClasses.put(0x95, "COMMAND_CLASS_AV_CONTENT_DIRECTORY_MD");
        constantNodeInfoCommandClasses.put(0x96, "COMMAND_CLASS_AV_RENDERER_STATUS");
        constantNodeInfoCommandClasses.put(0x97, "COMMAND_CLASS_AV_CONTENT_SEARCH_MD");
        constantNodeInfoCommandClasses.put(0xEF, "COMMAND_CLASS_MARK");
        constantNodeInfoCommandClasses.put(0xF0, "COMMAND_CLASS_NON_INTEROPERABLE");

        // Constants for NodeInfoCapability
        constantNodeInfoCapability.put(0x40, "ROUTING");
        constantNodeInfoCapability.put(0x80, "LISTENING");

        // Constants for NodeInfoSecurity
        constantNodeInfoSecurity.put(0x10, "BEAM_CAPABILITY");
        constantNodeInfoSecurity.put(0x01, "SECURITY");
        constantNodeInfoSecurity.put(0x20, "SENSOR_250MS");
        constantNodeInfoSecurity.put(0x02, "CONTROLLER");
        constantNodeInfoSecurity.put(0x40, "SENSOR_1000MS");
        constantNodeInfoSecurity.put(0x04, "SPECIFIC_DEVICE");
        constantNodeInfoSecurity.put(0x08, "ROUTING_SLAVE");
        constantNodeInfoSecurity.put(0x80, "OPTIONAL_FUNCTIONALITY");

        // Constants for NodeInfoBasicDeviceClass
        constantNodeInfoBasicDeviceClass.put(0x01, "BASIC_TYPE_CONTROLLER");
        constantNodeInfoBasicDeviceClass.put(0x02, "BASIC_TYPE_STATIC_CONTROLLER");
        constantNodeInfoBasicDeviceClass.put(0x03, "BASIC_TYPE_SLAVE");
        constantNodeInfoBasicDeviceClass.put(0x04, "BASIC_TYPE_ROUTING_SLAVE");

        // Constants for NodeInfoProtocolVersion
        constantNodeInfoProtocolVersion.put(0x00, "Z_WAVE_VERSION_2_0");
        constantNodeInfoProtocolVersion.put(0x01, "Z_WAVE_VERSION_ZDK_5_0X_ZDK_4_2X");
        constantNodeInfoProtocolVersion.put(0x02, "Z_WAVE_VERSION_ZDK_4_5X_AND_ZDK_6_0X");

        // Constants for NodeInfoSpeedExtension
        constantNodeInfoSpeedExtension.put(0x00, "100_KBPS");
        constantNodeInfoSpeedExtension.put(0x01, "200_KBPS");

        // Constants for NodeInfoGenericDeviceClass
        constantNodeInfoGenericDeviceClass.put(0x01, "GENERIC_TYPE_GENERIC_CONTROLLER");
        constantNodeInfoGenericDeviceClass.put(0x02, "GENERIC_TYPE_STATIC_CONTROLLER");
        constantNodeInfoGenericDeviceClass.put(0x20, "GENERIC_TYPE_SENSOR_BINARY");
        constantNodeInfoGenericDeviceClass.put(0x21, "GENERIC_TYPE_SENSOR_MULTILEVEL");
        constantNodeInfoGenericDeviceClass.put(0x03, "GENERIC_TYPE_AV_CONTROL_POINT");
        constantNodeInfoGenericDeviceClass.put(0x04, "GENERIC_TYPE_DISPLAY");
        constantNodeInfoGenericDeviceClass.put(0x40, "GENERIC_TYPE_ENTRY_CONTROL");
        constantNodeInfoGenericDeviceClass.put(0x05, "GENERIC_TYPE_NETWORK_EXTENDER");
        constantNodeInfoGenericDeviceClass.put(0x06, "GENERIC_TYPE_APPLIANCE");
        constantNodeInfoGenericDeviceClass.put(0x07, "GENERIC_TYPE_SENSOR_NOTIFICATION");
        constantNodeInfoGenericDeviceClass.put(0x08, "GENERIC_TYPE_THERMOSTAT");
        constantNodeInfoGenericDeviceClass.put(0x09, "GENERIC_TYPE_WINDOW_COVERING");
        constantNodeInfoGenericDeviceClass.put(0xA1, "GENERIC_TYPE_SENSOR_ALARM");
        constantNodeInfoGenericDeviceClass.put(0x0F, "GENERIC_TYPE_REPEATER_SLAVE");
        constantNodeInfoGenericDeviceClass.put(0x11, "GENERIC_TYPE_SWITCH_MULTILEVEL");
        constantNodeInfoGenericDeviceClass.put(0x10, "GENERIC_TYPE_SWITCH_BINARY");
        constantNodeInfoGenericDeviceClass.put(0xFF, "GENERIC_TYPE_NON_INTEROPERABLE");
        constantNodeInfoGenericDeviceClass.put(0x13, "GENERIC_TYPE_SWITCH_TOGGLE");
        constantNodeInfoGenericDeviceClass.put(0x31, "GENERIC_TYPE_METER");
        constantNodeInfoGenericDeviceClass.put(0x12, "GENERIC_TYPE_SWITCH_REMOTE");
        constantNodeInfoGenericDeviceClass.put(0x30, "GENERIC_TYPE_METER_PULSE");
        constantNodeInfoGenericDeviceClass.put(0x15, "GENERIC_TYPE_ZIP_NODE");
        constantNodeInfoGenericDeviceClass.put(0x50, "GENERIC_TYPE_SEMI_INTEROPERABLE");
        constantNodeInfoGenericDeviceClass.put(0x17, "GENERIC_TYPE_SECURITY_PANEL");
        constantNodeInfoGenericDeviceClass.put(0x16, "GENERIC_TYPE_VENTILATION");
        constantNodeInfoGenericDeviceClass.put(0x18, "GENERIC_TYPE_WALL_CONTROLLER");
    }

    /**
     * Creates a new message with the ZWAVE_CMD_NOP command.
     * <p>
     * NOP
     *
     * @return the {@link byte[]} array with the command to send
     */
    static public byte[] getZwaveCmdNop() {
        logger.debug("Creating command message ZWAVE_CMD_NOP version 1");

        ByteArrayOutputStream outputData = new ByteArrayOutputStream();
        outputData.write(COMMAND_CLASS_KEY);
        outputData.write(ZWAVE_CMD_NOP);

        return outputData.toByteArray();
    }

    /**
     * Processes a received frame with the ZWAVE_CMD_NOP command.
     * <p>
     * NOP
     *
     * @param payload the {@link byte[]} payload data to process
     * @return a {@link Map} of processed response data
     */
    public static Map<String, Object> handleZwaveCmdNop(byte[] payload) {
        // Create our response map
        Map<String, Object> response = new HashMap<String, Object>();

        // Return the map of processed response data;
        return response;
    }

    /**
     * Creates a new message with the NODE_INFO command.
     * <p>
     * Node Info
     * <p>
     * SDS10264-2
     *
     * @param protocolVersion {@link String}
     *            Can be one of the following -:
     *            <p>
     *            <ul>
     *            <li>Z_WAVE_VERSION_2_0
     *            <li>Z_WAVE_VERSION_ZDK_5_0X_ZDK_4_2X
     *            <li>Z_WAVE_VERSION_ZDK_4_5X_AND_ZDK_6_0X
     *            </ul>
     * @param maxBaudRate {@link String}
     *            Can be one of the following -:
     *            <p>
     *            <ul>
     *            <li>9_6_KBPS
     *            <li>40_KBPS
     *            </ul>
     * @param routing {@link Boolean}
     * @param listening {@link Boolean}
     * @param security {@link Boolean}
     *            Can be one of the following -:
     *            <p>
     *            <ul>
     *            <li>BEAM_CAPABILITY
     *            <li>SECURITY
     *            <li>SENSOR_250MS
     *            <li>CONTROLLER
     *            <li>SENSOR_1000MS
     *            <li>SPECIFIC_DEVICE
     *            <li>ROUTING_SLAVE
     *            <li>OPTIONAL_FUNCTIONALITY
     *            </ul>
     * @param controller {@link Boolean}
     * @param specificDevice {@link Boolean}
     * @param routingSlave {@link Boolean}
     * @param beamCapability {@link Boolean}
     * @param sensor250ms {@link Boolean}
     * @param sensor1000ms {@link Boolean}
     * @param optionalFunctionality {@link Boolean}
     * @param speedExtension {@link String}
     *            Can be one of the following -:
     *            <p>
     *            <ul>
     *            <li>100_KBPS
     *            <li>200_KBPS
     *            </ul>
     * @return the {@link byte[]} array with the command to send
     */
    static public byte[] getNodeInfo(String protocolVersion, String maxBaudRate, Boolean routing, Boolean listening,
            Boolean security, Boolean controller, Boolean specificDevice, Boolean routingSlave, Boolean beamCapability,
            Boolean sensor250ms, Boolean sensor1000ms, Boolean optionalFunctionality, String speedExtension) {
        logger.debug("Creating command message NODE_INFO version 1");

        ByteArrayOutputStream outputData = new ByteArrayOutputStream();
        outputData.write(COMMAND_CLASS_KEY);
        outputData.write(NODE_INFO);

        // Process 'Capability'
        int valCapability = 0;
        int varProtocolVersion = Integer.MAX_VALUE;
        for (Integer entry : constantNodeInfoProtocolVersion.keySet()) {
            if (constantNodeInfoProtocolVersion.get(entry).equals(protocolVersion)) {
                varProtocolVersion = entry;
                break;
            }
        }
        if (varProtocolVersion == Integer.MAX_VALUE) {
            throw new IllegalArgumentException("Unknown constant value '" + protocolVersion + "' for protocolVersion");
        }
        valCapability |= varProtocolVersion & 0x07;
        int varMaxBaudRate = Integer.MAX_VALUE;
        for (Integer entry : constantNodeInfoMaxBaudRate.keySet()) {
            if (constantNodeInfoMaxBaudRate.get(entry).equals(maxBaudRate)) {
                varMaxBaudRate = entry;
                break;
            }
        }
        if (varMaxBaudRate == Integer.MAX_VALUE) {
            throw new IllegalArgumentException("Unknown constant value '" + maxBaudRate + "' for maxBaudRate");
        }
        valCapability |= varMaxBaudRate << 3 & 0x38;
        valCapability |= routing ? 0x40 : 0;
        valCapability |= listening ? 0x80 : 0;
        outputData.write(valCapability);

        // Process 'Security'
        int valSecurity = 0;
        valSecurity |= security ? 0x01 : 0;
        valSecurity |= controller ? 0x02 : 0;
        valSecurity |= specificDevice ? 0x04 : 0;
        valSecurity |= routingSlave ? 0x08 : 0;
        valSecurity |= beamCapability ? 0x10 : 0;
        valSecurity |= sensor250ms ? 0x20 : 0;
        valSecurity |= sensor1000ms ? 0x40 : 0;
        valSecurity |= optionalFunctionality ? 0x80 : 0;
        outputData.write(valSecurity);

        // Process 'Properties1'
        int varSpeedExtension = Integer.MAX_VALUE;
        for (Integer entry : constantNodeInfoSpeedExtension.keySet()) {
            if (constantNodeInfoSpeedExtension.get(entry).equals(speedExtension)) {
                varSpeedExtension = entry;
                break;
            }
        }
        if (varSpeedExtension == Integer.MAX_VALUE) {
            throw new IllegalArgumentException("Unknown constant value '" + speedExtension + "' for speedExtension");
        }
        outputData.write(varSpeedExtension & 0x07);

        // Process 'Basic Device Class'

        // Process 'Generic Device Class'

        // Process 'Specific Device Class'

        // Process 'Command Classes'

        return outputData.toByteArray();
    }

    /**
     * Processes a received frame with the NODE_INFO command.
     * <p>
     * Node Info
     * <p>
     * SDS10264-2
     * <p>
     * The output data {@link Map} has the following properties -:
     *
     * <ul>
     * <li>PROTOCOL_VERSION {@link String}
     * Can be one of the following -:
     * <p>
     * <ul>
     * <li>Z_WAVE_VERSION_2_0
     * <li>Z_WAVE_VERSION_ZDK_5_0X_ZDK_4_2X
     * <li>Z_WAVE_VERSION_ZDK_4_5X_AND_ZDK_6_0X
     * </ul>
     * <li>MAX_BAUD_RATE {@link String}
     * Can be one of the following -:
     * <p>
     * <ul>
     * <li>9_6_KBPS
     * <li>40_KBPS
     * </ul>
     * <li>ROUTING {@link Boolean}
     * <li>LISTENING {@link Boolean}
     * <li>SECURITY {@link Boolean}
     * Can be one of the following -:
     * <p>
     * <ul>
     * <li>BEAM_CAPABILITY
     * <li>SECURITY
     * <li>SENSOR_250MS
     * <li>CONTROLLER
     * <li>SENSOR_1000MS
     * <li>SPECIFIC_DEVICE
     * <li>ROUTING_SLAVE
     * <li>OPTIONAL_FUNCTIONALITY
     * </ul>
     * <li>CONTROLLER {@link Boolean}
     * <li>SPECIFIC_DEVICE {@link Boolean}
     * <li>ROUTING_SLAVE {@link Boolean}
     * <li>BEAM_CAPABILITY {@link Boolean}
     * <li>SENSOR_250MS {@link Boolean}
     * <li>SENSOR_1000MS {@link Boolean}
     * <li>OPTIONAL_FUNCTIONALITY {@link Boolean}
     * <li>SPEED_EXTENSION {@link String}
     * Can be one of the following -:
     * <p>
     * <ul>
     * <li>100_KBPS
     * <li>200_KBPS
     * </ul>
     * </ul>
     *
     * @param payload the {@link byte[]} payload data to process
     * @return a {@link Map} of processed response data
     */
    public static Map<String, Object> handleNodeInfo(byte[] payload) {
        // Create our response map
        Map<String, Object> response = new HashMap<String, Object>();

        // Process 'Capability'
        response.put("PROTOCOL_VERSION", constantNodeInfoProtocolVersion.get(payload[2] & 0x07));
        response.put("MAX_BAUD_RATE", constantNodeInfoMaxBaudRate.get((payload[2] & 0x38) >> 3));
        response.put("ROUTING", Boolean.valueOf((payload[2] & 0x40) != 0));
        response.put("LISTENING", Boolean.valueOf((payload[2] & 0x80) != 0));

        // Process 'Security'
        response.put("SECURITY", Boolean.valueOf((payload[3] & 0x01) != 0));
        response.put("CONTROLLER", Boolean.valueOf((payload[3] & 0x02) != 0));
        response.put("SPECIFIC_DEVICE", Boolean.valueOf((payload[3] & 0x04) != 0));
        response.put("ROUTING_SLAVE", Boolean.valueOf((payload[3] & 0x08) != 0));
        response.put("BEAM_CAPABILITY", Boolean.valueOf((payload[3] & 0x10) != 0));
        response.put("SENSOR_250MS", Boolean.valueOf((payload[3] & 0x20) != 0));
        response.put("SENSOR_1000MS", Boolean.valueOf((payload[3] & 0x40) != 0));
        response.put("OPTIONAL_FUNCTIONALITY", Boolean.valueOf((payload[3] & 0x80) != 0));

        // Process 'Properties1'
        response.put("SPEED_EXTENSION", constantNodeInfoSpeedExtension.get(payload[4] & 0x07));

        // Process 'Basic Device Class' (optional)
        if (true) {
            response.put("BASIC_DEVICE_CLASS", constantNodeInfoBasicDeviceClass.get(payload[5] & 0xff));
        }

        // Process 'Generic Device Class'
        response.put("GENERIC_DEVICE_CLASS", constantNodeInfoGenericDeviceClass.get(payload[6] & 0xff));

        // Process 'Specific Device Class'

        // Process 'Command Classes'

        // Return the map of processed response data;
        return response;
    }

    /**
     * Creates a new message with the REQUEST_NODE_INFO command.
     * <p>
     * Request Node Info
     * <p>
     * SDS10264-2
     *
     * @return the {@link byte[]} array with the command to send
     */
    static public byte[] getRequestNodeInfo() {
        logger.debug("Creating command message REQUEST_NODE_INFO version 1");

        ByteArrayOutputStream outputData = new ByteArrayOutputStream();
        outputData.write(COMMAND_CLASS_KEY);
        outputData.write(REQUEST_NODE_INFO);

        return outputData.toByteArray();
    }

    /**
     * Processes a received frame with the REQUEST_NODE_INFO command.
     * <p>
     * Request Node Info
     * <p>
     * SDS10264-2
     *
     * @param payload the {@link byte[]} payload data to process
     * @return a {@link Map} of processed response data
     */
    public static Map<String, Object> handleRequestNodeInfo(byte[] payload) {
        // Create our response map
        Map<String, Object> response = new HashMap<String, Object>();

        // Return the map of processed response data;
        return response;
    }

    /**
     * Creates a new message with the ASSIGN_ID command.
     * <p>
     * Assign Id
     * <p>
     * SDS10264-2
     *
     * @return the {@link byte[]} array with the command to send
     */
    static public byte[] getAssignId() {
        logger.debug("Creating command message ASSIGN_ID version 1");

        ByteArrayOutputStream outputData = new ByteArrayOutputStream();
        outputData.write(COMMAND_CLASS_KEY);
        outputData.write(ASSIGN_ID);

        return outputData.toByteArray();
    }

    /**
     * Processes a received frame with the ASSIGN_ID command.
     * <p>
     * Assign Id
     * <p>
     * SDS10264-2
     *
     * @param payload the {@link byte[]} payload data to process
     * @return a {@link Map} of processed response data
     */
    public static Map<String, Object> handleAssignId(byte[] payload) {
        // Create our response map
        Map<String, Object> response = new HashMap<String, Object>();

        // Return the map of processed response data;
        return response;
    }

    /**
     * Creates a new message with the FIND_NODES_IN_RANGE command.
     * <p>
     * Find Nodes In Range
     * <p>
     * SDS10264-2
     *
     * @return the {@link byte[]} array with the command to send
     */
    static public byte[] getFindNodesInRange() {
        logger.debug("Creating command message FIND_NODES_IN_RANGE version 1");

        ByteArrayOutputStream outputData = new ByteArrayOutputStream();
        outputData.write(COMMAND_CLASS_KEY);
        outputData.write(FIND_NODES_IN_RANGE);

        return outputData.toByteArray();
    }

    /**
     * Processes a received frame with the FIND_NODES_IN_RANGE command.
     * <p>
     * Find Nodes In Range
     * <p>
     * SDS10264-2
     *
     * @param payload the {@link byte[]} payload data to process
     * @return a {@link Map} of processed response data
     */
    public static Map<String, Object> handleFindNodesInRange(byte[] payload) {
        // Create our response map
        Map<String, Object> response = new HashMap<String, Object>();

        // Return the map of processed response data;
        return response;
    }

    /**
     * Creates a new message with the GET_NODES_IN_RANGE command.
     * <p>
     * Get Nodes In Range
     * <p>
     * SDS10264-2
     *
     * @return the {@link byte[]} array with the command to send
     */
    static public byte[] getGetNodesInRange() {
        logger.debug("Creating command message GET_NODES_IN_RANGE version 1");

        ByteArrayOutputStream outputData = new ByteArrayOutputStream();
        outputData.write(COMMAND_CLASS_KEY);
        outputData.write(GET_NODES_IN_RANGE);

        return outputData.toByteArray();
    }

    /**
     * Processes a received frame with the GET_NODES_IN_RANGE command.
     * <p>
     * Get Nodes In Range
     * <p>
     * SDS10264-2
     *
     * @param payload the {@link byte[]} payload data to process
     * @return a {@link Map} of processed response data
     */
    public static Map<String, Object> handleGetNodesInRange(byte[] payload) {
        // Create our response map
        Map<String, Object> response = new HashMap<String, Object>();

        // Return the map of processed response data;
        return response;
    }

    /**
     * Creates a new message with the NODE_RANGE_INFO command.
     * <p>
     * Node Range Info
     * <p>
     * SDS10264-2
     *
     * @return the {@link byte[]} array with the command to send
     */
    static public byte[] getNodeRangeInfo() {
        logger.debug("Creating command message NODE_RANGE_INFO version 1");

        ByteArrayOutputStream outputData = new ByteArrayOutputStream();
        outputData.write(COMMAND_CLASS_KEY);
        outputData.write(NODE_RANGE_INFO);

        return outputData.toByteArray();
    }

    /**
     * Processes a received frame with the NODE_RANGE_INFO command.
     * <p>
     * Node Range Info
     * <p>
     * SDS10264-2
     *
     * @param payload the {@link byte[]} payload data to process
     * @return a {@link Map} of processed response data
     */
    public static Map<String, Object> handleNodeRangeInfo(byte[] payload) {
        // Create our response map
        Map<String, Object> response = new HashMap<String, Object>();

        // Return the map of processed response data;
        return response;
    }

    /**
     * Creates a new message with the COMMAND_COMPLETE command.
     * <p>
     * Command Complete
     * <p>
     * SDS10264-2
     *
     * @return the {@link byte[]} array with the command to send
     */
    static public byte[] getCommandComplete() {
        logger.debug("Creating command message COMMAND_COMPLETE version 1");

        ByteArrayOutputStream outputData = new ByteArrayOutputStream();
        outputData.write(COMMAND_CLASS_KEY);
        outputData.write(COMMAND_COMPLETE);

        return outputData.toByteArray();
    }

    /**
     * Processes a received frame with the COMMAND_COMPLETE command.
     * <p>
     * Command Complete
     * <p>
     * SDS10264-2
     *
     * @param payload the {@link byte[]} payload data to process
     * @return a {@link Map} of processed response data
     */
    public static Map<String, Object> handleCommandComplete(byte[] payload) {
        // Create our response map
        Map<String, Object> response = new HashMap<String, Object>();

        // Return the map of processed response data;
        return response;
    }

    /**
     * Creates a new message with the TRANSFER_PRESENTATION command.
     * <p>
     * Transfer Presentation
     * <p>
     * SDS10264-2
     *
     * @return the {@link byte[]} array with the command to send
     */
    static public byte[] getTransferPresentation() {
        logger.debug("Creating command message TRANSFER_PRESENTATION version 1");

        ByteArrayOutputStream outputData = new ByteArrayOutputStream();
        outputData.write(COMMAND_CLASS_KEY);
        outputData.write(TRANSFER_PRESENTATION);

        return outputData.toByteArray();
    }

    /**
     * Processes a received frame with the TRANSFER_PRESENTATION command.
     * <p>
     * Transfer Presentation
     * <p>
     * SDS10264-2
     *
     * @param payload the {@link byte[]} payload data to process
     * @return a {@link Map} of processed response data
     */
    public static Map<String, Object> handleTransferPresentation(byte[] payload) {
        // Create our response map
        Map<String, Object> response = new HashMap<String, Object>();

        // Return the map of processed response data;
        return response;
    }

    /**
     * Creates a new message with the TRANSFER_NODE_INFO command.
     * <p>
     * Transfer Node Info
     * <p>
     * SDS10264-2
     *
     * @return the {@link byte[]} array with the command to send
     */
    static public byte[] getTransferNodeInfo() {
        logger.debug("Creating command message TRANSFER_NODE_INFO version 1");

        ByteArrayOutputStream outputData = new ByteArrayOutputStream();
        outputData.write(COMMAND_CLASS_KEY);
        outputData.write(TRANSFER_NODE_INFO);

        return outputData.toByteArray();
    }

    /**
     * Processes a received frame with the TRANSFER_NODE_INFO command.
     * <p>
     * Transfer Node Info
     * <p>
     * SDS10264-2
     *
     * @param payload the {@link byte[]} payload data to process
     * @return a {@link Map} of processed response data
     */
    public static Map<String, Object> handleTransferNodeInfo(byte[] payload) {
        // Create our response map
        Map<String, Object> response = new HashMap<String, Object>();

        // Return the map of processed response data;
        return response;
    }

    /**
     * Creates a new message with the TRANSFER_RANGE_INFO command.
     * <p>
     * Transfer Range Info
     * <p>
     * SDS10264-2
     *
     * @return the {@link byte[]} array with the command to send
     */
    static public byte[] getTransferRangeInfo() {
        logger.debug("Creating command message TRANSFER_RANGE_INFO version 1");

        ByteArrayOutputStream outputData = new ByteArrayOutputStream();
        outputData.write(COMMAND_CLASS_KEY);
        outputData.write(TRANSFER_RANGE_INFO);

        return outputData.toByteArray();
    }

    /**
     * Processes a received frame with the TRANSFER_RANGE_INFO command.
     * <p>
     * Transfer Range Info
     * <p>
     * SDS10264-2
     *
     * @param payload the {@link byte[]} payload data to process
     * @return a {@link Map} of processed response data
     */
    public static Map<String, Object> handleTransferRangeInfo(byte[] payload) {
        // Create our response map
        Map<String, Object> response = new HashMap<String, Object>();

        // Return the map of processed response data;
        return response;
    }

    /**
     * Creates a new message with the TRANSFER_END command.
     * <p>
     * Transfer End
     * <p>
     * SDS10264-2
     *
     * @return the {@link byte[]} array with the command to send
     */
    static public byte[] getTransferEnd() {
        logger.debug("Creating command message TRANSFER_END version 1");

        ByteArrayOutputStream outputData = new ByteArrayOutputStream();
        outputData.write(COMMAND_CLASS_KEY);
        outputData.write(TRANSFER_END);

        return outputData.toByteArray();
    }

    /**
     * Processes a received frame with the TRANSFER_END command.
     * <p>
     * Transfer End
     * <p>
     * SDS10264-2
     *
     * @param payload the {@link byte[]} payload data to process
     * @return a {@link Map} of processed response data
     */
    public static Map<String, Object> handleTransferEnd(byte[] payload) {
        // Create our response map
        Map<String, Object> response = new HashMap<String, Object>();

        // Return the map of processed response data;
        return response;
    }

    /**
     * Creates a new message with the ASSIGN_RETURN_ROUTE command.
     * <p>
     * Assign Return Route
     * <p>
     * SDS10264-2
     *
     * @return the {@link byte[]} array with the command to send
     */
    static public byte[] getAssignReturnRoute() {
        logger.debug("Creating command message ASSIGN_RETURN_ROUTE version 1");

        ByteArrayOutputStream outputData = new ByteArrayOutputStream();
        outputData.write(COMMAND_CLASS_KEY);
        outputData.write(ASSIGN_RETURN_ROUTE);

        return outputData.toByteArray();
    }

    /**
     * Processes a received frame with the ASSIGN_RETURN_ROUTE command.
     * <p>
     * Assign Return Route
     * <p>
     * SDS10264-2
     *
     * @param payload the {@link byte[]} payload data to process
     * @return a {@link Map} of processed response data
     */
    public static Map<String, Object> handleAssignReturnRoute(byte[] payload) {
        // Create our response map
        Map<String, Object> response = new HashMap<String, Object>();

        // Return the map of processed response data;
        return response;
    }

    /**
     * Creates a new message with the NEW_NODE_REGISTERED command.
     * <p>
     * New Node Registered
     * <p>
     * SDS10264-2
     *
     * @return the {@link byte[]} array with the command to send
     */
    static public byte[] getNewNodeRegistered() {
        logger.debug("Creating command message NEW_NODE_REGISTERED version 1");

        ByteArrayOutputStream outputData = new ByteArrayOutputStream();
        outputData.write(COMMAND_CLASS_KEY);
        outputData.write(NEW_NODE_REGISTERED);

        return outputData.toByteArray();
    }

    /**
     * Processes a received frame with the NEW_NODE_REGISTERED command.
     * <p>
     * New Node Registered
     * <p>
     * SDS10264-2
     *
     * @param payload the {@link byte[]} payload data to process
     * @return a {@link Map} of processed response data
     */
    public static Map<String, Object> handleNewNodeRegistered(byte[] payload) {
        // Create our response map
        Map<String, Object> response = new HashMap<String, Object>();

        // Return the map of processed response data;
        return response;
    }

    /**
     * Creates a new message with the NEW_RANGE_REGISTERED command.
     * <p>
     * New Range Registered
     * <p>
     * SDS10264-2
     *
     * @return the {@link byte[]} array with the command to send
     */
    static public byte[] getNewRangeRegistered() {
        logger.debug("Creating command message NEW_RANGE_REGISTERED version 1");

        ByteArrayOutputStream outputData = new ByteArrayOutputStream();
        outputData.write(COMMAND_CLASS_KEY);
        outputData.write(NEW_RANGE_REGISTERED);

        return outputData.toByteArray();
    }

    /**
     * Processes a received frame with the NEW_RANGE_REGISTERED command.
     * <p>
     * New Range Registered
     * <p>
     * SDS10264-2
     *
     * @param payload the {@link byte[]} payload data to process
     * @return a {@link Map} of processed response data
     */
    public static Map<String, Object> handleNewRangeRegistered(byte[] payload) {
        // Create our response map
        Map<String, Object> response = new HashMap<String, Object>();

        // Return the map of processed response data;
        return response;
    }

    /**
     * Creates a new message with the TRANSFER_NEW_PRIMARY_COMPLETE command.
     * <p>
     * Transfer New Primary Complete
     * <p>
     * SDS10264-2
     *
     * @return the {@link byte[]} array with the command to send
     */
    static public byte[] getTransferNewPrimaryComplete() {
        logger.debug("Creating command message TRANSFER_NEW_PRIMARY_COMPLETE version 1");

        ByteArrayOutputStream outputData = new ByteArrayOutputStream();
        outputData.write(COMMAND_CLASS_KEY);
        outputData.write(TRANSFER_NEW_PRIMARY_COMPLETE);

        return outputData.toByteArray();
    }

    /**
     * Processes a received frame with the TRANSFER_NEW_PRIMARY_COMPLETE command.
     * <p>
     * Transfer New Primary Complete
     * <p>
     * SDS10264-2
     *
     * @param payload the {@link byte[]} payload data to process
     * @return a {@link Map} of processed response data
     */
    public static Map<String, Object> handleTransferNewPrimaryComplete(byte[] payload) {
        // Create our response map
        Map<String, Object> response = new HashMap<String, Object>();

        // Return the map of processed response data;
        return response;
    }

    /**
     * Creates a new message with the CMD_AUTOMATIC_CONTROLLER_UPDATE_START command.
     * <p>
     * Automatic Controller Update Start
     *
     * @return the {@link byte[]} array with the command to send
     */
    static public byte[] getCmdAutomaticControllerUpdateStart() {
        logger.debug("Creating command message CMD_AUTOMATIC_CONTROLLER_UPDATE_START version 1");

        ByteArrayOutputStream outputData = new ByteArrayOutputStream();
        outputData.write(COMMAND_CLASS_KEY);
        outputData.write(CMD_AUTOMATIC_CONTROLLER_UPDATE_START);

        return outputData.toByteArray();
    }

    /**
     * Processes a received frame with the CMD_AUTOMATIC_CONTROLLER_UPDATE_START command.
     * <p>
     * Automatic Controller Update Start
     *
     * @param payload the {@link byte[]} payload data to process
     * @return a {@link Map} of processed response data
     */
    public static Map<String, Object> handleCmdAutomaticControllerUpdateStart(byte[] payload) {
        // Create our response map
        Map<String, Object> response = new HashMap<String, Object>();

        // Return the map of processed response data;
        return response;
    }

    /**
     * Creates a new message with the CMD_SUC_NODE_ID command.
     * <p>
     * SUC Node ID
     *
     * @return the {@link byte[]} array with the command to send
     */
    static public byte[] getCmdSucNodeId() {
        logger.debug("Creating command message CMD_SUC_NODE_ID version 1");

        ByteArrayOutputStream outputData = new ByteArrayOutputStream();
        outputData.write(COMMAND_CLASS_KEY);
        outputData.write(CMD_SUC_NODE_ID);

        return outputData.toByteArray();
    }

    /**
     * Processes a received frame with the CMD_SUC_NODE_ID command.
     * <p>
     * SUC Node ID
     *
     * @param payload the {@link byte[]} payload data to process
     * @return a {@link Map} of processed response data
     */
    public static Map<String, Object> handleCmdSucNodeId(byte[] payload) {
        // Create our response map
        Map<String, Object> response = new HashMap<String, Object>();

        // Return the map of processed response data;
        return response;
    }

    /**
     * Creates a new message with the CMD_SET_SUC command.
     * <p>
     * Set SUC
     *
     * @return the {@link byte[]} array with the command to send
     */
    static public byte[] getCmdSetSuc() {
        logger.debug("Creating command message CMD_SET_SUC version 1");

        ByteArrayOutputStream outputData = new ByteArrayOutputStream();
        outputData.write(COMMAND_CLASS_KEY);
        outputData.write(CMD_SET_SUC);

        return outputData.toByteArray();
    }

    /**
     * Processes a received frame with the CMD_SET_SUC command.
     * <p>
     * Set SUC
     *
     * @param payload the {@link byte[]} payload data to process
     * @return a {@link Map} of processed response data
     */
    public static Map<String, Object> handleCmdSetSuc(byte[] payload) {
        // Create our response map
        Map<String, Object> response = new HashMap<String, Object>();

        // Return the map of processed response data;
        return response;
    }

    /**
     * Creates a new message with the CMD_SET_SUC_ACK command.
     * <p>
     * Set SUC ACK
     *
     * @return the {@link byte[]} array with the command to send
     */
    static public byte[] getCmdSetSucAck() {
        logger.debug("Creating command message CMD_SET_SUC_ACK version 1");

        ByteArrayOutputStream outputData = new ByteArrayOutputStream();
        outputData.write(COMMAND_CLASS_KEY);
        outputData.write(CMD_SET_SUC_ACK);

        return outputData.toByteArray();
    }

    /**
     * Processes a received frame with the CMD_SET_SUC_ACK command.
     * <p>
     * Set SUC ACK
     *
     * @param payload the {@link byte[]} payload data to process
     * @return a {@link Map} of processed response data
     */
    public static Map<String, Object> handleCmdSetSucAck(byte[] payload) {
        // Create our response map
        Map<String, Object> response = new HashMap<String, Object>();

        // Return the map of processed response data;
        return response;
    }

    /**
     * Creates a new message with the CMD_ASSIGN_SUC_RETURN_ROUTE command.
     * <p>
     * Assign SUC Return Route
     *
     * @return the {@link byte[]} array with the command to send
     */
    static public byte[] getCmdAssignSucReturnRoute() {
        logger.debug("Creating command message CMD_ASSIGN_SUC_RETURN_ROUTE version 1");

        ByteArrayOutputStream outputData = new ByteArrayOutputStream();
        outputData.write(COMMAND_CLASS_KEY);
        outputData.write(CMD_ASSIGN_SUC_RETURN_ROUTE);

        return outputData.toByteArray();
    }

    /**
     * Processes a received frame with the CMD_ASSIGN_SUC_RETURN_ROUTE command.
     * <p>
     * Assign SUC Return Route
     *
     * @param payload the {@link byte[]} payload data to process
     * @return a {@link Map} of processed response data
     */
    public static Map<String, Object> handleCmdAssignSucReturnRoute(byte[] payload) {
        // Create our response map
        Map<String, Object> response = new HashMap<String, Object>();

        // Return the map of processed response data;
        return response;
    }

    /**
     * Creates a new message with the CMD_STATIC_ROUTE_REQUEST command.
     * <p>
     * Static Route Request
     *
     * @return the {@link byte[]} array with the command to send
     */
    static public byte[] getCmdStaticRouteRequest() {
        logger.debug("Creating command message CMD_STATIC_ROUTE_REQUEST version 1");

        ByteArrayOutputStream outputData = new ByteArrayOutputStream();
        outputData.write(COMMAND_CLASS_KEY);
        outputData.write(CMD_STATIC_ROUTE_REQUEST);

        return outputData.toByteArray();
    }

    /**
     * Processes a received frame with the CMD_STATIC_ROUTE_REQUEST command.
     * <p>
     * Static Route Request
     *
     * @param payload the {@link byte[]} payload data to process
     * @return a {@link Map} of processed response data
     */
    public static Map<String, Object> handleCmdStaticRouteRequest(byte[] payload) {
        // Create our response map
        Map<String, Object> response = new HashMap<String, Object>();

        // Return the map of processed response data;
        return response;
    }

    /**
     * Creates a new message with the LOST command.
     * <p>
     * Lost
     * <p>
     * SDS10264-2
     *
     * @return the {@link byte[]} array with the command to send
     */
    static public byte[] getLost() {
        logger.debug("Creating command message LOST version 1");

        ByteArrayOutputStream outputData = new ByteArrayOutputStream();
        outputData.write(COMMAND_CLASS_KEY);
        outputData.write(LOST);

        return outputData.toByteArray();
    }

    /**
     * Processes a received frame with the LOST command.
     * <p>
     * Lost
     * <p>
     * SDS10264-2
     *
     * @param payload the {@link byte[]} payload data to process
     * @return a {@link Map} of processed response data
     */
    public static Map<String, Object> handleLost(byte[] payload) {
        // Create our response map
        Map<String, Object> response = new HashMap<String, Object>();

        // Return the map of processed response data;
        return response;
    }

    /**
     * Creates a new message with the ACCEPT_LOST command.
     * <p>
     * Accept Lost
     * <p>
     * SDS10264-2
     *
     * @return the {@link byte[]} array with the command to send
     */
    static public byte[] getAcceptLost() {
        logger.debug("Creating command message ACCEPT_LOST version 1");

        ByteArrayOutputStream outputData = new ByteArrayOutputStream();
        outputData.write(COMMAND_CLASS_KEY);
        outputData.write(ACCEPT_LOST);

        return outputData.toByteArray();
    }

    /**
     * Processes a received frame with the ACCEPT_LOST command.
     * <p>
     * Accept Lost
     * <p>
     * SDS10264-2
     *
     * @param payload the {@link byte[]} payload data to process
     * @return a {@link Map} of processed response data
     */
    public static Map<String, Object> handleAcceptLost(byte[] payload) {
        // Create our response map
        Map<String, Object> response = new HashMap<String, Object>();

        // Return the map of processed response data;
        return response;
    }

    /**
     * Creates a new message with the CMD_NOP_POWER command.
     * <p>
     * NOP Power
     *
     * @return the {@link byte[]} array with the command to send
     */
    static public byte[] getCmdNopPower() {
        logger.debug("Creating command message CMD_NOP_POWER version 1");

        ByteArrayOutputStream outputData = new ByteArrayOutputStream();
        outputData.write(COMMAND_CLASS_KEY);
        outputData.write(CMD_NOP_POWER);

        return outputData.toByteArray();
    }

    /**
     * Processes a received frame with the CMD_NOP_POWER command.
     * <p>
     * NOP Power
     *
     * @param payload the {@link byte[]} payload data to process
     * @return a {@link Map} of processed response data
     */
    public static Map<String, Object> handleCmdNopPower(byte[] payload) {
        // Create our response map
        Map<String, Object> response = new HashMap<String, Object>();

        // Return the map of processed response data;
        return response;
    }

    /**
     * Creates a new message with the ZWAVE_CMD_RESERVE_NODE_IDS command.
     * <p>
     * Reserve Node ID
     *
     * @return the {@link byte[]} array with the command to send
     */
    static public byte[] getZwaveCmdReserveNodeIds() {
        logger.debug("Creating command message ZWAVE_CMD_RESERVE_NODE_IDS version 1");

        ByteArrayOutputStream outputData = new ByteArrayOutputStream();
        outputData.write(COMMAND_CLASS_KEY);
        outputData.write(ZWAVE_CMD_RESERVE_NODE_IDS);

        return outputData.toByteArray();
    }

    /**
     * Processes a received frame with the ZWAVE_CMD_RESERVE_NODE_IDS command.
     * <p>
     * Reserve Node ID
     *
     * @param payload the {@link byte[]} payload data to process
     * @return a {@link Map} of processed response data
     */
    public static Map<String, Object> handleZwaveCmdReserveNodeIds(byte[] payload) {
        // Create our response map
        Map<String, Object> response = new HashMap<String, Object>();

        // Return the map of processed response data;
        return response;
    }

    /**
     * Creates a new message with the CMD_RESERVED_IDS command.
     * <p>
     * Reserved ID
     *
     * @return the {@link byte[]} array with the command to send
     */
    static public byte[] getCmdReservedIds() {
        logger.debug("Creating command message CMD_RESERVED_IDS version 1");

        ByteArrayOutputStream outputData = new ByteArrayOutputStream();
        outputData.write(COMMAND_CLASS_KEY);
        outputData.write(CMD_RESERVED_IDS);

        return outputData.toByteArray();
    }

    /**
     * Processes a received frame with the CMD_RESERVED_IDS command.
     * <p>
     * Reserved ID
     *
     * @param payload the {@link byte[]} payload data to process
     * @return a {@link Map} of processed response data
     */
    public static Map<String, Object> handleCmdReservedIds(byte[] payload) {
        // Create our response map
        Map<String, Object> response = new HashMap<String, Object>();

        // Return the map of processed response data;
        return response;
    }

    /**
     * Creates a new message with the CMD_NODES_EXIST command.
     * <p>
     * Cmd Nodes Exist
     *
     * @return the {@link byte[]} array with the command to send
     */
    static public byte[] getCmdNodesExist() {
        logger.debug("Creating command message CMD_NODES_EXIST version 1");

        ByteArrayOutputStream outputData = new ByteArrayOutputStream();
        outputData.write(COMMAND_CLASS_KEY);
        outputData.write(CMD_NODES_EXIST);

        return outputData.toByteArray();
    }

    /**
     * Processes a received frame with the CMD_NODES_EXIST command.
     * <p>
     * Cmd Nodes Exist
     *
     * @param payload the {@link byte[]} payload data to process
     * @return a {@link Map} of processed response data
     */
    public static Map<String, Object> handleCmdNodesExist(byte[] payload) {
        // Create our response map
        Map<String, Object> response = new HashMap<String, Object>();

        // Return the map of processed response data;
        return response;
    }

    /**
     * Creates a new message with the CMD_NODES_EXIST_REPLY command.
     * <p>
     * Cmd Nodes Exist Reply
     *
     * @return the {@link byte[]} array with the command to send
     */
    static public byte[] getCmdNodesExistReply() {
        logger.debug("Creating command message CMD_NODES_EXIST_REPLY version 1");

        ByteArrayOutputStream outputData = new ByteArrayOutputStream();
        outputData.write(COMMAND_CLASS_KEY);
        outputData.write(CMD_NODES_EXIST_REPLY);

        return outputData.toByteArray();
    }

    /**
     * Processes a received frame with the CMD_NODES_EXIST_REPLY command.
     * <p>
     * Cmd Nodes Exist Reply
     *
     * @param payload the {@link byte[]} payload data to process
     * @return a {@link Map} of processed response data
     */
    public static Map<String, Object> handleCmdNodesExistReply(byte[] payload) {
        // Create our response map
        Map<String, Object> response = new HashMap<String, Object>();

        // Return the map of processed response data;
        return response;
    }

    /**
     * Creates a new message with the CMD_SET_NWI_MODE command.
     * <p>
     * Cmd Set Nwi Mode
     *
     * @return the {@link byte[]} array with the command to send
     */
    static public byte[] getCmdSetNwiMode() {
        logger.debug("Creating command message CMD_SET_NWI_MODE version 1");

        ByteArrayOutputStream outputData = new ByteArrayOutputStream();
        outputData.write(COMMAND_CLASS_KEY);
        outputData.write(CMD_SET_NWI_MODE);

        return outputData.toByteArray();
    }

    /**
     * Processes a received frame with the CMD_SET_NWI_MODE command.
     * <p>
     * Cmd Set Nwi Mode
     *
     * @param payload the {@link byte[]} payload data to process
     * @return a {@link Map} of processed response data
     */
    public static Map<String, Object> handleCmdSetNwiMode(byte[] payload) {
        // Create our response map
        Map<String, Object> response = new HashMap<String, Object>();

        // Return the map of processed response data;
        return response;
    }

    /**
     * Creates a new message with the EXCLUDE_REQUEST command.
     * <p>
     * Exclude Request
     * <p>
     * INS13044
     *
     * @return the {@link byte[]} array with the command to send
     */
    static public byte[] getExcludeRequest() {
        logger.debug("Creating command message EXCLUDE_REQUEST version 1");

        ByteArrayOutputStream outputData = new ByteArrayOutputStream();
        outputData.write(COMMAND_CLASS_KEY);
        outputData.write(EXCLUDE_REQUEST);

        return outputData.toByteArray();
    }

    /**
     * Processes a received frame with the EXCLUDE_REQUEST command.
     * <p>
     * Exclude Request
     * <p>
     * INS13044
     *
     * @param payload the {@link byte[]} payload data to process
     * @return a {@link Map} of processed response data
     */
    public static Map<String, Object> handleExcludeRequest(byte[] payload) {
        // Create our response map
        Map<String, Object> response = new HashMap<String, Object>();

        // Return the map of processed response data;
        return response;
    }

    /**
     * Creates a new message with the ASSIGN_RETURN_ROUTE_PRIORITY command.
     * <p>
     * Assign Return Route Priority
     *
     * @return the {@link byte[]} array with the command to send
     */
    static public byte[] getAssignReturnRoutePriority() {
        logger.debug("Creating command message ASSIGN_RETURN_ROUTE_PRIORITY version 1");

        ByteArrayOutputStream outputData = new ByteArrayOutputStream();
        outputData.write(COMMAND_CLASS_KEY);
        outputData.write(ASSIGN_RETURN_ROUTE_PRIORITY);

        return outputData.toByteArray();
    }

    /**
     * Processes a received frame with the ASSIGN_RETURN_ROUTE_PRIORITY command.
     * <p>
     * Assign Return Route Priority
     *
     * @param payload the {@link byte[]} payload data to process
     * @return a {@link Map} of processed response data
     */
    public static Map<String, Object> handleAssignReturnRoutePriority(byte[] payload) {
        // Create our response map
        Map<String, Object> response = new HashMap<String, Object>();

        // Return the map of processed response data;
        return response;
    }

    /**
     * Creates a new message with the ASSIGN_SUC_RETURN_ROUTE_PRIORITY command.
     * <p>
     * Assign SUC Return Route Priority
     *
     * @return the {@link byte[]} array with the command to send
     */
    static public byte[] getAssignSucReturnRoutePriority() {
        logger.debug("Creating command message ASSIGN_SUC_RETURN_ROUTE_PRIORITY version 1");

        ByteArrayOutputStream outputData = new ByteArrayOutputStream();
        outputData.write(COMMAND_CLASS_KEY);
        outputData.write(ASSIGN_SUC_RETURN_ROUTE_PRIORITY);

        return outputData.toByteArray();
    }

    /**
     * Processes a received frame with the ASSIGN_SUC_RETURN_ROUTE_PRIORITY command.
     * <p>
     * Assign SUC Return Route Priority
     *
     * @param payload the {@link byte[]} payload data to process
     * @return a {@link Map} of processed response data
     */
    public static Map<String, Object> handleAssignSucReturnRoutePriority(byte[] payload) {
        // Create our response map
        Map<String, Object> response = new HashMap<String, Object>();

        // Return the map of processed response data;
        return response;
    }
}
