/**
 * Copyright (c) 2016-2017 by the respective copyright holders.
 *
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Eclipse Public License v1.0
 * which accompanies this distribution, and is available at
 * http://www.eclipse.org/legal/epl-v10.html
 */
package com.zsmartsystems.zwave.commandclass.impl;

import java.io.ByteArrayOutputStream;
import java.util.HashMap;
import java.util.Map;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

/**
 * Class to implement the Z-Wave command class <b>ZWAVE_CMD_CLASS</b> version <b>1</b>.<br>
 * <p>
 * Z-Wave protocol Command Class<br>
 *
 * This class provides static methods for processing received messages (message handler) and
 * methods to get a message to send on the Z-Wave network.<br>
 * <p>
 * Note that this code is autogenerated. Manual changes may be overwritten.
 *
 * @author Chris Jackson - Initial contribution of Java code generator
 */
public class ZwaveCmdClassV1 {
    private static final Logger logger = LoggerFactory.getLogger(ZwaveCmdClassV1.class);

    /**
     * Integer command class key for ZWAVE_CMD_CLASS
     */
    public final static int COMMAND_CLASS_KEY = 0x01;

    /**
     * NOP Command Constant
     */
    public final static int ZWAVE_CMD_NOP = 0x00;
    /**
     * Node Info Command Constant
     * SDS10264-2
     */
    public final static int NODE_INFO = 0x01;
    /**
     * Request Node Info Command Constant
     * SDS10264-2
     */
    public final static int REQUEST_NODE_INFO = 0x02;
    /**
     * Assign Id Command Constant
     * SDS10264-2
     */
    public final static int ASSIGN_ID = 0x03;
    /**
     * Find Nodes In Range Command Constant
     * SDS10264-2
     */
    public final static int FIND_NODES_IN_RANGE = 0x04;
    /**
     * Get Nodes In Range Command Constant
     * SDS10264-2
     */
    public final static int GET_NODES_IN_RANGE = 0x05;
    /**
     * Node Range Info Command Constant
     * SDS10264-2
     */
    public final static int NODE_RANGE_INFO = 0x06;
    /**
     * Command Complete Command Constant
     * SDS10264-2
     */
    public final static int COMMAND_COMPLETE = 0x07;
    /**
     * Transfer Presentation Command Constant
     * SDS10264-2
     */
    public final static int TRANSFER_PRESENTATION = 0x08;
    /**
     * Transfer Node Info Command Constant
     * SDS10264-2
     */
    public final static int TRANSFER_NODE_INFO = 0x09;
    /**
     * Transfer Range Info Command Constant
     * SDS10264-2
     */
    public final static int TRANSFER_RANGE_INFO = 0x0A;
    /**
     * Transfer End Command Constant
     * SDS10264-2
     */
    public final static int TRANSFER_END = 0x0B;
    /**
     * Assign Return Route Command Constant
     * SDS10264-2
     */
    public final static int ASSIGN_RETURN_ROUTE = 0x0C;
    /**
     * New Node Registered Command Constant
     * SDS10264-2
     */
    public final static int NEW_NODE_REGISTERED = 0x0D;
    /**
     * New Range Registered Command Constant
     * SDS10264-2
     */
    public final static int NEW_RANGE_REGISTERED = 0x0E;
    /**
     * Transfer New Primary Complete Command Constant
     * SDS10264-2
     */
    public final static int TRANSFER_NEW_PRIMARY_COMPLETE = 0x0F;
    /**
     * Automatic Controller Update Start Command Constant
     */
    public final static int CMD_AUTOMATIC_CONTROLLER_UPDATE_START = 0x10;
    /**
     * SUC Node ID Command Constant
     */
    public final static int CMD_SUC_NODE_ID = 0x11;
    /**
     * Set SUC Command Constant
     */
    public final static int CMD_SET_SUC = 0x12;
    /**
     * Set SUC ACK Command Constant
     */
    public final static int CMD_SET_SUC_ACK = 0x13;
    /**
     * Assign SUC Return Route Command Constant
     */
    public final static int CMD_ASSIGN_SUC_RETURN_ROUTE = 0x14;
    /**
     * Static Route Request Command Constant
     */
    public final static int CMD_STATIC_ROUTE_REQUEST = 0x15;
    /**
     * Lost Command Constant
     * SDS10264-2
     */
    public final static int LOST = 0x16;
    /**
     * Accept Lost Command Constant
     * SDS10264-2
     */
    public final static int ACCEPT_LOST = 0x17;
    /**
     * NOP Power Command Constant
     */
    public final static int CMD_NOP_POWER = 0x18;
    /**
     * Reserve Node ID Command Constant
     */
    public final static int ZWAVE_CMD_RESERVE_NODE_IDS = 0x19;
    /**
     * Reserved ID Command Constant
     */
    public final static int CMD_RESERVED_IDS = 0x1A;
    /**
     * Cmd Nodes Exist Command Constant
     */
    public final static int CMD_NODES_EXIST = 0x1F;
    /**
     * Cmd Nodes Exist Reply Command Constant
     */
    public final static int CMD_NODES_EXIST_REPLY = 0x20;
    /**
     * Cmd Set Nwi Mode Command Constant
     */
    public final static int CMD_SET_NWI_MODE = 0x22;
    /**
     * Exclude Request Command Constant
     * INS13044
     */
    public final static int EXCLUDE_REQUEST = 0x23;
    /**
     * Assign Return Route Priority Command Constant
     */
    public final static int ASSIGN_RETURN_ROUTE_PRIORITY = 0x24;
    /**
     * Assign SUC Return Route Priority Command Constant
     */
    public final static int ASSIGN_SUC_RETURN_ROUTE_PRIORITY = 0x25;

    /**
     * Creates a new message with the ZWAVE_CMD_NOP command.<br>
     * <p>
     * NOP<br>
     *
     * @return the {@link byte[]} array with the command to send
     */
    static public byte[] getZwaveCmdNop() {
        logger.debug("Creating command message ZWAVE_CMD_NOP version 1");

        ByteArrayOutputStream outputData = new ByteArrayOutputStream();
        outputData.write(COMMAND_CLASS_KEY);
        outputData.write(ZWAVE_CMD_NOP);

        return outputData.toByteArray();
    }

    /**
     * Processes a received frame with the ZWAVE_CMD_NOP command<br>
     * <p>
     * NOP<br>
     *
     * @param payload the {@link byte[]} payload data to process
     * @return a {@link Map} of processed response data
     */
    public static Map<String, Object> handleZwaveCmdNop(byte[] payload) {
        // Create our response map
        Map<String, Object> response = new HashMap<String, Object>();

        // Return the map of processed response data;
        return response;
    }

    /**
     * Creates a new message with the NODE_INFO command.<br>
     * <p>
     * Node Info<br>
     * <p>
     * SDS10264-2<br>
     *
     * @param protocolVersion {@link String}
     * @param maxBaudRate {@link String}
     * @param routing {@link Boolean}
     * @param listening {@link Boolean}
     * @param security {@link Boolean}
     * @param controller {@link Boolean}
     * @param specificDevice {@link Boolean}
     * @param routingSlave {@link Boolean}
     * @param beamCapability {@link Boolean}
     * @param sensor250ms {@link Boolean}
     * @param sensor1000ms {@link Boolean}
     * @param optionalFunctionality {@link Boolean}
     * @param speedExtension {@link String}
     * @return the {@link byte[]} array with the command to send
     */
    static public byte[] getNodeInfo(String protocolVersion, String maxBaudRate, Boolean routing, Boolean listening,
            Boolean security, Boolean controller, Boolean specificDevice, Boolean routingSlave, Boolean beamCapability,
            Boolean sensor250ms, Boolean sensor1000ms, Boolean optionalFunctionality, String speedExtension) {
        logger.debug("Creating command message NODE_INFO version 1");

        ByteArrayOutputStream outputData = new ByteArrayOutputStream();
        outputData.write(COMMAND_CLASS_KEY);
        outputData.write(NODE_INFO);

        // Process 'Capability'
        int valCapability = 0;
        int valprotocolVersion;
        switch (protocolVersion) {
            case "Z_WAVE_VERSION_2_0":
                valprotocolVersion = 1;
                break;
            case "Z_WAVE_VERSION_ZDK_5_0X,_ZDK_4_2X":
                valprotocolVersion = 2;
                break;
            case "Z_WAVE_VERSION_ZDK_4_5X_AND_ZDK_6_0X":
                valprotocolVersion = 3;
                break;
            default:
                throw new IllegalArgumentException("Unknown enum value for protocolVersion: " + protocolVersion);
        }
        valCapability |= valprotocolVersion & 0x07;
        int valmaxBaudRate;
        switch (maxBaudRate) {
            case "9_6_KBPS":
                valmaxBaudRate = 1;
                break;
            case "40_KBPS":
                valmaxBaudRate = 2;
                break;
            default:
                throw new IllegalArgumentException("Unknown enum value for maxBaudRate: " + maxBaudRate);
        }
        valCapability |= valmaxBaudRate >> 3 & 0x38;
        valCapability |= routing ? 0x40 : 0;
        valCapability |= listening ? 0x80 : 0;
        outputData.write(valCapability);

        // Process 'Security'
        int valSecurity = 0;
        valSecurity |= security ? 0x01 : 0;
        valSecurity |= controller ? 0x02 : 0;
        valSecurity |= specificDevice ? 0x04 : 0;
        valSecurity |= routingSlave ? 0x08 : 0;
        valSecurity |= beamCapability ? 0x10 : 0;
        valSecurity |= sensor250ms ? 0x20 : 0;
        valSecurity |= sensor1000ms ? 0x40 : 0;
        valSecurity |= optionalFunctionality ? 0x80 : 0;
        outputData.write(valSecurity);

        // Process 'Properties1'
        int valspeedExtension;
        switch (speedExtension) {
            case "100_KBPS":
                valspeedExtension = 1;
                break;
            case "200_KBPS":
                valspeedExtension = 2;
                break;
            default:
                throw new IllegalArgumentException("Unknown enum value for speedExtension: " + speedExtension);
        }
        outputData.write(valspeedExtension & 0x07);

        // Process 'Basic Device Class'

        // Process 'Generic Device Class'

        // Process 'Specific Device Class'

        // Process 'Command Classes'

        return outputData.toByteArray();
    }

    /**
     * Processes a received frame with the NODE_INFO command<br>
     * <p>
     * Node Info<br>
     * <p>
     * SDS10264-2<br>
     * <p>
     * The output data {@link Map} has the following properties<br>
     *
     * <ul>
     * <li>PROTOCOL_VERSION {@link String}
     * <li>MAX_BAUD_RATE {@link String}
     * <li>ROUTING {@link Boolean}
     * <li>LISTENING {@link Boolean}
     * <li>SECURITY {@link Boolean}
     * <li>CONTROLLER {@link Boolean}
     * <li>SPECIFIC_DEVICE {@link Boolean}
     * <li>ROUTING_SLAVE {@link Boolean}
     * <li>BEAM_CAPABILITY {@link Boolean}
     * <li>SENSOR_250MS {@link Boolean}
     * <li>SENSOR_1000MS {@link Boolean}
     * <li>OPTIONAL_FUNCTIONALITY {@link Boolean}
     * <li>SPEED_EXTENSION {@link String}
     * </ul>
     *
     * @param payload the {@link byte[]} payload data to process
     * @return a {@link Map} of processed response data
     */
    public static Map<String, Object> handleNodeInfo(byte[] payload) {
        // Create our response map
        Map<String, Object> response = new HashMap<String, Object>();

        // Process 'Capability'
        switch (payload[2] & 0x07) {
            case 0x01:
                response.put("PROTOCOL_VERSION", "Z_WAVE_VERSION_2_0");
                break;
            case 0x02:
                response.put("PROTOCOL_VERSION", "Z_WAVE_VERSION_ZDK_5_0X,_ZDK_4_2X");
                break;
            case 0x03:
                response.put("PROTOCOL_VERSION", "Z_WAVE_VERSION_ZDK_4_5X_AND_ZDK_6_0X");
                break;
            default:
                logger.debug("Unknown enum value {} for PROTOCOL_VERSION", String.format("0x%02X", 2));
        }
        switch ((payload[2] & 0x38) >> 3) {
            case 0x01:
                response.put("MAX_BAUD_RATE", "9_6_KBPS");
                break;
            case 0x02:
                response.put("MAX_BAUD_RATE", "40_KBPS");
                break;
            default:
                logger.debug("Unknown enum value {} for MAX_BAUD_RATE", String.format("0x%02X", 2));
        }
        response.put("ROUTING", Boolean.valueOf((payload[2] & 0x40) != 0));
        response.put("LISTENING", Boolean.valueOf((payload[2] & 0x80) != 0));

        // Process 'Security'
        response.put("SECURITY", Boolean.valueOf((payload[3] & 0x01) != 0));
        response.put("CONTROLLER", Boolean.valueOf((payload[3] & 0x02) != 0));
        response.put("SPECIFIC_DEVICE", Boolean.valueOf((payload[3] & 0x04) != 0));
        response.put("ROUTING_SLAVE", Boolean.valueOf((payload[3] & 0x08) != 0));
        response.put("BEAM_CAPABILITY", Boolean.valueOf((payload[3] & 0x10) != 0));
        response.put("SENSOR_250MS", Boolean.valueOf((payload[3] & 0x20) != 0));
        response.put("SENSOR_1000MS", Boolean.valueOf((payload[3] & 0x40) != 0));
        response.put("OPTIONAL_FUNCTIONALITY", Boolean.valueOf((payload[3] & 0x80) != 0));

        // Process 'Properties1'
        switch (payload[4] & 0x07) {
            case 0x01:
                response.put("SPEED_EXTENSION", "100_KBPS");
                break;
            case 0x02:
                response.put("SPEED_EXTENSION", "200_KBPS");
                break;
            default:
                logger.debug("Unknown enum value {} for SPEED_EXTENSION", String.format("0x%02X", 4));
        }

        // Process 'Basic Device Class'

        // Process 'Generic Device Class'

        // Process 'Specific Device Class'

        // Process 'Command Classes'

        // Return the map of processed response data;
        return response;
    }

    /**
     * Creates a new message with the REQUEST_NODE_INFO command.<br>
     * <p>
     * Request Node Info<br>
     * <p>
     * SDS10264-2<br>
     *
     * @return the {@link byte[]} array with the command to send
     */
    static public byte[] getRequestNodeInfo() {
        logger.debug("Creating command message REQUEST_NODE_INFO version 1");

        ByteArrayOutputStream outputData = new ByteArrayOutputStream();
        outputData.write(COMMAND_CLASS_KEY);
        outputData.write(REQUEST_NODE_INFO);

        return outputData.toByteArray();
    }

    /**
     * Processes a received frame with the REQUEST_NODE_INFO command<br>
     * <p>
     * Request Node Info<br>
     * <p>
     * SDS10264-2<br>
     *
     * @param payload the {@link byte[]} payload data to process
     * @return a {@link Map} of processed response data
     */
    public static Map<String, Object> handleRequestNodeInfo(byte[] payload) {
        // Create our response map
        Map<String, Object> response = new HashMap<String, Object>();

        // Return the map of processed response data;
        return response;
    }

    /**
     * Creates a new message with the ASSIGN_ID command.<br>
     * <p>
     * Assign Id<br>
     * <p>
     * SDS10264-2<br>
     *
     * @return the {@link byte[]} array with the command to send
     */
    static public byte[] getAssignId() {
        logger.debug("Creating command message ASSIGN_ID version 1");

        ByteArrayOutputStream outputData = new ByteArrayOutputStream();
        outputData.write(COMMAND_CLASS_KEY);
        outputData.write(ASSIGN_ID);

        return outputData.toByteArray();
    }

    /**
     * Processes a received frame with the ASSIGN_ID command<br>
     * <p>
     * Assign Id<br>
     * <p>
     * SDS10264-2<br>
     *
     * @param payload the {@link byte[]} payload data to process
     * @return a {@link Map} of processed response data
     */
    public static Map<String, Object> handleAssignId(byte[] payload) {
        // Create our response map
        Map<String, Object> response = new HashMap<String, Object>();

        // Return the map of processed response data;
        return response;
    }

    /**
     * Creates a new message with the FIND_NODES_IN_RANGE command.<br>
     * <p>
     * Find Nodes In Range<br>
     * <p>
     * SDS10264-2<br>
     *
     * @return the {@link byte[]} array with the command to send
     */
    static public byte[] getFindNodesInRange() {
        logger.debug("Creating command message FIND_NODES_IN_RANGE version 1");

        ByteArrayOutputStream outputData = new ByteArrayOutputStream();
        outputData.write(COMMAND_CLASS_KEY);
        outputData.write(FIND_NODES_IN_RANGE);

        return outputData.toByteArray();
    }

    /**
     * Processes a received frame with the FIND_NODES_IN_RANGE command<br>
     * <p>
     * Find Nodes In Range<br>
     * <p>
     * SDS10264-2<br>
     *
     * @param payload the {@link byte[]} payload data to process
     * @return a {@link Map} of processed response data
     */
    public static Map<String, Object> handleFindNodesInRange(byte[] payload) {
        // Create our response map
        Map<String, Object> response = new HashMap<String, Object>();

        // Return the map of processed response data;
        return response;
    }

    /**
     * Creates a new message with the GET_NODES_IN_RANGE command.<br>
     * <p>
     * Get Nodes In Range<br>
     * <p>
     * SDS10264-2<br>
     *
     * @return the {@link byte[]} array with the command to send
     */
    static public byte[] getGetNodesInRange() {
        logger.debug("Creating command message GET_NODES_IN_RANGE version 1");

        ByteArrayOutputStream outputData = new ByteArrayOutputStream();
        outputData.write(COMMAND_CLASS_KEY);
        outputData.write(GET_NODES_IN_RANGE);

        return outputData.toByteArray();
    }

    /**
     * Processes a received frame with the GET_NODES_IN_RANGE command<br>
     * <p>
     * Get Nodes In Range<br>
     * <p>
     * SDS10264-2<br>
     *
     * @param payload the {@link byte[]} payload data to process
     * @return a {@link Map} of processed response data
     */
    public static Map<String, Object> handleGetNodesInRange(byte[] payload) {
        // Create our response map
        Map<String, Object> response = new HashMap<String, Object>();

        // Return the map of processed response data;
        return response;
    }

    /**
     * Creates a new message with the NODE_RANGE_INFO command.<br>
     * <p>
     * Node Range Info<br>
     * <p>
     * SDS10264-2<br>
     *
     * @return the {@link byte[]} array with the command to send
     */
    static public byte[] getNodeRangeInfo() {
        logger.debug("Creating command message NODE_RANGE_INFO version 1");

        ByteArrayOutputStream outputData = new ByteArrayOutputStream();
        outputData.write(COMMAND_CLASS_KEY);
        outputData.write(NODE_RANGE_INFO);

        return outputData.toByteArray();
    }

    /**
     * Processes a received frame with the NODE_RANGE_INFO command<br>
     * <p>
     * Node Range Info<br>
     * <p>
     * SDS10264-2<br>
     *
     * @param payload the {@link byte[]} payload data to process
     * @return a {@link Map} of processed response data
     */
    public static Map<String, Object> handleNodeRangeInfo(byte[] payload) {
        // Create our response map
        Map<String, Object> response = new HashMap<String, Object>();

        // Return the map of processed response data;
        return response;
    }

    /**
     * Creates a new message with the COMMAND_COMPLETE command.<br>
     * <p>
     * Command Complete<br>
     * <p>
     * SDS10264-2<br>
     *
     * @return the {@link byte[]} array with the command to send
     */
    static public byte[] getCommandComplete() {
        logger.debug("Creating command message COMMAND_COMPLETE version 1");

        ByteArrayOutputStream outputData = new ByteArrayOutputStream();
        outputData.write(COMMAND_CLASS_KEY);
        outputData.write(COMMAND_COMPLETE);

        return outputData.toByteArray();
    }

    /**
     * Processes a received frame with the COMMAND_COMPLETE command<br>
     * <p>
     * Command Complete<br>
     * <p>
     * SDS10264-2<br>
     *
     * @param payload the {@link byte[]} payload data to process
     * @return a {@link Map} of processed response data
     */
    public static Map<String, Object> handleCommandComplete(byte[] payload) {
        // Create our response map
        Map<String, Object> response = new HashMap<String, Object>();

        // Return the map of processed response data;
        return response;
    }

    /**
     * Creates a new message with the TRANSFER_PRESENTATION command.<br>
     * <p>
     * Transfer Presentation<br>
     * <p>
     * SDS10264-2<br>
     *
     * @return the {@link byte[]} array with the command to send
     */
    static public byte[] getTransferPresentation() {
        logger.debug("Creating command message TRANSFER_PRESENTATION version 1");

        ByteArrayOutputStream outputData = new ByteArrayOutputStream();
        outputData.write(COMMAND_CLASS_KEY);
        outputData.write(TRANSFER_PRESENTATION);

        return outputData.toByteArray();
    }

    /**
     * Processes a received frame with the TRANSFER_PRESENTATION command<br>
     * <p>
     * Transfer Presentation<br>
     * <p>
     * SDS10264-2<br>
     *
     * @param payload the {@link byte[]} payload data to process
     * @return a {@link Map} of processed response data
     */
    public static Map<String, Object> handleTransferPresentation(byte[] payload) {
        // Create our response map
        Map<String, Object> response = new HashMap<String, Object>();

        // Return the map of processed response data;
        return response;
    }

    /**
     * Creates a new message with the TRANSFER_NODE_INFO command.<br>
     * <p>
     * Transfer Node Info<br>
     * <p>
     * SDS10264-2<br>
     *
     * @return the {@link byte[]} array with the command to send
     */
    static public byte[] getTransferNodeInfo() {
        logger.debug("Creating command message TRANSFER_NODE_INFO version 1");

        ByteArrayOutputStream outputData = new ByteArrayOutputStream();
        outputData.write(COMMAND_CLASS_KEY);
        outputData.write(TRANSFER_NODE_INFO);

        return outputData.toByteArray();
    }

    /**
     * Processes a received frame with the TRANSFER_NODE_INFO command<br>
     * <p>
     * Transfer Node Info<br>
     * <p>
     * SDS10264-2<br>
     *
     * @param payload the {@link byte[]} payload data to process
     * @return a {@link Map} of processed response data
     */
    public static Map<String, Object> handleTransferNodeInfo(byte[] payload) {
        // Create our response map
        Map<String, Object> response = new HashMap<String, Object>();

        // Return the map of processed response data;
        return response;
    }

    /**
     * Creates a new message with the TRANSFER_RANGE_INFO command.<br>
     * <p>
     * Transfer Range Info<br>
     * <p>
     * SDS10264-2<br>
     *
     * @return the {@link byte[]} array with the command to send
     */
    static public byte[] getTransferRangeInfo() {
        logger.debug("Creating command message TRANSFER_RANGE_INFO version 1");

        ByteArrayOutputStream outputData = new ByteArrayOutputStream();
        outputData.write(COMMAND_CLASS_KEY);
        outputData.write(TRANSFER_RANGE_INFO);

        return outputData.toByteArray();
    }

    /**
     * Processes a received frame with the TRANSFER_RANGE_INFO command<br>
     * <p>
     * Transfer Range Info<br>
     * <p>
     * SDS10264-2<br>
     *
     * @param payload the {@link byte[]} payload data to process
     * @return a {@link Map} of processed response data
     */
    public static Map<String, Object> handleTransferRangeInfo(byte[] payload) {
        // Create our response map
        Map<String, Object> response = new HashMap<String, Object>();

        // Return the map of processed response data;
        return response;
    }

    /**
     * Creates a new message with the TRANSFER_END command.<br>
     * <p>
     * Transfer End<br>
     * <p>
     * SDS10264-2<br>
     *
     * @return the {@link byte[]} array with the command to send
     */
    static public byte[] getTransferEnd() {
        logger.debug("Creating command message TRANSFER_END version 1");

        ByteArrayOutputStream outputData = new ByteArrayOutputStream();
        outputData.write(COMMAND_CLASS_KEY);
        outputData.write(TRANSFER_END);

        return outputData.toByteArray();
    }

    /**
     * Processes a received frame with the TRANSFER_END command<br>
     * <p>
     * Transfer End<br>
     * <p>
     * SDS10264-2<br>
     *
     * @param payload the {@link byte[]} payload data to process
     * @return a {@link Map} of processed response data
     */
    public static Map<String, Object> handleTransferEnd(byte[] payload) {
        // Create our response map
        Map<String, Object> response = new HashMap<String, Object>();

        // Return the map of processed response data;
        return response;
    }

    /**
     * Creates a new message with the ASSIGN_RETURN_ROUTE command.<br>
     * <p>
     * Assign Return Route<br>
     * <p>
     * SDS10264-2<br>
     *
     * @return the {@link byte[]} array with the command to send
     */
    static public byte[] getAssignReturnRoute() {
        logger.debug("Creating command message ASSIGN_RETURN_ROUTE version 1");

        ByteArrayOutputStream outputData = new ByteArrayOutputStream();
        outputData.write(COMMAND_CLASS_KEY);
        outputData.write(ASSIGN_RETURN_ROUTE);

        return outputData.toByteArray();
    }

    /**
     * Processes a received frame with the ASSIGN_RETURN_ROUTE command<br>
     * <p>
     * Assign Return Route<br>
     * <p>
     * SDS10264-2<br>
     *
     * @param payload the {@link byte[]} payload data to process
     * @return a {@link Map} of processed response data
     */
    public static Map<String, Object> handleAssignReturnRoute(byte[] payload) {
        // Create our response map
        Map<String, Object> response = new HashMap<String, Object>();

        // Return the map of processed response data;
        return response;
    }

    /**
     * Creates a new message with the NEW_NODE_REGISTERED command.<br>
     * <p>
     * New Node Registered<br>
     * <p>
     * SDS10264-2<br>
     *
     * @return the {@link byte[]} array with the command to send
     */
    static public byte[] getNewNodeRegistered() {
        logger.debug("Creating command message NEW_NODE_REGISTERED version 1");

        ByteArrayOutputStream outputData = new ByteArrayOutputStream();
        outputData.write(COMMAND_CLASS_KEY);
        outputData.write(NEW_NODE_REGISTERED);

        return outputData.toByteArray();
    }

    /**
     * Processes a received frame with the NEW_NODE_REGISTERED command<br>
     * <p>
     * New Node Registered<br>
     * <p>
     * SDS10264-2<br>
     *
     * @param payload the {@link byte[]} payload data to process
     * @return a {@link Map} of processed response data
     */
    public static Map<String, Object> handleNewNodeRegistered(byte[] payload) {
        // Create our response map
        Map<String, Object> response = new HashMap<String, Object>();

        // Return the map of processed response data;
        return response;
    }

    /**
     * Creates a new message with the NEW_RANGE_REGISTERED command.<br>
     * <p>
     * New Range Registered<br>
     * <p>
     * SDS10264-2<br>
     *
     * @return the {@link byte[]} array with the command to send
     */
    static public byte[] getNewRangeRegistered() {
        logger.debug("Creating command message NEW_RANGE_REGISTERED version 1");

        ByteArrayOutputStream outputData = new ByteArrayOutputStream();
        outputData.write(COMMAND_CLASS_KEY);
        outputData.write(NEW_RANGE_REGISTERED);

        return outputData.toByteArray();
    }

    /**
     * Processes a received frame with the NEW_RANGE_REGISTERED command<br>
     * <p>
     * New Range Registered<br>
     * <p>
     * SDS10264-2<br>
     *
     * @param payload the {@link byte[]} payload data to process
     * @return a {@link Map} of processed response data
     */
    public static Map<String, Object> handleNewRangeRegistered(byte[] payload) {
        // Create our response map
        Map<String, Object> response = new HashMap<String, Object>();

        // Return the map of processed response data;
        return response;
    }

    /**
     * Creates a new message with the TRANSFER_NEW_PRIMARY_COMPLETE command.<br>
     * <p>
     * Transfer New Primary Complete<br>
     * <p>
     * SDS10264-2<br>
     *
     * @return the {@link byte[]} array with the command to send
     */
    static public byte[] getTransferNewPrimaryComplete() {
        logger.debug("Creating command message TRANSFER_NEW_PRIMARY_COMPLETE version 1");

        ByteArrayOutputStream outputData = new ByteArrayOutputStream();
        outputData.write(COMMAND_CLASS_KEY);
        outputData.write(TRANSFER_NEW_PRIMARY_COMPLETE);

        return outputData.toByteArray();
    }

    /**
     * Processes a received frame with the TRANSFER_NEW_PRIMARY_COMPLETE command<br>
     * <p>
     * Transfer New Primary Complete<br>
     * <p>
     * SDS10264-2<br>
     *
     * @param payload the {@link byte[]} payload data to process
     * @return a {@link Map} of processed response data
     */
    public static Map<String, Object> handleTransferNewPrimaryComplete(byte[] payload) {
        // Create our response map
        Map<String, Object> response = new HashMap<String, Object>();

        // Return the map of processed response data;
        return response;
    }

    /**
     * Creates a new message with the CMD_AUTOMATIC_CONTROLLER_UPDATE_START command.<br>
     * <p>
     * Automatic Controller Update Start<br>
     *
     * @return the {@link byte[]} array with the command to send
     */
    static public byte[] getCmdAutomaticControllerUpdateStart() {
        logger.debug("Creating command message CMD_AUTOMATIC_CONTROLLER_UPDATE_START version 1");

        ByteArrayOutputStream outputData = new ByteArrayOutputStream();
        outputData.write(COMMAND_CLASS_KEY);
        outputData.write(CMD_AUTOMATIC_CONTROLLER_UPDATE_START);

        return outputData.toByteArray();
    }

    /**
     * Processes a received frame with the CMD_AUTOMATIC_CONTROLLER_UPDATE_START command<br>
     * <p>
     * Automatic Controller Update Start<br>
     *
     * @param payload the {@link byte[]} payload data to process
     * @return a {@link Map} of processed response data
     */
    public static Map<String, Object> handleCmdAutomaticControllerUpdateStart(byte[] payload) {
        // Create our response map
        Map<String, Object> response = new HashMap<String, Object>();

        // Return the map of processed response data;
        return response;
    }

    /**
     * Creates a new message with the CMD_SUC_NODE_ID command.<br>
     * <p>
     * SUC Node ID<br>
     *
     * @return the {@link byte[]} array with the command to send
     */
    static public byte[] getCmdSucNodeId() {
        logger.debug("Creating command message CMD_SUC_NODE_ID version 1");

        ByteArrayOutputStream outputData = new ByteArrayOutputStream();
        outputData.write(COMMAND_CLASS_KEY);
        outputData.write(CMD_SUC_NODE_ID);

        return outputData.toByteArray();
    }

    /**
     * Processes a received frame with the CMD_SUC_NODE_ID command<br>
     * <p>
     * SUC Node ID<br>
     *
     * @param payload the {@link byte[]} payload data to process
     * @return a {@link Map} of processed response data
     */
    public static Map<String, Object> handleCmdSucNodeId(byte[] payload) {
        // Create our response map
        Map<String, Object> response = new HashMap<String, Object>();

        // Return the map of processed response data;
        return response;
    }

    /**
     * Creates a new message with the CMD_SET_SUC command.<br>
     * <p>
     * Set SUC<br>
     *
     * @return the {@link byte[]} array with the command to send
     */
    static public byte[] getCmdSetSuc() {
        logger.debug("Creating command message CMD_SET_SUC version 1");

        ByteArrayOutputStream outputData = new ByteArrayOutputStream();
        outputData.write(COMMAND_CLASS_KEY);
        outputData.write(CMD_SET_SUC);

        return outputData.toByteArray();
    }

    /**
     * Processes a received frame with the CMD_SET_SUC command<br>
     * <p>
     * Set SUC<br>
     *
     * @param payload the {@link byte[]} payload data to process
     * @return a {@link Map} of processed response data
     */
    public static Map<String, Object> handleCmdSetSuc(byte[] payload) {
        // Create our response map
        Map<String, Object> response = new HashMap<String, Object>();

        // Return the map of processed response data;
        return response;
    }

    /**
     * Creates a new message with the CMD_SET_SUC_ACK command.<br>
     * <p>
     * Set SUC ACK<br>
     *
     * @return the {@link byte[]} array with the command to send
     */
    static public byte[] getCmdSetSucAck() {
        logger.debug("Creating command message CMD_SET_SUC_ACK version 1");

        ByteArrayOutputStream outputData = new ByteArrayOutputStream();
        outputData.write(COMMAND_CLASS_KEY);
        outputData.write(CMD_SET_SUC_ACK);

        return outputData.toByteArray();
    }

    /**
     * Processes a received frame with the CMD_SET_SUC_ACK command<br>
     * <p>
     * Set SUC ACK<br>
     *
     * @param payload the {@link byte[]} payload data to process
     * @return a {@link Map} of processed response data
     */
    public static Map<String, Object> handleCmdSetSucAck(byte[] payload) {
        // Create our response map
        Map<String, Object> response = new HashMap<String, Object>();

        // Return the map of processed response data;
        return response;
    }

    /**
     * Creates a new message with the CMD_ASSIGN_SUC_RETURN_ROUTE command.<br>
     * <p>
     * Assign SUC Return Route<br>
     *
     * @return the {@link byte[]} array with the command to send
     */
    static public byte[] getCmdAssignSucReturnRoute() {
        logger.debug("Creating command message CMD_ASSIGN_SUC_RETURN_ROUTE version 1");

        ByteArrayOutputStream outputData = new ByteArrayOutputStream();
        outputData.write(COMMAND_CLASS_KEY);
        outputData.write(CMD_ASSIGN_SUC_RETURN_ROUTE);

        return outputData.toByteArray();
    }

    /**
     * Processes a received frame with the CMD_ASSIGN_SUC_RETURN_ROUTE command<br>
     * <p>
     * Assign SUC Return Route<br>
     *
     * @param payload the {@link byte[]} payload data to process
     * @return a {@link Map} of processed response data
     */
    public static Map<String, Object> handleCmdAssignSucReturnRoute(byte[] payload) {
        // Create our response map
        Map<String, Object> response = new HashMap<String, Object>();

        // Return the map of processed response data;
        return response;
    }

    /**
     * Creates a new message with the CMD_STATIC_ROUTE_REQUEST command.<br>
     * <p>
     * Static Route Request<br>
     *
     * @return the {@link byte[]} array with the command to send
     */
    static public byte[] getCmdStaticRouteRequest() {
        logger.debug("Creating command message CMD_STATIC_ROUTE_REQUEST version 1");

        ByteArrayOutputStream outputData = new ByteArrayOutputStream();
        outputData.write(COMMAND_CLASS_KEY);
        outputData.write(CMD_STATIC_ROUTE_REQUEST);

        return outputData.toByteArray();
    }

    /**
     * Processes a received frame with the CMD_STATIC_ROUTE_REQUEST command<br>
     * <p>
     * Static Route Request<br>
     *
     * @param payload the {@link byte[]} payload data to process
     * @return a {@link Map} of processed response data
     */
    public static Map<String, Object> handleCmdStaticRouteRequest(byte[] payload) {
        // Create our response map
        Map<String, Object> response = new HashMap<String, Object>();

        // Return the map of processed response data;
        return response;
    }

    /**
     * Creates a new message with the LOST command.<br>
     * <p>
     * Lost<br>
     * <p>
     * SDS10264-2<br>
     *
     * @return the {@link byte[]} array with the command to send
     */
    static public byte[] getLost() {
        logger.debug("Creating command message LOST version 1");

        ByteArrayOutputStream outputData = new ByteArrayOutputStream();
        outputData.write(COMMAND_CLASS_KEY);
        outputData.write(LOST);

        return outputData.toByteArray();
    }

    /**
     * Processes a received frame with the LOST command<br>
     * <p>
     * Lost<br>
     * <p>
     * SDS10264-2<br>
     *
     * @param payload the {@link byte[]} payload data to process
     * @return a {@link Map} of processed response data
     */
    public static Map<String, Object> handleLost(byte[] payload) {
        // Create our response map
        Map<String, Object> response = new HashMap<String, Object>();

        // Return the map of processed response data;
        return response;
    }

    /**
     * Creates a new message with the ACCEPT_LOST command.<br>
     * <p>
     * Accept Lost<br>
     * <p>
     * SDS10264-2<br>
     *
     * @return the {@link byte[]} array with the command to send
     */
    static public byte[] getAcceptLost() {
        logger.debug("Creating command message ACCEPT_LOST version 1");

        ByteArrayOutputStream outputData = new ByteArrayOutputStream();
        outputData.write(COMMAND_CLASS_KEY);
        outputData.write(ACCEPT_LOST);

        return outputData.toByteArray();
    }

    /**
     * Processes a received frame with the ACCEPT_LOST command<br>
     * <p>
     * Accept Lost<br>
     * <p>
     * SDS10264-2<br>
     *
     * @param payload the {@link byte[]} payload data to process
     * @return a {@link Map} of processed response data
     */
    public static Map<String, Object> handleAcceptLost(byte[] payload) {
        // Create our response map
        Map<String, Object> response = new HashMap<String, Object>();

        // Return the map of processed response data;
        return response;
    }

    /**
     * Creates a new message with the CMD_NOP_POWER command.<br>
     * <p>
     * NOP Power<br>
     *
     * @return the {@link byte[]} array with the command to send
     */
    static public byte[] getCmdNopPower() {
        logger.debug("Creating command message CMD_NOP_POWER version 1");

        ByteArrayOutputStream outputData = new ByteArrayOutputStream();
        outputData.write(COMMAND_CLASS_KEY);
        outputData.write(CMD_NOP_POWER);

        return outputData.toByteArray();
    }

    /**
     * Processes a received frame with the CMD_NOP_POWER command<br>
     * <p>
     * NOP Power<br>
     *
     * @param payload the {@link byte[]} payload data to process
     * @return a {@link Map} of processed response data
     */
    public static Map<String, Object> handleCmdNopPower(byte[] payload) {
        // Create our response map
        Map<String, Object> response = new HashMap<String, Object>();

        // Return the map of processed response data;
        return response;
    }

    /**
     * Creates a new message with the ZWAVE_CMD_RESERVE_NODE_IDS command.<br>
     * <p>
     * Reserve Node ID<br>
     *
     * @return the {@link byte[]} array with the command to send
     */
    static public byte[] getZwaveCmdReserveNodeIds() {
        logger.debug("Creating command message ZWAVE_CMD_RESERVE_NODE_IDS version 1");

        ByteArrayOutputStream outputData = new ByteArrayOutputStream();
        outputData.write(COMMAND_CLASS_KEY);
        outputData.write(ZWAVE_CMD_RESERVE_NODE_IDS);

        return outputData.toByteArray();
    }

    /**
     * Processes a received frame with the ZWAVE_CMD_RESERVE_NODE_IDS command<br>
     * <p>
     * Reserve Node ID<br>
     *
     * @param payload the {@link byte[]} payload data to process
     * @return a {@link Map} of processed response data
     */
    public static Map<String, Object> handleZwaveCmdReserveNodeIds(byte[] payload) {
        // Create our response map
        Map<String, Object> response = new HashMap<String, Object>();

        // Return the map of processed response data;
        return response;
    }

    /**
     * Creates a new message with the CMD_RESERVED_IDS command.<br>
     * <p>
     * Reserved ID<br>
     *
     * @return the {@link byte[]} array with the command to send
     */
    static public byte[] getCmdReservedIds() {
        logger.debug("Creating command message CMD_RESERVED_IDS version 1");

        ByteArrayOutputStream outputData = new ByteArrayOutputStream();
        outputData.write(COMMAND_CLASS_KEY);
        outputData.write(CMD_RESERVED_IDS);

        return outputData.toByteArray();
    }

    /**
     * Processes a received frame with the CMD_RESERVED_IDS command<br>
     * <p>
     * Reserved ID<br>
     *
     * @param payload the {@link byte[]} payload data to process
     * @return a {@link Map} of processed response data
     */
    public static Map<String, Object> handleCmdReservedIds(byte[] payload) {
        // Create our response map
        Map<String, Object> response = new HashMap<String, Object>();

        // Return the map of processed response data;
        return response;
    }

    /**
     * Creates a new message with the CMD_NODES_EXIST command.<br>
     * <p>
     * Cmd Nodes Exist<br>
     *
     * @return the {@link byte[]} array with the command to send
     */
    static public byte[] getCmdNodesExist() {
        logger.debug("Creating command message CMD_NODES_EXIST version 1");

        ByteArrayOutputStream outputData = new ByteArrayOutputStream();
        outputData.write(COMMAND_CLASS_KEY);
        outputData.write(CMD_NODES_EXIST);

        return outputData.toByteArray();
    }

    /**
     * Processes a received frame with the CMD_NODES_EXIST command<br>
     * <p>
     * Cmd Nodes Exist<br>
     *
     * @param payload the {@link byte[]} payload data to process
     * @return a {@link Map} of processed response data
     */
    public static Map<String, Object> handleCmdNodesExist(byte[] payload) {
        // Create our response map
        Map<String, Object> response = new HashMap<String, Object>();

        // Return the map of processed response data;
        return response;
    }

    /**
     * Creates a new message with the CMD_NODES_EXIST_REPLY command.<br>
     * <p>
     * Cmd Nodes Exist Reply<br>
     *
     * @return the {@link byte[]} array with the command to send
     */
    static public byte[] getCmdNodesExistReply() {
        logger.debug("Creating command message CMD_NODES_EXIST_REPLY version 1");

        ByteArrayOutputStream outputData = new ByteArrayOutputStream();
        outputData.write(COMMAND_CLASS_KEY);
        outputData.write(CMD_NODES_EXIST_REPLY);

        return outputData.toByteArray();
    }

    /**
     * Processes a received frame with the CMD_NODES_EXIST_REPLY command<br>
     * <p>
     * Cmd Nodes Exist Reply<br>
     *
     * @param payload the {@link byte[]} payload data to process
     * @return a {@link Map} of processed response data
     */
    public static Map<String, Object> handleCmdNodesExistReply(byte[] payload) {
        // Create our response map
        Map<String, Object> response = new HashMap<String, Object>();

        // Return the map of processed response data;
        return response;
    }

    /**
     * Creates a new message with the CMD_SET_NWI_MODE command.<br>
     * <p>
     * Cmd Set Nwi Mode<br>
     *
     * @return the {@link byte[]} array with the command to send
     */
    static public byte[] getCmdSetNwiMode() {
        logger.debug("Creating command message CMD_SET_NWI_MODE version 1");

        ByteArrayOutputStream outputData = new ByteArrayOutputStream();
        outputData.write(COMMAND_CLASS_KEY);
        outputData.write(CMD_SET_NWI_MODE);

        return outputData.toByteArray();
    }

    /**
     * Processes a received frame with the CMD_SET_NWI_MODE command<br>
     * <p>
     * Cmd Set Nwi Mode<br>
     *
     * @param payload the {@link byte[]} payload data to process
     * @return a {@link Map} of processed response data
     */
    public static Map<String, Object> handleCmdSetNwiMode(byte[] payload) {
        // Create our response map
        Map<String, Object> response = new HashMap<String, Object>();

        // Return the map of processed response data;
        return response;
    }

    /**
     * Creates a new message with the EXCLUDE_REQUEST command.<br>
     * <p>
     * Exclude Request<br>
     * <p>
     * INS13044<br>
     *
     * @return the {@link byte[]} array with the command to send
     */
    static public byte[] getExcludeRequest() {
        logger.debug("Creating command message EXCLUDE_REQUEST version 1");

        ByteArrayOutputStream outputData = new ByteArrayOutputStream();
        outputData.write(COMMAND_CLASS_KEY);
        outputData.write(EXCLUDE_REQUEST);

        return outputData.toByteArray();
    }

    /**
     * Processes a received frame with the EXCLUDE_REQUEST command<br>
     * <p>
     * Exclude Request<br>
     * <p>
     * INS13044<br>
     *
     * @param payload the {@link byte[]} payload data to process
     * @return a {@link Map} of processed response data
     */
    public static Map<String, Object> handleExcludeRequest(byte[] payload) {
        // Create our response map
        Map<String, Object> response = new HashMap<String, Object>();

        // Return the map of processed response data;
        return response;
    }

    /**
     * Creates a new message with the ASSIGN_RETURN_ROUTE_PRIORITY command.<br>
     * <p>
     * Assign Return Route Priority<br>
     *
     * @return the {@link byte[]} array with the command to send
     */
    static public byte[] getAssignReturnRoutePriority() {
        logger.debug("Creating command message ASSIGN_RETURN_ROUTE_PRIORITY version 1");

        ByteArrayOutputStream outputData = new ByteArrayOutputStream();
        outputData.write(COMMAND_CLASS_KEY);
        outputData.write(ASSIGN_RETURN_ROUTE_PRIORITY);

        return outputData.toByteArray();
    }

    /**
     * Processes a received frame with the ASSIGN_RETURN_ROUTE_PRIORITY command<br>
     * <p>
     * Assign Return Route Priority<br>
     *
     * @param payload the {@link byte[]} payload data to process
     * @return a {@link Map} of processed response data
     */
    public static Map<String, Object> handleAssignReturnRoutePriority(byte[] payload) {
        // Create our response map
        Map<String, Object> response = new HashMap<String, Object>();

        // Return the map of processed response data;
        return response;
    }

    /**
     * Creates a new message with the ASSIGN_SUC_RETURN_ROUTE_PRIORITY command.<br>
     * <p>
     * Assign SUC Return Route Priority<br>
     *
     * @return the {@link byte[]} array with the command to send
     */
    static public byte[] getAssignSucReturnRoutePriority() {
        logger.debug("Creating command message ASSIGN_SUC_RETURN_ROUTE_PRIORITY version 1");

        ByteArrayOutputStream outputData = new ByteArrayOutputStream();
        outputData.write(COMMAND_CLASS_KEY);
        outputData.write(ASSIGN_SUC_RETURN_ROUTE_PRIORITY);

        return outputData.toByteArray();
    }

    /**
     * Processes a received frame with the ASSIGN_SUC_RETURN_ROUTE_PRIORITY command<br>
     * <p>
     * Assign SUC Return Route Priority<br>
     *
     * @param payload the {@link byte[]} payload data to process
     * @return a {@link Map} of processed response data
     */
    public static Map<String, Object> handleAssignSucReturnRoutePriority(byte[] payload) {
        // Create our response map
        Map<String, Object> response = new HashMap<String, Object>();

        // Return the map of processed response data;
        return response;
    }

}
