/**
 * Copyright (c) 2016-2017 by the respective copyright holders.
 *
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Eclipse Public License v1.0
 * which accompanies this distribution, and is available at
 * http://www.eclipse.org/legal/epl-v10.html
 */
package com.zsmartsystems.zwave.commandclass.impl.loopback;

import static org.junit.Assert.assertEquals;

import java.util.Map;
import java.util.List;
import com.zsmartsystems.zwave.commandclass.impl.CommandClassScheduleV1;

/**
 * Class to implement loopback tests for command class <b>COMMAND_CLASS_SCHEDULE</b> version <b>1</b>.
 * <p>
 * Note that this code is autogenerated. Manual changes may be overwritten.
 *
 * @author Chris Jackson - Initial contribution of Java code generator
 */
public class CommandClassScheduleV1LoopbackTest {
    /**
     * Performs an in/out test of the SCHEDULE_SUPPORTED_REPORT command.
     * <p>
     * Test is designed to ensure that the command generates the same data
     * as the handler processes and is mainly a check of the code generator.
     *
     * @param numberOfSupportedScheduleId {@link Integer}
     * @param startTimeSupport {@link Integer}
     * @param fallbackSupport {@link Boolean}
     * @param supportEnableDisable {@link Boolean}
     * @param numberOfSupportedCc {@link Integer}
     * @param supportedOverrideTypes {@link Integer}
     * @param overrideSupport {@link Boolean}
     */
    public static void testScheduleSupportedReportLoopback(Integer numberOfSupportedScheduleId, Integer startTimeSupport,
            Boolean fallbackSupport, Boolean supportEnableDisable, Integer numberOfSupportedCc,
            Integer supportedOverrideTypes, Boolean overrideSupport) {
        byte[] testPayload = CommandClassScheduleV1.getScheduleSupportedReport(numberOfSupportedScheduleId,
                startTimeSupport, fallbackSupport, supportEnableDisable, numberOfSupportedCc, supportedOverrideTypes,
                overrideSupport);

        Map<String, Object> response = CommandClassScheduleV1.handleScheduleSupportedReport(testPayload);
        assertEquals(numberOfSupportedScheduleId, (Integer) response.get("NUMBER_OF_SUPPORTED_SCHEDULE_ID"));
        assertEquals(startTimeSupport, (Integer) response.get("START_TIME_SUPPORT"));
        assertEquals(fallbackSupport, (Boolean) response.get("FALLBACK_SUPPORT"));
        assertEquals(supportEnableDisable, (Boolean) response.get("SUPPORT_ENABLE_DISABLE"));
        assertEquals(numberOfSupportedCc, (Integer) response.get("NUMBER_OF_SUPPORTED_CC"));
        assertEquals(supportedOverrideTypes, (Integer) response.get("SUPPORTED_OVERRIDE_TYPES"));
        assertEquals(overrideSupport, (Boolean) response.get("OVERRIDE_SUPPORT"));
    }

    /**
     * Performs an in/out test of the COMMAND_SCHEDULE_SET command.
     * <p>
     * Test is designed to ensure that the command generates the same data
     * as the handler processes and is mainly a check of the code generator.
     *
     * @param scheduleId {@link Integer}
     * @param userIdentifier {@link Integer}
     * @param startYear {@link Integer}
     * @param startMonth {@link Integer}
     * @param startDayOfMonth {@link Integer}
     * @param startWeekday {@link Integer}
     * @param res {@link Boolean}
     * @param startHour {@link Integer}
     * @param durationType {@link Integer}
     * @param startMinute {@link Integer}
     * @param durationByte {@link Integer}
     * @param reportsToFollow {@link Integer}
     * @param numberOfCmdToFollow {@link Integer}
     */
    public static void testCommandScheduleSetLoopback(Integer scheduleId, Integer userIdentifier, Integer startYear,
            Integer startMonth, Integer startDayOfMonth, Integer startWeekday, Boolean res, Integer startHour,
            Integer durationType, Integer startMinute, Integer durationByte, Integer reportsToFollow,
            Integer numberOfCmdToFollow) {
        byte[] testPayload = CommandClassScheduleV1.getCommandScheduleSet(scheduleId, userIdentifier, startYear,
                startMonth, startDayOfMonth, startWeekday, res, startHour, durationType, startMinute, durationByte,
                reportsToFollow, numberOfCmdToFollow);

        Map<String, Object> response = CommandClassScheduleV1.handleCommandScheduleSet(testPayload);
        assertEquals(scheduleId, (Integer) response.get("SCHEDULE_ID"));
        assertEquals(userIdentifier, (Integer) response.get("USER_IDENTIFIER"));
        assertEquals(startYear, (Integer) response.get("START_YEAR"));
        assertEquals(startMonth, (Integer) response.get("START_MONTH"));
        assertEquals(startDayOfMonth, (Integer) response.get("START_DAY_OF_MONTH"));
        assertEquals(startWeekday, (Integer) response.get("START_WEEKDAY"));
        assertEquals(res, (Boolean) response.get("RES"));
        assertEquals(startHour, (Integer) response.get("START_HOUR"));
        assertEquals(durationType, (Integer) response.get("DURATION_TYPE"));
        assertEquals(startMinute, (Integer) response.get("START_MINUTE"));
        assertEquals(durationByte, (Integer) response.get("DURATION_BYTE"));
        assertEquals(reportsToFollow, (Integer) response.get("REPORTS_TO_FOLLOW"));
        assertEquals(numberOfCmdToFollow, (Integer) response.get("NUMBER_OF_CMD_TO_FOLLOW"));
    }

    /**
     * Performs an in/out test of the COMMAND_SCHEDULE_GET command.
     * <p>
     * Test is designed to ensure that the command generates the same data
     * as the handler processes and is mainly a check of the code generator.
     *
     * @param scheduleId {@link Integer}
     */
    public static void testCommandScheduleGetLoopback(Integer scheduleId) {
        byte[] testPayload = CommandClassScheduleV1.getCommandScheduleGet(scheduleId);

        Map<String, Object> response = CommandClassScheduleV1.handleCommandScheduleGet(testPayload);
        assertEquals(scheduleId, (Integer) response.get("SCHEDULE_ID"));
    }

    /**
     * Performs an in/out test of the COMMAND_SCHEDULE_REPORT command.
     * <p>
     * Test is designed to ensure that the command generates the same data
     * as the handler processes and is mainly a check of the code generator.
     *
     * @param scheduleId {@link Integer}
     * @param userIdentifier {@link Integer}
     * @param startYear {@link Integer}
     * @param startMonth {@link Integer}
     * @param activeId {@link Integer}
     * @param startDayOfMonth {@link Integer}
     * @param startWeekday {@link Integer}
     * @param res {@link Boolean}
     * @param startHour {@link Integer}
     * @param durationType {@link Integer}
     * @param startMinute {@link Integer}
     * @param durationByte {@link Integer}
     * @param reportsToFollow {@link Integer}
     * @param numberOfCmdToFollow {@link Integer}
     */
    public static void testCommandScheduleReportLoopback(Integer scheduleId, Integer userIdentifier, Integer startYear,
            Integer startMonth, Integer activeId, Integer startDayOfMonth, Integer startWeekday, Boolean res,
            Integer startHour, Integer durationType, Integer startMinute, Integer durationByte, Integer reportsToFollow,
            Integer numberOfCmdToFollow) {
        byte[] testPayload = CommandClassScheduleV1.getCommandScheduleReport(scheduleId, userIdentifier, startYear,
                startMonth, activeId, startDayOfMonth, startWeekday, res, startHour, durationType, startMinute,
                durationByte, reportsToFollow, numberOfCmdToFollow);

        Map<String, Object> response = CommandClassScheduleV1.handleCommandScheduleReport(testPayload);
        assertEquals(scheduleId, (Integer) response.get("SCHEDULE_ID"));
        assertEquals(userIdentifier, (Integer) response.get("USER_IDENTIFIER"));
        assertEquals(startYear, (Integer) response.get("START_YEAR"));
        assertEquals(startMonth, (Integer) response.get("START_MONTH"));
        assertEquals(activeId, (Integer) response.get("ACTIVE_ID"));
        assertEquals(startDayOfMonth, (Integer) response.get("START_DAY_OF_MONTH"));
        assertEquals(startWeekday, (Integer) response.get("START_WEEKDAY"));
        assertEquals(res, (Boolean) response.get("RES"));
        assertEquals(startHour, (Integer) response.get("START_HOUR"));
        assertEquals(durationType, (Integer) response.get("DURATION_TYPE"));
        assertEquals(startMinute, (Integer) response.get("START_MINUTE"));
        assertEquals(durationByte, (Integer) response.get("DURATION_BYTE"));
        assertEquals(reportsToFollow, (Integer) response.get("REPORTS_TO_FOLLOW"));
        assertEquals(numberOfCmdToFollow, (Integer) response.get("NUMBER_OF_CMD_TO_FOLLOW"));
    }

    /**
     * Performs an in/out test of the SCHEDULE_REMOVE command.
     * <p>
     * Test is designed to ensure that the command generates the same data
     * as the handler processes and is mainly a check of the code generator.
     *
     * @param scheduleId {@link Integer}
     */
    public static void testScheduleRemoveLoopback(Integer scheduleId) {
        byte[] testPayload = CommandClassScheduleV1.getScheduleRemove(scheduleId);

        Map<String, Object> response = CommandClassScheduleV1.handleScheduleRemove(testPayload);
        assertEquals(scheduleId, (Integer) response.get("SCHEDULE_ID"));
    }

    /**
     * Performs an in/out test of the SCHEDULE_STATE_SET command.
     * <p>
     * Test is designed to ensure that the command generates the same data
     * as the handler processes and is mainly a check of the code generator.
     *
     * @param scheduleId {@link Integer}
     * @param scheduleState {@link Integer}
     */
    public static void testScheduleStateSetLoopback(Integer scheduleId, Integer scheduleState) {
        byte[] testPayload = CommandClassScheduleV1.getScheduleStateSet(scheduleId, scheduleState);

        Map<String, Object> response = CommandClassScheduleV1.handleScheduleStateSet(testPayload);
        assertEquals(scheduleId, (Integer) response.get("SCHEDULE_ID"));
        assertEquals(scheduleState, (Integer) response.get("SCHEDULE_STATE"));
    }

    /**
     * Performs an in/out test of the SCHEDULE_STATE_REPORT command.
     * <p>
     * Test is designed to ensure that the command generates the same data
     * as the handler processes and is mainly a check of the code generator.
     *
     * @param numberOfSupportedScheduleId {@link Integer}
     * @param override {@link Boolean}
     * @param reportsToFollow {@link Integer}
     * @param activeId1 {@link Integer}
     * @param activeId2 {@link Integer}
     * @param activeId3 {@link Integer}
     * @param activeIdN {@link Integer}
     */
    public static void testScheduleStateReportLoopback(Integer numberOfSupportedScheduleId, Boolean override,
            Integer reportsToFollow, Integer activeId1, Integer activeId2, Integer activeId3, Integer activeIdN) {
        byte[] testPayload = CommandClassScheduleV1.getScheduleStateReport(numberOfSupportedScheduleId, override,
                reportsToFollow, activeId1, activeId2, activeId3, activeIdN);

        Map<String, Object> response = CommandClassScheduleV1.handleScheduleStateReport(testPayload);
        assertEquals(numberOfSupportedScheduleId, (Integer) response.get("NUMBER_OF_SUPPORTED_SCHEDULE_ID"));
        assertEquals(override, (Boolean) response.get("OVERRIDE"));
        assertEquals(reportsToFollow, (Integer) response.get("REPORTS_TO_FOLLOW"));
        assertEquals(activeId1, (Integer) response.get("ACTIVE_ID1"));
        assertEquals(activeId2, (Integer) response.get("ACTIVE_ID2"));
        assertEquals(activeId3, (Integer) response.get("ACTIVE_ID3"));
        assertEquals(activeIdN, (Integer) response.get("ACTIVE_ID_N"));
    }

}
