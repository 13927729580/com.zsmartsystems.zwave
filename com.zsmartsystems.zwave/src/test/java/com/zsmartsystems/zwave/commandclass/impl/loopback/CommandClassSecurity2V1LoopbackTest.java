/**
 * Copyright (c) 2016-2017 by the respective copyright holders.
 *
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Eclipse Public License v1.0
 * which accompanies this distribution, and is available at
 * http://www.eclipse.org/legal/epl-v10.html
 */
package com.zsmartsystems.zwave.commandclass.impl.loopback;

import static org.junit.Assert.assertEquals;

import java.util.Map;
import java.util.List;
import com.zsmartsystems.zwave.commandclass.impl.CommandClassSecurity2V1;

/**
 * Class to implement loopback tests for command class <b>COMMAND_CLASS_SECURITY_2</b> version <b>1</b>.
 * <p>
 * Note that this code is autogenerated. Manual changes may be overwritten.
 *
 * @author Chris Jackson - Initial contribution of Java code generator
 */
public class CommandClassSecurity2V1LoopbackTest {
    /**
     * Performs an in/out test of the SECURITY_2_NONCE_GET command.
     * <p>
     * Test is designed to ensure that the command generates the same data
     * as the handler processes and is mainly a check of the code generator.
     *
     * @param sequenceNumber {@link Integer}
     */
    public static void testSecurity2NonceGetLoopback(Integer sequenceNumber) {
        byte[] testPayload = CommandClassSecurity2V1.getSecurity2NonceGet(sequenceNumber);

        Map<String, Object> response = CommandClassSecurity2V1.handleSecurity2NonceGet(testPayload);
        assertEquals(sequenceNumber, (Integer) response.get("SEQUENCE_NUMBER"));
    }

    /**
     * Performs an in/out test of the SECURITY_2_NONCE_REPORT command.
     * <p>
     * Test is designed to ensure that the command generates the same data
     * as the handler processes and is mainly a check of the code generator.
     *
     * @param sequenceNumber {@link Integer}
     * @param sos {@link Boolean}
     * @param mos {@link Boolean}
     * @param receiversEntropyInput {@link byte[]}
     */
    public static void testSecurity2NonceReportLoopback(Integer sequenceNumber, Boolean sos, Boolean mos,
            byte[] receiversEntropyInput) {
        byte[] testPayload = CommandClassSecurity2V1.getSecurity2NonceReport(sequenceNumber, sos, mos,
                receiversEntropyInput);

        Map<String, Object> response = CommandClassSecurity2V1.handleSecurity2NonceReport(testPayload);
        assertEquals(sequenceNumber, (Integer) response.get("SEQUENCE_NUMBER"));
        assertEquals(sos, (Boolean) response.get("SOS"));
        assertEquals(mos, (Boolean) response.get("MOS"));
        assertEquals(receiversEntropyInput, (byte[]) response.get("RECEIVERS_ENTROPY_INPUT"));
    }

    /**
     * Performs an in/out test of the SECURITY_2_MESSAGE_ENCAPSULATION command.
     * <p>
     * Test is designed to ensure that the command generates the same data
     * as the handler processes and is mainly a check of the code generator.
     *
     * @param sequenceNumber {@link Integer}
     * @param extension {@link Boolean}
     * @param encryptedExtension {@link Boolean}
     * @param ccmCiphertextObject {@link byte[]}
     */
    public static void testSecurity2MessageEncapsulationLoopback(Integer sequenceNumber, Boolean extension,
            Boolean encryptedExtension, byte[] ccmCiphertextObject) {
        byte[] testPayload = CommandClassSecurity2V1.getSecurity2MessageEncapsulation(sequenceNumber, extension,
                encryptedExtension, ccmCiphertextObject);

        Map<String, Object> response = CommandClassSecurity2V1.handleSecurity2MessageEncapsulation(testPayload);
        assertEquals(sequenceNumber, (Integer) response.get("SEQUENCE_NUMBER"));
        assertEquals(extension, (Boolean) response.get("EXTENSION"));
        assertEquals(encryptedExtension, (Boolean) response.get("ENCRYPTED_EXTENSION"));
        assertEquals(ccmCiphertextObject, (byte[]) response.get("CCM_CIPHERTEXT_OBJECT"));
    }

    /**
     * Performs an in/out test of the KEX_REPORT command.
     * <p>
     * Test is designed to ensure that the command generates the same data
     * as the handler processes and is mainly a check of the code generator.
     *
     * @param echo {@link Boolean}
     * @param requestCsa {@link Boolean}
     * @param supportedKexSchemes {@link Integer}
     * @param supportedEcdhProfiles {@link Integer}
     * @param requestedKeys {@link List<String>}
     */
    public static void testKexReportLoopback(Boolean echo, Boolean requestCsa, Integer supportedKexSchemes,
            Integer supportedEcdhProfiles, List<String> requestedKeys) {
        byte[] testPayload = CommandClassSecurity2V1.getKexReport(echo, requestCsa, supportedKexSchemes,
                supportedEcdhProfiles, requestedKeys);

        Map<String, Object> response = CommandClassSecurity2V1.handleKexReport(testPayload);
        assertEquals(echo, (Boolean) response.get("ECHO"));
        assertEquals(requestCsa, (Boolean) response.get("REQUEST_CSA"));
        assertEquals(supportedKexSchemes, (Integer) response.get("SUPPORTED_KEX_SCHEMES"));
        assertEquals(supportedEcdhProfiles, (Integer) response.get("SUPPORTED_ECDH_PROFILES"));
        assertEquals(requestedKeys, (List<String>) response.get("REQUESTED_KEYS"));
    }

    /**
     * Performs an in/out test of the KEX_SET command.
     * <p>
     * Test is designed to ensure that the command generates the same data
     * as the handler processes and is mainly a check of the code generator.
     *
     * @param echo {@link Boolean}
     * @param requestCsa {@link Boolean}
     * @param selectedKexScheme {@link Integer}
     * @param selectedEcdhProfile {@link Integer}
     * @param grantedKeys {@link List<String>}
     */
    public static void testKexSetLoopback(Boolean echo, Boolean requestCsa, Integer selectedKexScheme,
            Integer selectedEcdhProfile, List<String> grantedKeys) {
        byte[] testPayload = CommandClassSecurity2V1.getKexSet(echo, requestCsa, selectedKexScheme, selectedEcdhProfile,
                grantedKeys);

        Map<String, Object> response = CommandClassSecurity2V1.handleKexSet(testPayload);
        assertEquals(echo, (Boolean) response.get("ECHO"));
        assertEquals(requestCsa, (Boolean) response.get("REQUEST_CSA"));
        assertEquals(selectedKexScheme, (Integer) response.get("SELECTED_KEX_SCHEME"));
        assertEquals(selectedEcdhProfile, (Integer) response.get("SELECTED_ECDH_PROFILE"));
        assertEquals(grantedKeys, (List<String>) response.get("GRANTED_KEYS"));
    }

    /**
     * Performs an in/out test of the KEX_FAIL command.
     * <p>
     * Test is designed to ensure that the command generates the same data
     * as the handler processes and is mainly a check of the code generator.
     *
     * @param kexFailType {@link String}
     */
    public static void testKexFailLoopback(String kexFailType) {
        byte[] testPayload = CommandClassSecurity2V1.getKexFail(kexFailType);

        Map<String, Object> response = CommandClassSecurity2V1.handleKexFail(testPayload);
        assertEquals(kexFailType, (String) response.get("KEX_FAIL_TYPE"));
    }

    /**
     * Performs an in/out test of the PUBLIC_KEY_REPORT command.
     * <p>
     * Test is designed to ensure that the command generates the same data
     * as the handler processes and is mainly a check of the code generator.
     *
     * @param includingNode {@link Boolean}
     * @param ecdhPublicKey {@link byte[]}
     */
    public static void testPublicKeyReportLoopback(Boolean includingNode, byte[] ecdhPublicKey) {
        byte[] testPayload = CommandClassSecurity2V1.getPublicKeyReport(includingNode, ecdhPublicKey);

        Map<String, Object> response = CommandClassSecurity2V1.handlePublicKeyReport(testPayload);
        assertEquals(includingNode, (Boolean) response.get("INCLUDING_NODE"));
        assertEquals(ecdhPublicKey, (byte[]) response.get("ECDH_PUBLIC_KEY"));
    }

    /**
     * Performs an in/out test of the SECURITY_2_NETWORK_KEY_GET command.
     * <p>
     * Test is designed to ensure that the command generates the same data
     * as the handler processes and is mainly a check of the code generator.
     *
     * @param requestedKey {@link String}
     */
    public static void testSecurity2NetworkKeyGetLoopback(String requestedKey) {
        byte[] testPayload = CommandClassSecurity2V1.getSecurity2NetworkKeyGet(requestedKey);

        Map<String, Object> response = CommandClassSecurity2V1.handleSecurity2NetworkKeyGet(testPayload);
        assertEquals(requestedKey, (String) response.get("REQUESTED_KEY"));
    }

    /**
     * Performs an in/out test of the SECURITY_2_NETWORK_KEY_REPORT command.
     * <p>
     * Test is designed to ensure that the command generates the same data
     * as the handler processes and is mainly a check of the code generator.
     *
     * @param grantedKey {@link String}
     * @param networkKey {@link byte[]}
     */
    public static void testSecurity2NetworkKeyReportLoopback(String grantedKey, byte[] networkKey) {
        byte[] testPayload = CommandClassSecurity2V1.getSecurity2NetworkKeyReport(grantedKey, networkKey);

        Map<String, Object> response = CommandClassSecurity2V1.handleSecurity2NetworkKeyReport(testPayload);
        assertEquals(grantedKey, (String) response.get("GRANTED_KEY"));
        assertEquals(networkKey, (byte[]) response.get("NETWORK_KEY"));
    }

    /**
     * Performs an in/out test of the SECURITY_2_TRANSFER_END command.
     * <p>
     * Test is designed to ensure that the command generates the same data
     * as the handler processes and is mainly a check of the code generator.
     *
     * @param keyRequestComplete {@link Boolean}
     * @param keyVerified {@link Boolean}
     */
    public static void testSecurity2TransferEndLoopback(Boolean keyRequestComplete, Boolean keyVerified) {
        byte[] testPayload = CommandClassSecurity2V1.getSecurity2TransferEnd(keyRequestComplete, keyVerified);

        Map<String, Object> response = CommandClassSecurity2V1.handleSecurity2TransferEnd(testPayload);
        assertEquals(keyRequestComplete, (Boolean) response.get("KEY_REQUEST_COMPLETE"));
        assertEquals(keyVerified, (Boolean) response.get("KEY_VERIFIED"));
    }

    /**
     * Performs an in/out test of the SECURITY_2_COMMANDS_SUPPORTED_REPORT command.
     * <p>
     * Test is designed to ensure that the command generates the same data
     * as the handler processes and is mainly a check of the code generator.
     *
     * @param commandClass {@link List<Integer>}
     */
    public static void testSecurity2CommandsSupportedReportLoopback(List<Integer> commandClass) {
        byte[] testPayload = CommandClassSecurity2V1.getSecurity2CommandsSupportedReport(commandClass);

        Map<String, Object> response = CommandClassSecurity2V1.handleSecurity2CommandsSupportedReport(testPayload);
        assertEquals(commandClass, (List<Integer>) response.get("COMMAND_CLASS"));
    }

    /**
     * Performs an in/out test of the SECURITY_2_CAPABILITIES_REPORT command.
     * <p>
     * Test is designed to ensure that the command generates the same data
     * as the handler processes and is mainly a check of the code generator.
     *
     * @param supportedSpans {@link Integer}
     * @param supportedMpans {@link Integer}
     */
    public static void testSecurity2CapabilitiesReportLoopback(Integer supportedSpans, Integer supportedMpans) {
        byte[] testPayload = CommandClassSecurity2V1.getSecurity2CapabilitiesReport(supportedSpans, supportedMpans);

        Map<String, Object> response = CommandClassSecurity2V1.handleSecurity2CapabilitiesReport(testPayload);
        assertEquals(supportedSpans, (Integer) response.get("SUPPORTED_SPANS"));
        assertEquals(supportedMpans, (Integer) response.get("SUPPORTED_MPANS"));
    }

}
