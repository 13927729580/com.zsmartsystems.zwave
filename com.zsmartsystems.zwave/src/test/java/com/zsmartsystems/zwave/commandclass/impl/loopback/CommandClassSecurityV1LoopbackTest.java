/**
 * Copyright (c) 2016-2017 by the respective copyright holders.
 *
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Eclipse Public License v1.0
 * which accompanies this distribution, and is available at
 * http://www.eclipse.org/legal/epl-v10.html
 */
package com.zsmartsystems.zwave.commandclass.impl.loopback;

import static org.junit.Assert.assertEquals;

import java.util.Map;
import java.util.List;
import com.zsmartsystems.zwave.commandclass.impl.CommandClassSecurityV1;

/**
 * Class to implement loopback tests for command class <b>COMMAND_CLASS_SECURITY</b> version <b>1</b>.
 * <p>
 * Note that this code is autogenerated. Manual changes may be overwritten.
 *
 * @author Chris Jackson - Initial contribution of Java code generator
 */
public class CommandClassSecurityV1LoopbackTest {
    /**
     * Performs an in/out test of the SECURITY_COMMANDS_SUPPORTED_REPORT command.
     * <p>
     * Test is designed to ensure that the command generates the same data
     * as the handler processes and is mainly a check of the code generator.
     *
     * @param reportsToFollow {@link Integer}
     * @param commandClassSupport {@link List<Integer>}
     * @param commandClassControl {@link List<Integer>}
     */
    public static void testSecurityCommandsSupportedReportLoopback(Integer reportsToFollow,
            List<Integer> commandClassSupport, List<Integer> commandClassControl) {
        byte[] testPayload = CommandClassSecurityV1.getSecurityCommandsSupportedReport(reportsToFollow,
                commandClassSupport, commandClassControl);

        Map<String, Object> response = CommandClassSecurityV1.handleSecurityCommandsSupportedReport(testPayload);
        assertEquals(reportsToFollow, (Integer) response.get("REPORTS_TO_FOLLOW"));
        assertEquals(commandClassSupport, (List<Integer>) response.get("COMMAND_CLASS_SUPPORT"));
        assertEquals(commandClassControl, (List<Integer>) response.get("COMMAND_CLASS_CONTROL"));
    }

    /**
     * Performs an in/out test of the SECURITY_SCHEME_GET command.
     * <p>
     * Test is designed to ensure that the command generates the same data
     * as the handler processes and is mainly a check of the code generator.
     *
     * @param supportedSecuritySchemes {@link Integer}
     */
    public static void testSecuritySchemeGetLoopback(Integer supportedSecuritySchemes) {
        byte[] testPayload = CommandClassSecurityV1.getSecuritySchemeGet(supportedSecuritySchemes);

        Map<String, Object> response = CommandClassSecurityV1.handleSecuritySchemeGet(testPayload);
        assertEquals(supportedSecuritySchemes, (Integer) response.get("SUPPORTED_SECURITY_SCHEMES"));
    }

    /**
     * Performs an in/out test of the SECURITY_SCHEME_REPORT command.
     * <p>
     * Test is designed to ensure that the command generates the same data
     * as the handler processes and is mainly a check of the code generator.
     *
     * @param supportedSecuritySchemes {@link Integer}
     */
    public static void testSecuritySchemeReportLoopback(Integer supportedSecuritySchemes) {
        byte[] testPayload = CommandClassSecurityV1.getSecuritySchemeReport(supportedSecuritySchemes);

        Map<String, Object> response = CommandClassSecurityV1.handleSecuritySchemeReport(testPayload);
        assertEquals(supportedSecuritySchemes, (Integer) response.get("SUPPORTED_SECURITY_SCHEMES"));
    }

    /**
     * Performs an in/out test of the NETWORK_KEY_SET command.
     * <p>
     * Test is designed to ensure that the command generates the same data
     * as the handler processes and is mainly a check of the code generator.
     *
     * @param networkKeyByte {@link byte[]}
     */
    public static void testNetworkKeySetLoopback(byte[] networkKeyByte) {
        byte[] testPayload = CommandClassSecurityV1.getNetworkKeySet(networkKeyByte);

        Map<String, Object> response = CommandClassSecurityV1.handleNetworkKeySet(testPayload);
        assertEquals(networkKeyByte, (byte[]) response.get("NETWORK_KEY_BYTE"));
    }

    /**
     * Performs an in/out test of the SECURITY_SCHEME_INHERIT command.
     * <p>
     * Test is designed to ensure that the command generates the same data
     * as the handler processes and is mainly a check of the code generator.
     *
     * @param supportedSecuritySchemes {@link Integer}
     */
    public static void testSecuritySchemeInheritLoopback(Integer supportedSecuritySchemes) {
        byte[] testPayload = CommandClassSecurityV1.getSecuritySchemeInherit(supportedSecuritySchemes);

        Map<String, Object> response = CommandClassSecurityV1.handleSecuritySchemeInherit(testPayload);
        assertEquals(supportedSecuritySchemes, (Integer) response.get("SUPPORTED_SECURITY_SCHEMES"));
    }

    /**
     * Performs an in/out test of the SECURITY_NONCE_REPORT command.
     * <p>
     * Test is designed to ensure that the command generates the same data
     * as the handler processes and is mainly a check of the code generator.
     *
     * @param nonceByte {@link byte[]}
     */
    public static void testSecurityNonceReportLoopback(byte[] nonceByte) {
        byte[] testPayload = CommandClassSecurityV1.getSecurityNonceReport(nonceByte);

        Map<String, Object> response = CommandClassSecurityV1.handleSecurityNonceReport(testPayload);
        assertEquals(nonceByte, (byte[]) response.get("NONCE_BYTE"));
    }

    /**
     * Performs an in/out test of the SECURITY_MESSAGE_ENCAPSULATION command.
     * <p>
     * Test is designed to ensure that the command generates the same data
     * as the handler processes and is mainly a check of the code generator.
     *
     * @param initializationVectorByte {@link byte[]}
     * @param sequenceCounter {@link Integer}
     * @param sequenced {@link Boolean}
     * @param secondFrame {@link Boolean}
     * @param commandByte {@link byte[]}
     * @param receiversNonceIdentifier {@link Integer}
     * @param messageAuthenticationCodeByte {@link byte[]}
     */
    public static void testSecurityMessageEncapsulationLoopback(byte[] initializationVectorByte, Integer sequenceCounter,
            Boolean sequenced, Boolean secondFrame, byte[] commandByte, Integer receiversNonceIdentifier,
            byte[] messageAuthenticationCodeByte) {
        byte[] testPayload = CommandClassSecurityV1.getSecurityMessageEncapsulation(initializationVectorByte,
                sequenceCounter, sequenced, secondFrame, commandByte, receiversNonceIdentifier,
                messageAuthenticationCodeByte);

        Map<String, Object> response = CommandClassSecurityV1.handleSecurityMessageEncapsulation(testPayload);
        assertEquals(initializationVectorByte, (byte[]) response.get("INITIALIZATION_VECTOR_BYTE"));
        assertEquals(sequenceCounter, (Integer) response.get("SEQUENCE_COUNTER"));
        assertEquals(sequenced, (Boolean) response.get("SEQUENCED"));
        assertEquals(secondFrame, (Boolean) response.get("SECOND_FRAME"));
        assertEquals(commandByte, (byte[]) response.get("COMMAND_BYTE"));
        assertEquals(receiversNonceIdentifier, (Integer) response.get("RECEIVERS_NONCE_IDENTIFIER"));
        assertEquals(messageAuthenticationCodeByte, (byte[]) response.get("MESSAGE_AUTHENTICATION_CODE_BYTE"));
    }

    /**
     * Performs an in/out test of the SECURITY_MESSAGE_ENCAPSULATION_NONCE_GET command.
     * <p>
     * Test is designed to ensure that the command generates the same data
     * as the handler processes and is mainly a check of the code generator.
     *
     * @param initializationVectorByte {@link byte[]}
     * @param sequenceCounter {@link Integer}
     * @param sequenced {@link Boolean}
     * @param secondFrame {@link Boolean}
     * @param commandByte {@link byte[]}
     * @param receiversNonceIdentifier {@link Integer}
     * @param messageAuthenticationCodeByte {@link byte[]}
     */
    public static void testSecurityMessageEncapsulationNonceGetLoopback(byte[] initializationVectorByte,
            Integer sequenceCounter, Boolean sequenced, Boolean secondFrame, byte[] commandByte,
            Integer receiversNonceIdentifier, byte[] messageAuthenticationCodeByte) {
        byte[] testPayload = CommandClassSecurityV1.getSecurityMessageEncapsulationNonceGet(initializationVectorByte,
                sequenceCounter, sequenced, secondFrame, commandByte, receiversNonceIdentifier,
                messageAuthenticationCodeByte);

        Map<String, Object> response = CommandClassSecurityV1.handleSecurityMessageEncapsulationNonceGet(testPayload);
        assertEquals(initializationVectorByte, (byte[]) response.get("INITIALIZATION_VECTOR_BYTE"));
        assertEquals(sequenceCounter, (Integer) response.get("SEQUENCE_COUNTER"));
        assertEquals(sequenced, (Boolean) response.get("SEQUENCED"));
        assertEquals(secondFrame, (Boolean) response.get("SECOND_FRAME"));
        assertEquals(commandByte, (byte[]) response.get("COMMAND_BYTE"));
        assertEquals(receiversNonceIdentifier, (Integer) response.get("RECEIVERS_NONCE_IDENTIFIER"));
        assertEquals(messageAuthenticationCodeByte, (byte[]) response.get("MESSAGE_AUTHENTICATION_CODE_BYTE"));
    }

}
